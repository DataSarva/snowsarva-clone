{"search_id":"search_28df13c7ac2f4364a4c4cdd6e261fb2f","results":[{"url":"https://docs.snowflake.com/en/sql-reference/account-usage","title":"Account Usage - Snowflake Documentation","excerpts":["Reference General reference SNOWFLAKE database Account Usage\nSection Title: Account Usage ¶\nContent:\nIn the SNOWFLAKE database, the ACCOUNT_USAGE and READER_ACCOUNT_USAGE schemas enable querying object metadata, as well as historical\nusage data, for your account and all reader accounts (if any) associated with the account.\nSection Title: Account Usage ¶ > Overview of Account Usage schemas ¶\nContent:\nACCOUNT_USAGE :\nViews that display object metadata and usage metrics for your account.\nIn general, these views mirror the corresponding views and table functions in the Snowflake Snowflake Information Schema , but\nwith the following differences:\nRecords for dropped objects included in each view.\nLonger retention time for historical usage data.\nData latency.\nFor more details, see Differences Between Account Usage and Information Schema (in this topic). For more details about each\nview, see ACCOUNT_USAGE Views (in this topic).\nREADER_ACCOUNT_USAGE :\nViews that display object metadata and usage metrics for all the reader accounts that have been created for\nyour account (as a Secure Data Sharing provider).\nThese views are a small subset of the ACCOUNT_USAGE views that apply to reader accounts. Also, each view in this schema contains an\nadditional `READER_ACCOUNT_NAME` column for filtering results by reader account.\nSection Title: Account Usage ¶ > Overview of Account Usage schemas ¶\nContent:\nFor more details about each view, see READER_ACCOUNT_USAGE Views (in this topic).\nNote that these views are empty if no reader accounts have been created for your account.\nSection Title: Account Usage ¶ > Differences between Account Usage and Information Schema ¶\nContent:\nThe Account Usage views and the corresponding views (or table functions) in the Snowflake Information Schema utilize identical\nstructures and naming conventions, but with some key differences, as described in this section:\nSection Title: Account Usage ¶ > Differences between Account Usage and Information Schema ¶\nContent:\n| Difference | Account Usage | Information Schema |\n| Includes dropped objects | Yes | No |\n| Latency of data | From 45 minutes to 3 hours (varies by view) | None |\n| Retention of historical data | 1 Year | From 7 days to 6 months (varies by view/table function) |\nSection Title: Account Usage ¶ > Differences between Account Usage and Information Schema ¶\nContent:\nFor more details, see the following sections.\nSection Title: Account Usage ¶ > ... > Dropped object records ¶\nContent:\nAccount usage views include records for all objects that have been dropped. Many of the views for object types contain an\nadditional `DELETED` column that displays the timestamp when the object was dropped.\nIn addition, because objects can be dropped and recreated with the same name, to differentiate between objects records that have the\nsame name, the account usage views include ID columns, where appropriate, that display the internal IDs generated and assigned to\neach record by the system.\nIf a column for an object name (e.g. the `TABLE_NAME` column) is NULL, that object has been dropped. In this case, the\ncolumns for the names and IDs of the parent objects (e.g. the `DATABASE_NAME` and `SCHEMA_NAME` columns) are also\nNULL.\nNote that in some views, the column for the object name might still contain the name of the object, even if the object has been\ndropped.\nSection Title: Account Usage ¶ > Differences between Account Usage and Information Schema ¶ > Data latency ¶\nContent:\nDue to the process of extracting the data from Snowflake’s internal metadata store, the account usage views have some natural latency:\nFor most of the views, the latency is 2 hours (120 minutes).\nFor the remaining views, the latency varies between 45 minutes and 3 hours.\nFor details, see the list of views for each schema (in this topic). Also, note that these are all maximum time lengths; the actual\nlatency for a given view when the view is queried may be less.\nIn contrast, views/table functions in the Snowflake Information Schema do not have any latency.\n ... \nSection Title: Account Usage ¶ > ACCOUNT_USAGE views ¶\nContent:\nThe ACCOUNT_USAGE schema contains the following views:\nSection Title: Account Usage ¶ > ACCOUNT_USAGE views ¶\nContent:\n| View | Type | Latency [1] | Edition [3] | Notes |\n| ACCESS_HISTORY | Historical | 3 hours | Enterprise Edition (or higher) | Data retained for 1 year. |\n| AGGREGATE_ACCESS_HISTORY | Historical | 3 hours | Enterprise Edition (or higher) | Data retained for 1 year. |\n| AGGREGATE_QUERY_HISTORY | Historical | 3 hours |  |  |\n| AGGREGATION_POLICIES | Object | 2 hours |  |  |\n| ALERT_HISTORY | Historical | 3 hours |  | Data retained for 1 year. |\n| ANOMALIES_DAILY | Historical | 3 hours |  | Data retained for 1 year. |\n| APPLICATION_CONFIGURATIONS | Object | 3 hours |  | Data retained for 1 year. |\n| APPLICATION_CONFIGURATION_VALUE_HISTORY | Historical | 3 hours |  | Data retained for 1 year. |\n| APPLICATION_DAILY_USAGE_HISTORY | Historical | 24 hours |  | Data retained for 1 year. |\n| APPLICATION_SPECIFICATION_STATUS_HISTORY | Historical | 1 hour |  | Data retained for 1 year. |\n ... \nSection Title: Account Usage ¶ > ACCOUNT_USAGE views ¶\nContent:\n| View | Type | Latency [1] | Edition [3] | Notes |\n| ACCESS_HISTORY | Historical | 3 hours | Enterprise Edition (or higher) | Data retained for 1 year. |\n| AGGREGATE_ACCESS_HISTORY | Historical | 3 hours | Enterprise Edition (or higher) | Data retained for 1 year. |\n| AGGREGATE_QUERY_HISTORY | Historical | 3 hours |  |  |\n| AGGREGATION_POLICIES | Object | 2 hours |  |  |\n| BACKUPS | Object | 6 hours |  |  |\n| BLOCK_STORAGE_HISTORY | Historical | 3 hours |  | Data retained for 1 year. |\n| BLOCK_STORAGE_SNAPSHOTS | Object | 3 hours |  |  |\n| CATALOG_LINKED_DATABASE_USAGE_HISTORY | Historical | 3 hours |  | Data retained for 1 year. |\n| CLASS_INSTANCES | Object | 3 hours |  | Data retained for 1 year. |\n| CLASSES | Object | 3 hours |  | Data retained for 1 year. |\n| COLUMN_QUERY_PRUNING_HISTORY | Historical | 4 hours |  | Data retained for 1 year. |\n| COLUMNS | Object | 90 minutes |  |  |\n ... \nSection Title: Account Usage ¶ > READER_ACCOUNT_USAGE views ¶\nContent:\nThe READER_ACCOUNT_USAGE schema contains the following views:\n ... \nSection Title: Account Usage ¶ > Enabling other roles to use schemas in the SNOWFLAKE database ¶\nContent:\nBy default, the SNOWFLAKE database is visible to all users; however, access to schemas in this database can be granted by a user with the\nACCOUNTADMIN role using either of the following approaches:\nGrant IMPORTED PRIVILEGES on the SNOWFLAKE database.\nGrant a SNOWFLAKE database role to an account role.\nImportant\nTo avoid unintentionally granting access to organization-level data, consider using SNOWFLAKE database roles to grant access to views in the ACCOUNT_USAGE schema.\nFor more information, refer to GRANT DATABASE ROLE .\nFor example, to grant IMPORTED PRIVILEGES on the SNOWFLAKE database to two additional roles:\nCopy\nA user with that is granted the `customrole1` role can query a view as follows:\nCopy\nFor additional examples, see Querying the Account Usage views .\nSection Title: Account Usage ¶ > ... > ACCOUNT_ USAGE schema SNOWFLAKE database roles ¶\nContent:\nIn addition, you can grant finer control to accounts using SNOWFLAKE Database roles.\nFor more information on database roles, see database roles .\nACCOUNT_USAGE schemas have four defined SNOWFLAKE database roles, each granted the SELECT privilege on specific views.\n ... \nSection Title: Account Usage ¶ > ... > Database role required to access ACCOUNT_ USAGE views ¶\nContent:\n| View | Database Role |\n| ACCESS_HISTORY view | GOVERNANCE_VIEWER |\n| APPLICATION_CONFIGURATIONS view | SECURITY_VIEWER |\n| AGGREGATE_ACCESS_HISTORY view | GOVERNANCE_VIEWER |\n| AGGREGATE_QUERY_HISTORY view | GOVERNANCE_VIEWER |\n| AGGREGATION_POLICIES view | GOVERNANCE_VIEWER |\n| ANOMALIES_DAILY view | USAGE_VIEWER |\n| APPLICATION_CONFIGURATION_VALUE_HISTORY view | SECURITY_VIEWER |\n| APPLICATION_DAILY_USAGE_HISTORY view | USAGE_VIEWER |\n| APPLICATION_SPECIFICATION_STATUS_HISTORY view | SECURITY_VIEWER |\n| APPLICATION_SPECIFICATIONS view | SECURITY_VIEWER |\n| ARCHIVE_STORAGE_DATA_RETRIEVAL_USAGE_HISTORY view | USAGE_VIEWER |\n| AUTOMATIC_CLUSTERING_HISTORY view | USAGE_VIEWER |\n| BLOCK_STORAGE_HISTORY view | USAGE_VIEWER |\n| BLOCK_STORAGE_SNAPSHOTS view | OBJECT_VIEWER |\n| CATALOG_LINKED_DATABASE_USAGE_HISTORY view | USAGE_VIEWER |\n| CLASS_INSTANCES view | USAGE_VIEWER |\n| CLASSES view | USAGE_VIEWER |\nSection Title: Account Usage ¶ > ... > Database role required to access ACCOUNT_ USAGE views ¶\nContent:\n| View | Database Role |\n| ACCESS_HISTORY view | GOVERNANCE_VIEWER |\n| APPLICATION_CONFIGURATIONS view | SECURITY_VIEWER |\n| AGGREGATE_ACCESS_HISTORY view | GOVERNANCE_VIEWER |\n| AGGREGATE_QUERY_HISTORY view | GOVERNANCE_VIEWER |\n| COLUMN_QUERY_PRUNING_HISTORY view | USAGE_VIEWER |\n| COLUMNS view | OBJECT_VIEWER |\n| COMPLETE_TASK_GRAPHS view | OBJECT_VIEWER |\n| CONTACT_REFERENCES view | GOVERNANCE_VIEWER |\n| CONTACTS view | GOVERNANCE_VIEWER |\n| COPY_FILES_HISTORY view | USAGE_VIEWER |\n| COPY_HISTORY view | USAGE_VIEWER |\n| CORTEX_AGENT_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_AISQL_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_ANALYST_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_DOCUMENT_PROCESSING_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_FINE_TUNING_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_FUNCTIONS_QUERY_USAGE_HISTORY view | USAGE_VIEWER |\n| CORTEX_FUNCTIONS_USAGE_HISTORY view | USAGE_VIEWER |\n ... \nSection Title: Account Usage ¶ > Querying the Account Usage views ¶ > Selecting columns ¶\nContent:\nThe Snowflake-specific views are subject to change. Avoid selecting all columns from these views. Instead, select the columns that you want.\nFor example, if you want the `name` column, use `SELECT name` , rather than `SELECT *` .\nSection Title: Account Usage ¶ > Querying the Account Usage views ¶ > Reconciling cost views ¶\nContent:\nThere are several Account Usage views that contain data related to the cost of compute resources, storage, and data transfers. If you are trying to reconcile these views against a corresponding view in the ORGANIZATION_USAGE schema , you must first set the timezone of the session to UTC.\nFor example, if you are trying to reconcile ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY to the account’s data in ORGANIZATION_USAGE.WAREHOUSE_METERING_HISTORY, you must run the following command before querying the Account Usage view:\n```\nALTER SESSION SET TIMEZONE = UTC ;\n```\nCopy\nSection Title: Account Usage ¶ > Querying the Account Usage views ¶ > Examples ¶\nContent:\nThe following examples show some typical/useful queries using the views in the ACCOUNT_USAGE schema.\nNote\nThese examples assume the SNOWFLAKE database and the ACCOUNT_USAGE schema are in use for the current session. The examples also\nassume the ACCOUNTADMIN role (or a role granted IMPORTED PRIVILEGES on the database) is in use. If they are not in use, execute\nthe following commands before running the queries in the examples:Copy\n ... \nSection Title: Account Usage ¶ > ... > Examples ¶ > Examples: Obtain a query count for every login event ¶\nContent:\nJoin columns from LOGIN_HISTORY, QUERY_HISTORY, and SESSIONS to obtain a query count for each user login event.\nNoteThe SESSIONS view records information starting on July 20-21, 2020, therefore the query result will only contain overlapping\ninformation for each of the three views starting from this date.Copy\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)"]},{"url":"https://docs.snowflake.com/en/user-guide/access-history","title":"Access History | Snowflake Documentation","excerpts":["Section Title: Access History ¶\nContent:\nEnterprise Edition Feature\nAccess History requires Enterprise Edition (or higher). To inquire about upgrading, please contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nThis topic provides concepts on the user access history in Snowflake.\nSection Title: Access History ¶ > Overview ¶\nContent:\nAccess History in Snowflake refers to when the user query reads data and when the SQL statement performs a data write\noperation, such as INSERT, UPDATE, and DELETE along with variations of the COPY command, from the source data object to the target data\nobject. The user access history can be found by querying the ACCESS_HISTORY view in the ACCOUNT_USAGE and ORGANIZATION_USAGE schemas. The\nrecords in these views facilitate regulatory compliance auditing and provide insights on popular and frequently accessed tables and columns\nbecause there is a direct link between the user (i.e. query operator), the query, the table or view, the column, and the data.\nEach row in the ACCESS_HISTORY view contains a single record per SQL statement. The record contains the following kinds of information:\nSection Title: Access History ¶ > Overview ¶\nContent:\nThe *source columns* the query accessed directly and indirectly, such as the underlying tables that the data for the query comes from.\nThe *projected columns* the user sees in the query result, such as the columns specified in a SELECT statement.\nThe columns that are used to determine the query result but are not projected, such as columns in a WHERE clause to filter the result.\nFor example:\n```\nCREATE OR REPLACE VIEW v1 ( vc1 , vc2 ) AS \n SELECT c1 as vc1 , \n       c2 as vc2 \n FROM t \n WHERE t . c3 > 0 \n ;\n```\nCopy\nSection Title: Access History ¶ > Overview ¶\nContent:\nColumns C1 and C2 are source columns that the view accesses directly, which are recorded in the `base_objects_accessed` column of\nthe ACCESS_HISTORY view.\nColumn C3 is used to filter the rows the view includes, which is recorded in the `base_objects_accessed` column of\nthe ACCESS_HISTORY view.\nColumns VC1 and VC2 are projected columns the user sees when querying the view, `SELECT * FROM v1;` , which are recorded in the `direct_objects_accessed` column of the ACCESS_HISTORY view.\nThe same behavior applies to a key column in a WHERE clause. For example:\n```\nCREATE OR REPLACE VIEW join_v ( vc1 , vc2 , c1 ) AS \n  SELECT \n      bt . c1 AS vc1 , \n      bt . c2 AS vc2 , \n      jt . c1 \n  FROM bt , jt \n  WHERE bt . c3 = jt . c1 ;\n```\nCopy\nSection Title: Access History ¶ > Overview ¶\nContent:\nTwo different tables are required to create the view: `bt` (base table) and `jt` (join table.).\nColumns C1, C2, and C3 from the base table and column C1 from the join table are all recorded in the `base_objects_accessed` column\nof the ACCESS_HISTORY view.\nColumns VC1, VC2, and C1 are projected columns the user sees when querying the view, `SELECT * FROM join_v;` , which are\nrecorded in the `direct_objects_accessed` column of the ACCESS_HISTORY view.\nNote\nRecords in the Account Usage QUERY_HISTORY view do not always get recorded in the\nACCESS_HISTORY view. The structure of the SQL statement determines whether Snowflake records an entry in the ACCESS_HISTORY view.\nFor details on the read and write operations Snowflake supports in the ACCESS_HISTORY view, refer to the view Usage notes .\nSection Title: Access History ¶ > Tracking read and write operations ¶\nContent:\nThe ACCESS_HISTORY view in both the ACCOUNT_USAGE and the ORGANIZATION_USAGE schemas includes the following columns:\n```\nquery_id | query_start_time | user_name | direct_objects_accessed | base_objects_accessed | objects_modified | object_modified_by_ddl | policies_referenced | parent_query_id | root_query_id\n```\nCopy\nRead operations are tracked through the first five columns, while the last column, `objects_modified` , specifies the data write information that involved Snowflake columns, tables, and stages.\nThe query in Snowflake and how the database objects were created determines the information Snowflake returns in the `direct_objects_accessed` , `base_objects_accessed` , and `objects_modified` columns.\nSimilarly, if the query references an object protected by a row access policy or a column protected by a masking policy, Snowflake records\nthe policy information in the `policies_referenced` column.\nSection Title: Access History ¶ > Tracking read and write operations ¶\nContent:\nThe `object_modified_by_ddl` column records the DDL operation on a database, schema, table, view, and column. These operations also\ninclude statements that specify a row access policy on a table or view, a masking policy on a column, and tag updates\n(e.g. set a tag, change a tag value) on the object or column.\nThe `parent_query_id` and `root_query_id` columns record query IDs that correspond to:\nA query that performs a read or write operation on another object.\nA query that performs a read or write operation on an object that calls a stored procedure, including nested stored procedure calls. For\ndetails, see ancestor queries (in this topic).\nFor column details, see the Columns section in the ACCESS_HISTORY view.\n ... \nSection Title: Access History ¶ > Column lineage ¶\nContent:\nColumn lineage (i.e. access history for columns) extends the Account Usage ACCESS_HISTORY view to specify how data flows from the source\ncolumn to the target column in a write operation. Snowflake tracks the data from the source columns through all subsequent table objects\nthat reference data from the source columns (e.g. INSERT, MERGE, CTAS) provided that objects in the lineage chain are not dropped.\nSnowflake makes column lineage accessible by enhancing the `objects_modified` column in the ACCESS_HISTORY view.\nColumn lineage provides the following benefits:\n ... \nSection Title: Access History ¶ > Column lineage ¶\nContent:\nFor additional details about column lineage, see:\nExample: Column lineage (in this topic)\n ... \nSection Title: Access History ¶ > Account-level vs. Organization-level access history ¶\nContent:\nAdministrators monitor access history at the account-level by querying the ACCESS_HISTORY view in the account’s ACCOUNT_USAGE schema. There\nis no additional cost associated with the ACCOUNT_USAGE.ACCESS_HISTORY view.\nThe ACCESS_HISTORY view in the ORGANIZATION_USAGE schema gathers the access history of all of the accounts in an organization into a single\nview to provide an organization-level access history. This ORGANIZATION_USAGE.ACCESS_HISTORY view is only found in the organization account .\nOrganization-level access history in the ORGANIZATION_USAGE schema differs from access history in the ACCOUNT_USAGE schema in the\nfollowing ways:\n ... \nSection Title: Access History ¶ > Examples: Read Queries ¶\nContent:\nThe subsections below detail how to query the ACCESS_HISTORY view for read operations for the following use cases:\nObtain the access history for a specific user.\nFacilitate compliance audits for sensitive data access in the last 30 days, based on `object_id` (e.g. a table id), to answer the\nfollowing questions:\nWho accessed the data?\nWhen was the data accessed?\nWhat columns were accessed?\n ... \nSection Title: Access History ¶ > Examples: Write operations ¶\nContent:\nThe subsections below detail how to query the ACCESS_HISTORY view for write operations for the following use cases:\nLoad data from a stage to a table.\nUnload data from a table to a stage.\nUse the PUT command to upload a local file to a stage.\nUse the GET command to retrieve data files from a stage to a local directory.\nTracking sensitive stage data movement.\n ... \nSection Title: Access History ¶ > Examples: Write operations ¶ > Tracking Sensitive stage data movement ¶\nContent:\n66574,\n\"objectName\": \"TEST_DB.TEST_SCHEMA.T7\"\n}\n]with access_history_flatten as (\nselect\nr . value : \"objectId\" as source_id ,\nr . value : \"objectName\" as source_name ,\nr . value : \"objectDomain\" as source_domain ,\nw . value : \"objectId\" as target_id ,\nw . value : \"objectName\" as target_name ,\nw . value : \"objectDomain\" as target_domain ,\nc . value : \"columnName\" as target_column ,\nt . query_start_time as query_start_time\nfrom\n( select * from TEST_DB . ACCOUNT_USAGE . ACCESS_HISTORY ) t ,\nlateral flatten ( input => t . BASE_OBJECTS_ACCESSED ) r ,\nlateral flatten ( input => t . OBJECTS_MODIFIED ) w ,\nlateral flatten ( input => w . value : \"columns\" , outer => true ) c\n),\nsensitive_data_movements ( path , target_id , target_name , target_domain , target_column , query_start_time )\nas\n-- Common Table Expression\n(\n-- Anchor Clause: Get the objects that access S1 directly\nselect\nf .\n ... \nSection Title: Access History ¶ > Example: Column lineage ¶\nContent:\n```\n// 1 \n\n select \n  directSources . value : \"objectId\" as source_object_id , \n  directSources . value : \"objectName\" as source_object_name , \n  directSources . value : \"columnName\" as source_column_name , \n  'DIRECT' as source_column_type , \n  om . value : \"objectName\" as target_object_name , \n  columns_modified . value : \"columnName\" as target_column_name \n from \n  ( \n    select \n      * \n    from \n      snowflake . account_usage . access_history \n  ) t , \n  lateral flatten ( input => t . OBJECTS_MODIFIED ) om , \n  lateral flatten ( input => om . value : \"columns\" , outer => true ) columns_modified , \n  lateral flatten ( \n    input => columns_modified . value : \"directSources\" , \n    outer => true \n  ) directSources \n\n union \n\n // 2 \n\n select \n  baseSources . value : \"objectId\" as source_object_id , \n  baseSources . value : \"objectName\" as source_object_name , \n  baseSources .\nSection Title: Access History ¶ > Example: Column lineage ¶\nContent:\nvalue : \"columnName\" as source_column_name , \n  'BASE' as source_column_type , \n  om . value : \"objectName\" as target_object_name , \n  columns_modified . value : \"columnName\" as target_column_name \n from \n  ( \n    select \n      * \n    from \n      snowflake . account_usage . access_history \n  ) t , \n  lateral flatten ( input => t . OBJECTS_MODIFIED ) om , \n  lateral flatten ( input => om . value : \"columns\" , outer => true ) columns_modified , \n  lateral flatten ( \n    input => columns_modified . value : \"baseSources\" , \n    outer => true \n  ) baseSources \n ;\n```\n ... \nSection Title: Access History ¶ > Example: Track the enforced policy in a query ¶\nContent:\n```\nSELECT * \n from ( \n  select j1 . *, j2 . QUERY_START_TIME as POLICY_CHANGED_TIME , POLICY_BODY \n from \n ( \n  select distinct t1 . *, \n      t4 . value : \"policyId\" ::number as PID \n  from ( select * \n      from SNOWFLAKE . ACCOUNT_USAGE . ACCESS_HISTORY \n      where query_start_time > '2023-07-07' and \n         query_start_time < '2023-07-08' and \n         query_id = '01ad7987-0606-6e2c-0001-dd20f12a9777' ) as t1 , // \n  lateral flatten ( input => t1 . POLICIES_REFERENCED , OUTER => TRUE ) t2 , \n  lateral flatten ( input => t2 . value : \"columns\" , OUTER => TRUE ) t3 , \n  lateral flatten ( input => t3 . value : \"policies\" , OUTER => TRUE ) t4 \n ) as j1 \n left join \n ( \n  select OBJECT_MODIFIED_BY_DDL : \"objectId\" ::number as PID , \n      QUERY_START_TIME , \n      OBJECT_MODIFIED_BY_DDL : \"properties\" . \"policyBody\" . \"value\" as POLICY_BODY \n      from SNOWFLAKE . ACCOUNT_USAGE .\n ... \nSection Title: Access History ¶ > Examples: UDFs ¶ > Call a UDF ¶\nContent:\nConsider the following SQL UDF that calculates the product of two numbers and assume it is stored in the schema named `mydb.udfs` :\nCopy\nCalling `get_product` directly results in recording the UDF details in the `direct_objects_accessed` column:\nCopy\nThis example is analogous to calling a stored procedure (in this topic).\n ... \nSection Title: Access History ¶ > Example: Call a stored procedure ¶\nContent:\nConsider the following stored procedure and assume it is stored in the schema named `mydb.procedures` :\nCopy\nCalling `my_procedure` directly results in recording the procedure details in both the `direct_objects_accessed` and `base_objects_accessed` columns as follows:\nCopy\nThis example is analogous to calling a UDF (in this topic)."]},{"url":"https://docs.snowflake.com/en/sql-reference/data-sharing-usage/listing-access-history","title":"LISTING_ACCESS_HISTORY view - Snowflake Documentation","excerpts":["Reference General reference SNOWFLAKE database Data Sharing Usage LISTING_ACCESS_HISTORY\nSchema:\nData Sharing Usage\nSection Title: LISTING_ACCESS_HISTORY view ¶\nContent:\nPreview Feature — Open\nThis feature is currently in preview and is available to all users.\nThis view in the DATA_SHARING_USAGE schema can be used to explore the history of consumers’ usage of your listings.\nLISTING_ACCESS_HISTORY provides object-level information about queries run against the data shares or Native Apps attached to your listings. For more information about the data provided by the LISTING_ACCESS_HISTORY view, see the Columns section.\nEach row returned by LISTING_ACCESS_HISTORY represents a single time the listing was accessed by a consumer. Because the rows represent queries instead of sessions, it is likely that the same listing will appear multiple times, one row for each query.\nA single consumer query can access objects from multiple listings. The QUERY_TOKEN identifies the query that generated a row in the listing access history.\nTo identify a collection of listing objects accessed by a single consumer query, use the QUERY_TOKEN.\nSection Title: LISTING_ACCESS_HISTORY view ¶\nContent:\nThe LISTING_ACCESS_HISTORY view does not allow providers to obtain any private consumer information, such as the actual text of queries. The\nview also excludes any objects that are not owned by the provider account. For example, if a consumer joins data from your listing with their own data or another\nprovider’s data, only listing objects that you own are returned by the LISTING_ACCESS_HISTORY view.\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| LISTING_GLOBAL_NAME | VARCHAR | Global name of the listing in the Snowflake Marketplace or data exchange that provides the share. |\n| PROVIDER_ACCOUNT_LOCATOR | VARCHAR | Account locator of the share owner. |\n| PROVIDER_ACCOUNT_NAME | VARCHAR | Account name of the share owner. |\n| SHARE_NAME | VARCHAR | Name of the data share that consumers accessed. When IS_SHARE is FALSE, the value is NULL. |\n| CONSUMER_ACCOUNT_LOCATOR | VARCHAR | Account locator of the consumer. |\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| CONSUMER_ACCOUNT_NAME | VARCHAR | Account name of the consumer. |\n| CONSUMER_ACCOUNT_ORGANIZATION | VARCHAR | Name of the organization for the consumer account. |\n| LISTING_OBJECTS_ACCESSED | ARRAY | Use SHARE_OBJECTS_ACCESSED as it contains the same data. When IS_SHARE is FALSE, the value is NULL. See LISTING_OBJECTS_ACCESSED array for formatting. |\n| REGION_GROUP | VARCHAR | Region group where the account of the consumer is located. |\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| CONSUMER_NAME | VARCHAR | Contains the name of the consumer account that accessed, used, or requested a listing. If no name is available, such as for trial accounts, the value is NULL. |\n| IS_SHARE | BOOLEAN | TRUE if the access was on a share. When TRUE, the SHARE_OBJECTS_ACCESSED column provides details about the share objects accessed by the consumer query. |\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| IS_APPLICATION | BOOLEAN | TRUE if the access was on an application. When TRUE, APPLICATION_OBJECTS_ACCESSED column provides details about the application objects accessed by the consumer query. |\n| SHARE_OBJECTS_ACCESSED | ARRAY | Details the share objects accessed by the consumer query. When IS_SHARE is FALSE, the value is NULL. See SHARE_OBJECTS_ACCESSED array for formatting. |\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| APPLICATION_OBJECTS_ACCESSED | ARRAY | Details the application objects accessed by the consumer query. When IS_APPLICATION is FALSE, the value is NULL. See APPLICATION_OBJECTS_ACCESSED array . |\n| APPLICATION_PACKAGE_NAME | VARCHAR | The current name of the application package from which the application was installed. When IS_APPLICATION is FALSE, the value is NULL. |\n| APPLICATION_VERSION | VARCHAR | The version of the application when the query occurred. When IS_APPLICATION is FALSE, the value is NULL |\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| QUERY_TOKEN | VARCHAR | Unique ID for each query run by a consumer. A QUERY_TOKEN does not correlate with any actual query identifier on the consumer side. |\n| QUERY_DATE | DATE | Date when the query was executed. |\n| EXCHANGE_NAME | VARCHAR | Snowflake Marketplace or the data exchange where the listing is available. |\n| SNOWFLAKE_REGION | VARCHAR | Snowflake region where the consumption occurred. |\n| APPLICATION_PATCH_ID | NUMBER | The application patch number when the query occurred. When IS_APPLICATION is FALSE, the value is NULL. |\n ... \nSection Title: LISTING_ACCESS_HISTORY view ¶ > Usage notes ¶ > SHARE_OBJECTS_ACCESSED array ¶\nContent:\nThe SHARE_OBJECTS_ACCESSED array provides details about the objects in a share accessed by a consumer query. The format of an item in the array depends on the type of object that was accessed.\nFunctions:\n```\n{ \n  \"argumentSignature\": (function_signature varchar),\n  \"objectName\": \"DATABASE_NAME.SCHEMA_NAME.FUNCTION_NAME\" ,\n  \"objectID\": \"12345\" ,\n  \"objectDomain\": \"Function\" \n }\n```\nCopy\nStored procedures:\n```\n{ \n  \"argumentSignature\": (function_signature varchar),\n  \"objectName\": \"DATABASE_NAME.SCHEMA_NAME.PROCEDURE_NAME\" \n  \"objectID\": \"12345\" \n  \"objectDomain\": \"Procedure\" \n }\n```\nCopy\nTables, views, and columns:\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Usage notes ¶ > SHARE_OBJECTS_ACCESSED array ¶\nContent:\n```\n[ \n  { \n    \"Columns\": [ \n      { \n        \"columnId\": ######,\n        \"columnName\": \"column1_name\" \n      } ,\n      { \n        \"columnId\": ######,\n        \"columnName\": \"column2_name\" \n      } \n    ] ,\n    \"objectDomain\": \"VIEW\" ,\n    \"objectId\": ###,\n    \"objectName\": \"DATABASE_1.PUBLIC.VIEW_1\" \n  } ,\n  { \n    \"Columns\": [ \n      { \n        \"columnId\": ######,\n        \"columnName\": \"column3_name\" \n      } ,\n      { \n        \"columnId\": ######,\n        \"columnName\": \"column4_name\" \n      } \n    ] ,\n    \"objectDomain\": \"TABLE\" ,\n    \"objectId\": ###,\n    \"objectName\": \"DATABASE_2.PUBLIC.TABLE1\" \n  } \n ]\n```\nCopy\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Usage notes ¶ > APPLICATION_ OBJECTS_ ACCESSED array ¶\nContent:\nThe APPLICATION_OBJECTS_ACCESSED array provides details about the objects in a Native App accessed by a consumer query. The format of an item in the array depends on the type of object that was accessed.\nUnlike the LISTING_OBJECTS_ACCESSED column array results, APPLICATION_OBJECTS_ACCESSED results containing object IDs are unavailable and database names are masked.\nFunctions:\n```\n{ \n  \"argumentSignature\": (function_signature varchar),\n  \"objectName\": \"23662386A408C571B77FDC53691793E4992D1C12.SCHEMA_NAME.FUNCTION_NAME\" ,\n  \"objectDomain\": \"Function\" \n }\n```\nCopy\nStored procedures:\n```\n{ \n  \"argumentSignature\": (function_signature varchar),\n  \"objectName\": \"23662386A408C571B77FDC53691793E4992D1C12.SCHEMA_NAME.PROCEDURE_NAME\" \n  \"objectDomain\": \"Procedure\" \n }\n```\nCopy\nTables, views, and columns:\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Usage notes ¶ > APPLICATION_ OBJECTS_ ACCESSED array ¶\nContent:\n```\n[ \n  { \n    \"Columns\": [ \n      { \n        \"columnName\": \"column1_name\" \n      } ,\n      { \n        \"columnName\": \"column2_name\" \n      } \n    ] ,\n    \"objectDomain\": \"VIEW\" ,\n    \"objectName\": \"5F3297829072D2E23B852D7787825FF762E74EF3.PUBLIC.VIEW_1\" \n  } ,\n  { \n    \"Columns\": [ \n      { \n        \"columnName\": \"column3_name\" \n      } ,\n      { \n        \"columnName\": \"column4_name\" \n      } \n    ] ,\n    \"objectDomain\": \"TABLE\" ,\n    \"objectName\": \"D85A2CE1531C6C1E077FA701713047305BDF5A83.PUBLIC.TABLE1\" \n  } \n ]\n```\nCopy\n ... \nSection Title: LISTING_ACCESS_HISTORY view ¶ > Examples ¶\nContent:\nThis section contains the following example SQL queries for the LISTING_ACCESS_HISTORY view:\nAggregate view of access over time\nAggregate view of access over time by consumer\nAccess count by column\nTable joins\nTable joins by consumer\n ... \nSection Title: LISTING_ACCESS_HISTORY view ¶ > Examples ¶ > Access count by column ¶\nContent:\nFor a given object (table, view), how many times each column was accessed.\nSection Title: LISTING_ACCESS_HISTORY view ¶ > Examples ¶ > Access count by column ¶\nContent:\n```\nselect \n  los . value : \"objectDomain\" ::string as object_type , \n  los . value : \"objectName\" ::string as object_name , \n  cols . value : \"columnName\" ::string as column_name , \n  count ( distinct lah . query_token ) as n_queries , \n  count ( distinct lah . consumer_account_locator ) as n_distinct_consumer_accounts \n from SNOWFLAKE . DATA_SHARING_USAGE . LISTING_ACCESS_HISTORY as lah \n join lateral flatten ( input => lah . listing_objects_accessed ) as los \n join lateral flatten ( input => los . value , path => 'columns' ) as cols \n where true \n  and los . value : \"objectDomain\" ::string in ( 'Table' , 'View' ) \n  and query_date between '2022-03-01' and '2022-04-30' \n  and los . value : \"objectName\" ::string = 'DATABASE_NAME.SCHEMA_NAME.TABLE_NAME' \n  and lah . consumer_account_locator = 'CONSUMER_ACCOUNT_LOCATOR' \n group by 1 , 2 , 3 ;\n```\nCopy\n ... \nSection Title: LISTING_ACCESS_HISTORY view ¶ > Examples ¶ > Table joins by consumer ¶\nContent:\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nColumns\nUsage notes\nExamples"]},{"url":"https://docs.snowflake.com/en/sql-reference/account-usage/columns","title":"COLUMNS view - Snowflake Documentation","excerpts":["Reference General reference SNOWFLAKE database Account Usage COLUMNS\nSchema:\nACCOUNT_USAGE\nSection Title: COLUMNS view ¶\nContent:\nThis Account Usage view displays a row for each column in the tables defined in the account.\nSee also:\nDATABASES view\nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\n| Column | Data Type | Description |\n| COLUMN_ID | NUMBER | Internal/system-generated identifier for the column. |\n| COLUMN_NAME | TEXT | Name of the column. |\n| TABLE_ID | NUMBER | Internal/system-generated identifier for the table or view for the column. |\n| TABLE_NAME | TEXT | Table or view that the column belongs to. |\n| TABLE_SCHEMA_ID | NUMBER | Internal/system-generated identifier for the schema of the table or view for the column. |\n| TABLE_SCHEMA | TEXT | Schema that the table or view belongs to. |\n| TABLE_CATALOG_ID | NUMBER | Internal/system-generated identifier for the database of the table or view for the column. |\n| TABLE_CATALOG | TEXT | Database that the table or view belongs to. |\n| ORDINAL_POSITION | NUMBER | Ordinal position of the column in the table/view. |\n| COLUMN_DEFAULT | TEXT | Default value of the column. |\n| IS_NULLABLE | TEXT | Whether the column allows NULL values. |\n| DATA_TYPE | TEXT | Data type of the column. |\nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\nThis column shows the standard Snowflake data type of the column. The DATA_TYPE_ALIAS column displays the original\ndata type name that was specified for the column when the table was created, or when the column was altered. |\n|CHARACTER_MAXIMUM_LENGTH |NUMBER |Maximum length in characters of string columns. |\n|CHARACTER_OCTET_LENGTH |NUMBER |Maximum length in bytes of string columns. |\n|NUMERIC_PRECISION |NUMBER |Numeric precision of numeric columns. |\n|NUMERIC_PRECISION_RADIX |NUMBER |Radix of precision of numeric columns. |\n|NUMERIC_SCALE |NUMBER |Scale of numeric columns. |\n|DATETIME_PRECISION |NUMBER |Not applicable for Snowflake. |\n|INTERVAL_TYPE |TEXT |Not applicable for Snowflake. |\n|INTERVAL_PRECISION |TEXT |Not applicable for Snowflake. |\n|CHARACTER_SET_CATALOG |TEXT |Not applicable for Snowflake. |\n|CHARACTER_SET_SCHEMA |TEXT |Not applicable for Snowflake. |\n|CHARACTER_SET_NAME |TEXT |Not applicable for Snowflake.\nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\n|\n|COLLATION_CATALOG |TEXT |Not applicable for Snowflake. |\n|COLLATION_SCHEMA |TEXT |Not applicable for Snowflake. |\n|COLLATION_NAME |TEXT |Not applicable for Snowflake. |\n|DOMAIN_CATALOG |TEXT |Not applicable for Snowflake. |\n|DOMAIN_SCHEMA |TEXT |Not applicable for Snowflake. |\n|DOMAIN_NAME |TEXT |Not applicable for Snowflake. |\n|UDT_CATALOG |TEXT |Not applicable for Snowflake. |\n|UDT_SCHEMA |TEXT |Not applicable for Snowflake. |\n|UDT_NAME |TEXT |Not applicable for Snowflake. |\n|SCOPE_CATALOG |TEXT |Not applicable for Snowflake. |\n|SCOPE_SCHEMA |TEXT |Not applicable for Snowflake. |\n|SCOPE_NAME |TEXT |Not applicable for Snowflake. |\n|MAXIMUM_CARDINALITY |TEXT |Not applicable for Snowflake. |\n|DTD_IDENTIFIER |TEXT |Not applicable for Snowflake. |\n|IS_SELF_REFERENCING |TEXT |Not applicable for Snowflake. |\n|IS_IDENTITY |TEXT |Whether the column is an identity column.\nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\n|\n|IDENTITY_GENERATION |TEXT |Whether an identity column’s value is always generated or only generated by default. Snowflake only supports `BY DEFAULT` . |\n|IDENTITY_START |TEXT |Not applicable for Snowflake. |\n|IDENTITY_INCREMENT |TEXT |Not applicable for Snowflake. |\n|IDENTITY_MAXIMUM |TEXT |Not applicable for Snowflake. |\n|IDENTITY_MINIMUM |TEXT |Not applicable for Snowflake. |\n|IDENTITY_CYCLE |TEXT |Whether the value of an identity column allows cycling. Snowflake only supports `NO CYCLE` . |\n|IDENTITY_ORDERED |TEXT |If `YES` , the column is an identity column and has the ORDER property. If `NO` , the column is an identity column and has the NOORDER property. |\n|SCHEMA_EVOLUTION_RECORD |TEXT |Records information about the latest triggered Schema Evolution for a given table column. This column contains the following subfields:\nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\nEvolutionType: The type of the triggered schema evolution (ADD_COLUMN or DROP_NOT_NULL). EvolutionMode: The triggering ingestion mechanism (COPY, SNOWPIPE, or SNOWPIPE_STREAMING). FileName: The file name that triggered the evolution (NULL for SNOWPIPE_STREAMING). TriggeringTime: The approximate time when the column was evolved. QueryId or PipeId: A unique identifier of the triggering query or pipe (QUERY ID for COPY, PIPE ID for SNOWPIPE, or NULL for SNOWPIPE_STREAMING). Pipe name: Fully qualified pipe name that triggered schema evolution (SNOWPIPE_STREAMING only). Channel name: Channel that triggered schema evolution (SNOWPIPE_STREAMING only). offsetTokenUpperBound: An offset at or before which schema evolution was triggered (SNOWPIPE_STREAMING only). |\n|COMMENT |TEXT |Comment for the column. |\n|DELETED |TIMESTAMP_LTZ |Date and time when the column was deleted.\n ... \nSection Title: COLUMNS view ¶ > Columns ¶\nContent:\nFor example, the BIGINT type is synonymous with the NUMBER type. If BIGINT was specified as the type for a column,\nthen BIGINT is displayed in this DATA_TYPE_ALIAS column.\nFor columns in tables that were created before the 2025_07 behavior change bundle was enabled, and not altered after the behavior change, the value in this column is NULL. For more information, see COLUMNS view (multiple schemas): New column . |\n ... \nSection Title: COLUMNS view ¶ > Examples ¶\nContent:\nThe following example retrieves all columns in the `myTable` table defined in the `mydb` database:\n```\nSELECT * \n  FROM SNOWFLAKE . ACCOUNT_USAGE . COLUMNS \n  WHERE \n    table_catalog = 'mydb' AND \n    table_name = 'myTable' AND \n    deleted IS NULL ;\n```\nCopy\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nColumns\nUsage notes\nExamples"]},{"url":"https://docs.snowflake.com/en/sql-reference/account-usage/application_daily_usage_history","title":"APPLICATION_DAILY_USAGE_HISTORY view | Snowflake Documentation","excerpts":["Reference General reference SNOWFLAKE database Account Usage APPLICATION_DAILY_USAGE_HISTORY\nSchema:\nACCOUNT_USAGE\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶\nContent:\nUse this view to return the daily credit and storage usage for Snowflake Native Apps in an account within the last 365 days\n(1 year).\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Columns ¶\nContent:\nThe following table provides definitions for the APPLICATION_DAILY_USAGE_HISTORY view columns.\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Columns ¶\nContent:\n| Field | Data type | Description |\n| APPLICATION_NAME | VARCHAR | The application name. |\n| APPLICATION_ID | NUMBER | An internal, system-generated identifier for the application. |\n| LISTING_GLOBAL_NAME | VARCHAR | The listing global name that appears in Snowflake Marketplace or in the data exchange hosting the application. |\n| USAGE_DATE | DATE | The date the Snowflake Native App usage occurred. |\n| CREDITS_USED | NUMBER | The number of credits consumed by the Snowflake Native App in a day. |\n| CREDITS_USED_BREAKDOWN | ARRAY | An array of data objects that identify the Snowflake service that consumed daily credits. See CREDITS_USED_BREAKDOWN array for formatting. |\n| STORAGE_BYTES | NUMBER | The daily average of storage bytes used by the Snowflake Native App. |\n| STORAGE_BYTES_BREAKDOWN | ARRAY | An array of data objects that identify the type and number of storage bytes used. See STORAGE_BYTES_BREAKDOWN array for formatting. |\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶\nContent:\nThe maximum latency for this view is one day.\nUsage is attributed to the start day when usage events span multiple days.\nThe APPLICATION_DAILY_USAGE_HISTORY view and the Snowsight cost management tools can return different daily credit and storage usage values. This discrepancy is caused by the methods used to determine daily credit and storage usage. To determine these values, the APPLICATION_DAILY_USAGE_HISTORY view uses the current session’s TIMEZONE parameter and the Snowsight cost management tools use Coordinated Universal Time (UTC). To resolve any discrepancies, Snowflake recommends setting the TIMEZONE parameter to UTC.\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶ > CREDITS_USED_BREAKDOWN array ¶\nContent:\nThe CREDITS_USED_BREAKDOWN array provides details about the services that consumed daily credits.\nExample:\n```\n[ \n  { \n    \"credits\": 0.005840921,\n    \"serviceType\": \"AUTO_CLUSTERING\" \n  } ,\n  { \n    \"credits\": 0.115940725,\n    \"serviceType\": \"SERVERLESS_TASK\" \n  } ,\n  { \n    \"credits\": 6.033448041,\n    \"serviceType\": \"SNOWPARK_CONTAINER_SERVICES\" \n  } \n ]\n```\nCopy\nThe following table provides descriptions for the key-value pairs in the objects in the array.\n ... \nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶ > CREDITS_USED_BREAKDOWN array ¶\nContent:\n`AUTO_CLUSTERING` — See Automatic Clustering .\n`DATA_QUALITY_MONITORING` — See Introduction to data quality checks .\n`MATERIALIZED_VIEW` — See Working with Materialized Views .\n`PIPE` — See Snowpipe .\n`SEARCH_OPTIMIZATION` — See Search optimization service .\n`SERVERLESS_TASK` — See Introduction to tasks .\n`SNOWPARK_CONTAINER_SERVICES` — See Snowpark Container Services .\n`WAREHOUSE_METERING` — See Overview of warehouses . |\nThe following are used in the determination of credit consumption:\nThe credits used by objects in the Snowflake Native App. For example, auto-clustering on tables in the Snowflake Native App.\nThe credits used by the warehouses owned by the Snowflake Native App.\nThe credits used by the compute pools dedicated to the Snowflake Native App.\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶ > STORAGE_ BYTES_ BREAKDOWN array ¶\nContent:\nThe STORAGE_BYTES_BREAKDOWN array provides details about the services that consumed storage.\nExample:\n```\n[ \n  { \n    \"bytes\": 34043221,\n    \"storageType\": \"DATABASE\" \n  } ,\n  { \n    \"bytes\": 109779541,\n    \"storageType\": \"FAILSAFE\" \n  } \n ]\n```\nCopy\nThe following table provides descriptions for the key-value pairs in the objects in the array.\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶ > STORAGE_ BYTES_ BREAKDOWN array ¶\nContent:\n| Field | Data type | Description |\n| `bytes` | INTEGER | Number of storage bytes used. |\n| `storageType` | VARCHAR | The storage type, which can be one of the following values: |\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Usage notes ¶ > STORAGE_ BYTES_ BREAKDOWN array ¶\nContent:\n`DATABASE` : Database storage.\n`FAILSAFE` : Fail-safe storage .\n`HYBRID_TABLE` : Storage for hybrid tables . |\nOnly data stored in the Snowflake Native App is used to determine storage byte consumption. External databases created by the Snowflake Native App are not included in the determination of this value.\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Examples ¶\nContent:\nRetrieve the daily credit and storage usage for a Snowflake Native App in an account and order the results by usage date:\n```\nSELECT * \n  FROM SNOWFLAKE . ACCOUNT_USAGE . APPLICATION_DAILY_USAGE_HISTORY \n  ORDER BY usage_date DESC ;\n```\nCopy\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nColumns\nUsage notes\nExamples\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > Privacy Preference Center\nContent:\nYour Opt Out Preference Signal is Honored\nYour Privacy\nStrictly Necessary Cookies\nPerformance Cookies\nFunctional Cookies\nTargeting Cookies\n ... \nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > ... > Your Privacy > Strictly Necessary Cookies\nContent:\nAlways Active\nThese cookies are necessary for the website to function and cannot be switched off. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not then work. These cookies do not store any personally identifiable information.\nCookies Details‎\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > ... > Your Privacy > Performance Cookies\nContent:\nPerformance Cookies\nThese cookies allow us to count visits and traffic sources so we can measure and improve the performance of our site. They help us to know which pages are the most and least popular and see how visitors move around the site.    All information these cookies collect is aggregated and therefore anonymous. If you do not allow these cookies we will not know when you have visited our site, and will not be able to monitor its performance.\nCookies Details‎\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > ... > Your Privacy > Functional Cookies\nContent:\nFunctional Cookies\nThese cookies enable the website to provide enhanced functionality and personalisation. They may be set by us or by third party providers whose services we have added to our pages.    If you do not allow these cookies then some or all of these services may not function properly.\nCookies Details‎\nSection Title: APPLICATION_ DAILY_ USAGE_ HISTORY view ¶ > ... > Your Privacy > Targeting Cookies\nContent:\nTargeting Cookies\nThese cookies may be set through our site by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant adverts on other sites. They do not store directly identifiable personal information, but are based on uniquely identifying your browser and internet device. If you do not allow these cookies, you will experience less targeted advertising.\nCookies Details‎"]},{"url":"https://select.dev/posts/snowflake-access-history","title":"Snowflake Access History: 8 ways to audit your account","publish_date":"2024-04-28","excerpts":["Section Title: Snowflake Access History: 8 ways to audit your account\nContent:\nIan Whitestone . Sunday, April 28, 2024\nCopy link\nSection Title: Snowflake Access History: 8 ways to audit your account > Table of Contents\nContent:\nWhat is in the Snowflake Access History?\nAccess History is a view provided in the [Snowflake database](https://docs.snowflake.com/en/sql-reference/snowflake-db) that is one of the most useful datasets when it comes to auditing and understanding usage in your Snowflake account. In this post, I’ll dive into what data the access history contains, and then share a number of different examples you can run in your account today.\nSection Title: Snowflake Access History: 8 ways to audit your account > What is in the Snowflake Access History?\nContent:\nThe Access History contains 1 row per query executed in your account. For each query, it stores a number of different columns about objects accessed and/or modified by the query.\nTo start with, there are three columns that are helpful for looking up the queries you are interested in:\n`query_id` : the unique identifier for the query\n`user_name` : the user who ran the query\n`query_start_time` : when the query started\nIf additional information about the query is required, like the role it was executed with or the warehouse it ran on, you can join the access history dataset with the [Snowflake Query History](https://select.dev/posts/snowflake-query-history) view.\nIn terms of **what objects the query accessed** , the view provides two columns:\nSection Title: Snowflake Access History: 8 ways to audit your account > What is in the Snowflake Access History?\nContent:\n`direct_objects_accessed` : a JSON array of data objects the query directly accesses\n`base_objects_accessed` : a JSON array of data objects that a query either directly or indirectly accesses (i.e. the underlying tables that populate a view)\nFor **objects a query modified** , there are two columns:\n`objects_modified` : a JSON array that specifies the objects modified by a query. This will be populated for `INSERT` , `UPDATE` , `MERGE` , `CREATE` or similar types of queries that update/insert/delete records in a table\n`objects_modified_by_ddl` : contains information about the DDL operation on a database, schema, table, view and/or column.\nSection Title: Snowflake Access History: 8 ways to audit your account > ... > Direct vs. Base Objects Accessed\nContent:\nTo understand the difference between **direct** and **base objects accessed** , consider the following query which accesses two columns from a **view** named `user_sales_summary` :\n```\n1 select 2 \tuser_name , 3 \ttotal_sales 4 from  user_sales_summary\n```\nThe `direct_objects_accessed` column would include 1 entry for the direct access of the `user_sales_summary` view, while the `base_objects_accessed` column would contain two entries for the two underlying tables ( `users` and `sales` ) that power the view.\nSection Title: Snowflake Access History: 8 ways to audit your account > ... > Access History Data Retention\nContent:\nSimilar to other account usage views like the [Snowflake Query History](https://select.dev/posts/snowflake-query-history) , Snowflake retains data from the last 365 days.\nSection Title: ... > Is Access History available to all Snowflake customers?\nContent:\nThe access history view is only available for Snowflake customers on a [Snowflake Enterprise editions](https://select.dev/posts/snowflake-pricing) or higher.\nNow that we’ve covered the basics, let’s get into some real examples you can run in your account to answer a variety of common questions.\nSection Title: ... > 1. Find all tables a given user accessed in the last 30 days\nContent:\nThe query below shows how to find all tables accessed by a given user in the last 30 days. Because the `base_objects_accessed` column is an array, we must use a `lateral` join combined with the `flatten` table function to explode each entry in the array into a separate row. You’ll see this pattern used throughout the blog post.\nSection Title: ... > 1. Find all tables a given user accessed in the last 30 days\nContent:\n```\n1 with 2 -- This will output 1 row per table accessed in a query 3 access_history_flattened  as ( 4 select 5        access_history . query_id , 6        access_history . query_start_time , 7        access_history . user_name , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  admin . audit . access_history_last_30d  as  access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 where 14 \t\t    access_history . query_start_time  > current_date - 30 15 )\n```\nExpand Code\nNote how I filter on `object_domain='Table'` . You can modify this as required to answer related questions like:\nWhat views did a user access?\nWhat functions did they use?\nSection Title: Snowflake Access History: 8 ways to audit your account > 2. Find all tables accessed in a schema?\nContent:\nTo find all tables accessed in a particular schema, we can leverage the `access_history_flattened` [CTE](https://select.dev/posts/snowflake-ctes) from above. The `object_name` present in Access History will always be the fully qualified name, meaning it will be in the format of `database_name.schema_name.table_name` . As a result, we parse this object name to get the database and schema name, and then filter as needed:\nSection Title: Snowflake Access History: 8 ways to audit your account > 2. Find all tables accessed in a schema?\nContent:\n```\n1 with 2 -- This will output 1 row per table accessed in a query 3 access_history_flattened  as ( 4 select 5        access_history . query_id , 6        access_history . query_start_time , 7        access_history . user_name , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  admin . audit . access_history_last_30d  as  access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 ) , 14 access_history_flattened_w_names  as ( 15 select\n```\nExpand Code\nSection Title: ... > 3. Return all users who accessed a specific table in the last 30 days\nContent:\nImagine you are trying to identify users that may have accessed sensitive data in a table. You can leverage the access_history view to quickly identify the full list of users:\n```\n1 with 2 -- This will output 1 row per table accessed in a query 3 access_history_flattened  as ( 4 select 5        access_history . query_id , 6        access_history . query_start_time , 7        access_history . user_name , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  admin . audit . access_history_last_30d  as  access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 where 14 \t   access_history . query_start_time  > current_date - 30 -- adjust as needed 15 ) ,\n```\nExpand Code\nSection Title: Snowflake Access History: 8 ways to audit your account > 4. Identify Unused Tables\nContent:\nI previously wrote about how to [identify unused tables](https://select.dev/posts/snowflake-unused-tables) by leveraging the access history view. You can refer to that post for a detailed explanation. Here is the code you can use:\n```\n1 with 2 access_history_flattened  as ( 3 select 4        access_history . query_id , 5        access_history . query_start_time , 6        access_history . user_name , 7        objects_accessed . value :objectId:: integer as  table_id , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  snowflake . account_usage . access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 ) , 14 table_access_history  as ( 15 select\n```\nExpand Code\nSection Title: Snowflake Access History: 8 ways to audit your account > 5. Identify Unused Views\nContent:\nWe can easily modify the query from above to identify Views that have not been used in the last 30 days. All we need to do is change `object_domain = 'Table'` to `object_domain = 'View'` :\n```\n1 with 2 access_history_flattened  as ( 3 select 4        access_history . query_id , 5        access_history . query_start_time , 6        access_history . user_name , 7        objects_accessed . value :objectId:: integer as  table_id , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  snowflake . account_usage . access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 ) , 14 table_access_history  as ( 15 select\n```\nExpand Code\nSection Title: ... > 6. Identify the most common columns accessed in a given table\nContent:\nThe examples thus far have solely addressed questions about table/schema access. We can go a layer deeper to analyze column usage for a given table by leveraging the `columns` array present in the `base/direct_objects_accessed` fields. After performing an extra `lateral flatten` , we can get a dataset with 1 row per column accessed in a query (see `access_history_flattened_columns` CTE).\nSection Title: ... > 6. Identify the most common columns accessed in a given table\nContent:\n```\n1 with 2 -- This will output 1 row per table accessed in a query 3 access_history_flattened  as ( 4 select 5        access_history . query_id , 6        access_history . query_start_time , 7        access_history . user_name , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  admin . audit . access_history_last_30d  as  access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 where 14 \t   access_history . query_start_time  > current_date - 30 -- adjust as needed 15 ) ,\n```\nExpand Code\nSection Title: ... > 7. Return all users who accessed a specific column in the last 30 days\nContent:\nWorking off the example from above, we can easily identify users who have accessed a specific column:\n```\n1 with 2 -- This will output 1 row per table accessed in a query 3 access_history_flattened  as ( 4 select 5        access_history . query_id , 6        access_history . query_start_time , 7        access_history . user_name , 8        objects_accessed . value :objectName:: text as  object_name , 9        objects_accessed . value :objectDomain:: text as  object_domain , 10        objects_accessed . value : columns as  columns_array 11 12 from  admin . audit . access_history_last_30d  as  access_history ,  lateral flatten ( access_history . base_objects_accessed ) as  objects_accessed 13 where 14 \t   access_history . query_start_time  > current_date - 30 -- adjust as needed 15 ) ,\n```\nExpand Code\nSection Title: ... > 8. Identify all queries that have modified a table\nContent:\nWhen investigating why or how a given table changes, it can be helpful to quickly identify the queries or users that modified the object. Or perhaps you want to see how often a table is being updated. Using similar approaches to ones from above, we can identify all queries that have modified a table by flattening the `objects_modified` column:"]},{"url":"https://docs.snowflake.com/release-notes/bcr-bundles/2024_05/bcr-1641","title":"LISTING_ACCESS_HISTORY view: New columns | Snowflake Documentation","excerpts":["Release notes Behavior change announcements Previous bundles 2024_05 Bundle LISTING_ACCESS_HISTORY view: New columns\nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶\nContent:\nAttention\nThis behavior change is in the 2024_05 bundle.\nFor the current status of the bundle, refer to Bundle History .\nWhen this behavior change bundle is enabled, the LISTING_ACCESS_HISTORY view includes the following new columns:\nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶\nContent:\n| Column name | Data type | Description |\n| IS_SHARE | BOOLEAN | TRUE if the access was on a share. |\n| When TRUE, the LISTING_OBJECTS_ACCESSED column provides details about the share objects accessed by the consumer query. |  |  |\n| IS_APPLICATION | BOOLEAN | TRUE if the access was on an application. |\n| When TRUE, APPLICATION_OBJECTS_ACCESSED column provides details about the application objects accessed by the consumer query. |  |  |\n| SHARE_OBJECTS_ACCESSED | ARRAY | See LISTING_OBJECTS_ACCESSED array for formatting. |\n| Is NULL when IS_SHARE is FALSE. |  |  |\nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶\nContent:\nNote: this column has the same data as the LISTING_OBJECTS_ACCESSED column.\nIt is recommended to use SHARE_OBJECTS_ACCESSED instead of LISTING_OBJECTS_ACCESSED as it may be deprecated in the future. |\n|APPLICATION_OBJECTS_ACCESSED |ARRAY |See APPLICATION_OBJECTS_ACCESSED Array for formatting.\nIs NULL when IS_APPLICATION is FALSE. |\n|APPLICATION_PACKAGE_NAME |VARCHAR |The current name of the application package from which the application was installed.\nIs NULL when IS_APPLICATION is FALSE. |\n|APPLICATION_VERSION |VARCHAR |The version of the application when this query occurred.\nIs NULL when IS_APPLICATION is FALSE. |\n|APPLICATION_PATCH_ID |INTEGER |The patch number of the application when this query occurred.\nIs NULL when IS_APPLICATION is FALSE. |\nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶ > APPLICATION_ OBJECTS_ ACCESSED Array ¶\nContent:\nThe APPLICATION_OBJECTS_ACCESSED array provides details about the objects in an application accessed by a consumer query.\nThe format of an item in the array depends on the type of object that was accessed.\nNote\nObject IDs are not available and database names are masked.\n ... \nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶ > ... > Tables, views, and columns ¶\nContent:\n```\n[ \n  { \n    \"Columns\": [ \n      { \n        \"columnName\": \"column1_name\" \n      } ,\n      { \n        \"columnName\": \"column2_name\" \n      } \n    ] ,\n    \"objectDomain\": \"VIEW\" ,\n    \"objectName\": \"5F3297829072D2E23B852D7787825FF762E74EF3.PUBLIC.VIEW_1\" \n  } ,\n  { \n    \"Columns\": [ \n      { \n        \"columnName\": \"column3_name\" \n      } ,\n      { \n        \"columnName\": \"column4_name\" \n      } \n    ] ,\n    \"objectDomain\": \"TABLE\" ,\n    \"objectName\": \"D85A2CE1531C6C1E077FA701713047305BDF5A83.PUBLIC.TABLE1\" \n  } \n ]\n```\nCopy\nRef: 1641\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nSection Title: LISTING_ ACCESS_ HISTORY view: New columns ¶ > ... > Tables, views, and columns ¶\nContent:\nAPPLICATION_OBJECTS_ACCESSED Array"]},{"url":"https://medium.com/%40peggie7191/account-usage-views-in-snowflake-82be6feb7c64","title":"ACCOUNT_USAGE Views In Snowflake - Medium","excerpts":["Mar 31, 2025 · The ACCOUNT_USAGE schema in Snowflake provides comprehensive metadata at the account level. It contains detailed information about all objects ..."]},{"url":"https://docs.snowflake.com/en/user-guide/collaboration/listings/organizational/org-listing-governance","title":"Organizational listing governance - Snowflake Documentation","excerpts":["[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSnowflake Horizon Catalog\nApplications and tools for connecting to Snowflake\nVirtual warehouses\nDatabases, Tables, & Views\nData types\nData Integration\nSnowflake Openflow\nApache Iceberg™\nApache Iceberg™ Tables\nSnowflake Open Catalog\nData engineering\nData loading\nDynamic Tables\nStreams and Tasks\ndbt Projects on Snowflake\nData Unloading\nStorage Lifecycle Policies\nMigrations\nQueries\nListings\nCollaboration\nSnowflake AI & ML\nAlerts & Notifications\nSecurity\nData Governance\nPrivacy\nOrganizations & Accounts\nBusiness continuity & data recovery\nPerformance optimization\nCost & Billing\nGuides Listings Organizational listings Organizational listing governance\nSection Title: Organizational listing governance ¶\nContent:\nEnterprise Edition Feature\nAvailable in the organization account, which requires Enterprise Edition or higher. To inquire about upgrading, please contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nOrganization-level access history provides data governors with the information they need to track\nwhen a consumer’s query reads from a data product made available by a provider through an organizational listing. The data governor can\ndetermine which account provided the organizational listing and exactly which data object was accessed. They can also determine if the data\nobject provided by the organizational listing is protected by a policy (such as a masking policy or row access policy) in the provider’s\naccount.\nSection Title: Organizational listing governance ¶\nContent:\nYou can gain these insights into the consumer queries by using the organization account to query\nthe ACCESS_HISTORY view of the ORGANIZATION_USAGE schema. This ACCESS_HISTORY view contains the\nfollowing columns related to the governance of organizational listings:\n`provider_base_objects_accessed` - Specifies the data objects in the provider’s account that were accessed by the consumer query.\n`provider_policies_referenced` - If a consumer query accessed base objects that are protected by a policy in the provider’s\naccount, this column lists the policy.\nFor example, if an organization administrator wants to know all the intra-organization, cross-account queries that have accessed data\nobjects via organizational listings, they could execute the following query *from the organization account* :\n```\nSELECT * FROM snowflake . organization_usage . access_history \n  WHERE provider_base_objects_accessed IS NOT NULL ;\n```\nCopy\nWas this page helpful?\nYes No\nSection Title: Organizational listing governance ¶\nContent:\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nRelated content\nAbout organizational listings\nAccess History\nLanguage: **English**\nEnglish\nFrançais\nDeutsch\n日本語\n한국어\nPortuguês"]},{"url":"https://docs.snowflake.com/en/sql-reference/account-usage/views","title":"VIEWS view - Snowflake Documentation","excerpts":["[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSQL data types reference\nSQL command reference\nFunction and stored procedure reference\nClass reference\nScripting reference\nGeneral reference\nAPI reference\nReference General reference SNOWFLAKE database Account Usage VIEWS\nSchema:\nACCOUNT_USAGE\nSection Title: VIEWS view ¶\nContent:\nThis Account Usage view displays a row for each view in the account, not including the views in the ACCOUNT_USAGE, READER_ACCOUNT_USAGE, and INFORMATION_SCHEMA schemas.\nSee also:\nTABLES view\nSection Title: VIEWS view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| TABLE_ID | NUMBER | Internal/system-generated identifier for the view. |\n| TABLE_NAME | VARCHAR | Name of the view. |\n| TABLE_SCHEMA_ID | NUMBER | Internal/system-generated identifier for the schema that the view belongs to. |\n| TABLE_SCHEMA | VARCHAR | Schema that the view belongs to. |\n| TABLE_CATALOG_ID | NUMBER | Internal/system-generated identifier for the database that the view belongs to. |\n| TABLE_CATALOG | VARCHAR | Database that the view belongs to. |\n| TABLE_OWNER | VARCHAR | Name of the role that owns the view. |\n| VIEW_DEFINITION | VARCHAR | Text of the query expression for the view. |\n| CHECK_OPTION | VARCHAR | Not applicable for Snowflake. |\n| IS_UPDATABLE | VARCHAR | Not applicable for Snowflake. |\n| INSERTABLE_INTO | VARCHAR | Not applicable for Snowflake. |\n| IS_SECURE | VARCHAR | Specifies whether the view is secure. |\n| CREATED | TIMESTAMP_LTZ | Date and time when the view was created. |\nSection Title: VIEWS view ¶ > Columns ¶\nContent:\n| Column Name | Data Type | Description |\n| TABLE_ID | NUMBER | Internal/system-generated identifier for the view. |\n| TABLE_NAME | VARCHAR | Name of the view. |\n| TABLE_SCHEMA_ID | NUMBER | Internal/system-generated identifier for the schema that the view belongs to. |\n| TABLE_SCHEMA | VARCHAR | Schema that the view belongs to. |\n| LAST_ALTERED | TIMESTAMP_LTZ | Date and time the object was last altered by a DML, DDL, or background metadata operation. See Usage Notes . |\n| LAST_DDL | TIMESTAMP_LTZ | Timestamp of the last DDL operation performed on the table or view. |\nSection Title: VIEWS view ¶ > Columns ¶\nContent:\nAll supported table/view DDL operations update this field:\n{ CREATE | ALTER | DROP | UNDROP } TABLE\n{ CREATE | ALTER | DROP } VIEW\nAll ALTER TABLE operations update this field, including setting or unsetting a table parameter (for example, COMMENT,\nDATA_RETENTION_TIME, etc.) and changes to table columns (ADD / MODIFY / RENAME / DROP).\nFor more information, see the Usage Notes . |\n|LAST_DDL_BY |VARCHAR |The current username for the user who executed the last DDL operation. If the user has been dropped, shows `DROPPED_USER(<id>)` .\nSection Title: VIEWS view ¶ > Columns ¶\nContent:\nFor dropped users, you can join the `<id>` with the USER_ID column in the USERS view of the ACCOUNT_USAGE or ORGANIZATION_USAGE schema. |\n|DELETED |TIMESTAMP_LTZ |Date and time when the view was deleted. |\n|COMMENT |VARCHAR |Comment for the view. |\n|INSTANCE_ID |NUMBER |Internal/system-generated identifier for the instance which the object belongs to. |\n|OWNER_ROLE_TYPE |VARCHAR |The type of role that owns the object, for example `ROLE` . . If a Snowflake Native App owns the object, the value is `APPLICATION` . . Snowflake returns NULL if you delete the object because a deleted object does not have an owner role. |\nSection Title: VIEWS view ¶ > Usage notes ¶\nContent:\nLatency for the view may be up to 90 minutes.\nThe view does not recognize the MANAGE GRANTS privilege and consequently may show less information compared to a SHOW command\nexecuted by a user who holds the MANAGE GRANTS privilege.\nThe LAST_ALTERED column is updated when the following operations are performed on an object:For views and tables, use the LAST_DDL column for the last modification time for an object.\nDDL operations.\nDML operations (for tables only). This column is updated even when no rows are affected by the DML statement.\nBackground maintenance operations on metadata performed by Snowflake.\nThe value in the LAST_DDL column is updated as follows:\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\nSection Title: VIEWS view ¶ > Usage notes ¶\nContent:\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nColumns\nUsage notes\nLanguage: **English**\nEnglish\nFrançais\nDeutsch\n日本語\n한국어\nPortuguês"]}],"usage":[{"name":"sku_search","count":1}]}