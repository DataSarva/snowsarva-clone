{
  "search_id": "search_b56087590e5b44c1a9f18381d284b5f2",
  "results": [
    {
      "url": "https://docs.snowflake.com/en/user-guide/access-history",
      "title": "Access History | Snowflake Documentation",
      "excerpts": [
        "Section Title: Access History \u00b6 > Tracking read and write operations \u00b6\nContent:\nThe `object_modified_by_ddl` column records the DDL operation on a database, schema, table, view, and column. These operations also\ninclude statements that specify a row access policy on a table or view, a masking policy on a column, and tag updates\n(e.g. set a tag, change a tag value) on the object or column.\nThe `parent_query_id` and `root_query_id` columns record query IDs that correspond to:\nA query that performs a read or write operation on another object.\nA query that performs a read or write operation on an object that calls a stored procedure, including nested stored procedure calls. For\ndetails, see ancestor queries (in this topic).\nFor column details, see the Columns section in the ACCESS_HISTORY view.\n ... \nSection Title: Access History \u00b6 > Tracking read and write operations \u00b6 > Multiple statements in a single request \u00b6\nContent:\nWhen you use Snowsight to execute multiple statements, it runs the queries one at a time and returns the `query_id` of the last executed query. You can find all executed statements and their return values in the ACCESS_HISTORY view.\nFeatures like the Snowflake Python connector or the Snowflake SQL API combine multiple SQL statements into a single request and return a\nsingle `query_id` for all of the statements. This number is actually a parent query id for all of the individual\nstatements. To return the `query_id` of each statement that comprised the request, you must query the ACCESS_HISTORY view using the `parent_query_id` . For example, if the request returned `query_id = 6789` , then you can return the query ids of the individual\nstatements by executing the following:Copy\n ... \nSection Title: Access History \u00b6 > Column lineage \u00b6\nContent:\nRoot Cause Analysis :\nColumn lineage provides a mechanism to trace the data to its source, which can help to pinpoint points of failure resulting from\npoor data quality and reduce the number of columns to analyze during the troubleshooting process.\n ... \nSection Title: Access History \u00b6 > Account-level vs. Organization-level access history \u00b6\nContent:\nAdditional columns :\nThe ORGANIZATION_USAGE.ACCESS_HISTORY view in the organization account contains additional columns that provide insights related to organizational listings . These columns can be used to determine which of\nthe data products attached to an organization listing were accessed by a consumer\u2019s query, and whether those data products are protected\nby a policy such as a masking policy. For more information, see Organizational listing governance .\nAdditional cost :\nThe ORGANIZATION_USAGE.ACCESS_HISTORY view in the organization account is a premium view that incurs the following costs:\nCompute costs associated with the serverless tasks that populate the ACCESS_HISTORY view.\nStorage costs associated with storing the data in the ACCESS_HISTORY view.\nFor more information about these costs, see Costs associated with premium views .\n ... \nSection Title: Access History \u00b6 > Querying the ACCESS_ HISTORY View \u00b6\nContent:\nThe following sections provide example queries for the ACCESS_HISTORY view.\nNote that some of the example queries filter on the `query_start_time` column to increase query performance. Another option to\nincrease performance is to query over narrower time ranges.\nSection Title: Access History \u00b6 > Examples: Read Queries \u00b6\nContent:\nThe subsections below detail how to query the ACCESS_HISTORY view for read operations for the following use cases:\nObtain the access history for a specific user.\nFacilitate compliance audits for sensitive data access in the last 30 days, based on `object_id` (e.g. a table id), to answer the\nfollowing questions:\nWho accessed the data?\nWhen was the data accessed?\nWhat columns were accessed?\n ... \nSection Title: Access History \u00b6 > Example: Column lineage \u00b6\nContent:\nThe following example queries the ACCESS_HISTORY view and uses the FLATTEN function to flatten the `objects_modified` column.\nAs a representative example, execute the following SQL query in your Snowflake account to produce the table below, where the numbered\ncomments indicate the following:\n`// 1` : Get the mapping between the `directSources` field and the target column.\n`// 2` : Get the mapping between the `baseSources` field and the target column.\n ... \nSection Title: Access History \u00b6 > Examples: UDFs \u00b6 > Call a UDF \u00b6\nContent:\nConsider the following SQL UDF that calculates the product of two numbers and assume it is stored in the schema named `mydb.udfs` :\nCopy\nCalling `get_product` directly results in recording the UDF details in the `direct_objects_accessed` column:\nCopy\nThis example is analogous to calling a stored procedure (in this topic).\n ... \nSection Title: Access History \u00b6 > Example: Call a stored procedure \u00b6\nContent:\nConsider the following stored procedure and assume it is stored in the schema named `mydb.procedures` :\nCopy\nCalling `my_procedure` directly results in recording the procedure details in both the `direct_objects_accessed` and `base_objects_accessed` columns as follows:\nCopy\nThis example is analogous to calling a UDF (in this topic).\nSection Title: Access History \u00b6 > Example: Ancestor queries with stored procedures \u00b6\nContent:\nYou can use the `parent_query_id` and `root_query_id` columns to understand how stored procedure calls relate to each other.\nSuppose that you have three different stored procedure statements and you run them in the following order:\nCopy\nA query on the ACCESS_HISTORY view records the information as follows:\nCopy\nSection Title: Access History \u00b6 > Example: Ancestor queries with stored procedures \u00b6\nContent:\nThe first row corresponds to calling the second procedure named `myproc_parent` as shown in the `direct_objects_accessed` column.The `parent_query_id` and `root_query_id` columns return NULL because you called this stored procedure directly. The second row corresponds to the query that calls the first procedure named `myproc_child` as shown in the `direct_objects_accessed column` .The `parent_query_id` and `root_query_id` columns return the same query ID because the query calling `myproc_child` was\ninitiated by the query calling `myproc_parent` , which you called directly. The third row corresponds to the query that accessed the table named `mytable` in the `myproc_child` procedure as shown in\nthe `direct_objects_accessed` column.The `parent_query_id` column returns the query ID of the query that accessed `mytable` , which corresponds to calling `myproc_child` .\nSection Title: Access History \u00b6 > Example: Ancestor queries with stored procedures \u00b6\nContent:\nThat stored procedure was initiated by the query calling `myproc_parent` , which is shown in the `root_query_id` column.\n ... \nSection Title: Access History \u00b6 > Example: Join \u00b6\nContent:\nOverview\nTracking read and write operations\nColumn lineage\nMasking and row access policy references\nAccount-level vs. Organization-level access history\nSupported Objects\nQuerying the ACCESS_HISTORY View\nExamples: Read Queries\nExamples: Write operations\nExample: Column lineage\nExample: Track row access policy references\nExample: Track masking policy references\nExample: Track the enforced policy in a query\nExamples: UDFs\nExamples: Tracking objects modified by a DDL operation\nExample: Call a stored procedure\nExample: Ancestor queries with stored procedures\nExample: Sequence\nExample: Join\nRelated content\nAccount Usage\nACCESS_HISTORY view\nLanguage: **English**\nEnglish\nFran\u00e7ais\nDeutsch\n\u65e5\u672c\u8a9e\n\ud55c\uad6d\uc5b4\nPortugu\u00eas"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/release-notes/bcr-bundles/2023_08/bcr-1265",
      "title": "ACCESS_HISTORY View: New parent_query_id and root_query_id columns | Snowflake Documentation",
      "excerpts": [
        "Release notes Behavior change announcements Previous bundles 2023_08 bundle ACCESS_HISTORY View: New PARENT_QUERY_ID and ROOT_QUERY_ID columns\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\nAttention\nThis behavior change is in the 2023_08 bundle.\nFor the current status of the bundle, refer to Bundle History .\nThe Account Usage ACCESS_HISTORY view behaves as follows:\nBefore the change\nA query on the view does not include the `parent_query_id` and `root_query_id` columns.\nAfter the change\nA query on the view includes the `parent_query_id` and `root_query_id` columns, which are defined as follows:\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\n| Column name | Data type | Description |\n| `parent_query_id` | TEXT | The query ID of the parent job or NULL if the job does not have a parent. |\n| `root_query_id` | TEXT | The query ID of the top most job in the chain or NULL if the job does not have a parent. |\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\nThese columns start to record data when the 2023_08 bundle is enabled and are the last two columns in the view. The query ID corresponds\nto a query in the `query_id` column in the Account Usage ACCESS_HISTORY view. The columns record query IDs for these kinds of\nqueries:\nA query performs a read or write operation on another object.The read or write operation must be an operation that the ACCESS_HISTORY view\ncurrently supports.\nA query performs a read or write operation on an object that calls a stored procedure. Nested stored procedure calls are also supported.\nFor example, if you have these statements run in order:\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\n```\nCREATE OR REPLACE PROCEDURE myproc_child () \n RETURNS INTEGER \n LANGUAGE SQL \n AS \n $$ \n  BEGIN \n  SELECT * FROM mydb . mysch . mytable ; \n  RETURN 1 ; \n  END \n $$; \n\n CREATE OR REPLACE PROCEDURE myproc_parent () \n RETURNS INTEGER \n LANGUAGE SQL \n AS \n $$ \n  BEGIN \n  CALL myproc_child (); \n  RETURN 1 ; \n  END \n $$; \n\n CALL myproc_parent ();\n```\nCopy\nA query on the ACCESS_HISTORY view records the information as follows:\n```\nUSE ROLE GOVERNANCE_VIEWER ; \n\n SELECT \n  query_id , \n  parent_query_id , \n  root_query_id , \n  direct_objects_accessed \n FROM \n  SNOWFLAKE . ACCOUNT_USAGE . ACCESS_HISTORY ;\n```\nCopy\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\n```\n+----------+-----------------+---------------+-----------------------------------+ \n | QUERY_ID | PARENT_QUERY_ID | ROOT_QUERY_ID |      DIRECT_OBJECTS_ACCESSED      | \n +----------+-----------------+---------------+-----------------------------------+ \n |  1       | NULL            | NULL          | [{\"objectName\": \"myproc_parent\"}] | \n |  2       | 1               | 1             | [{\"objectName\": \"myproc_child\"}]  | \n |  3       | 2               | 1             | [{\"objectName\": \"mytable\"}]       | \n +----------+-----------------+---------------+-----------------------------------+\n```\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\nThe first row corresponds to calling the second procedure named `myproc_parent` as shown in the `direct_objects_accessed` column.The `parent_query_id` and `root_query_id` columns return NULL because you called this stored procedure directly. The second row corresponds to the query that calls the first procedure named `myproc_child` as shown in the `direct_objects_accessed` column.The `parent_query_id` and `root_query_id` columns return the same query ID because the query calling `myproc_child` was initiated by the query calling `myproc_parent` , which you called directly. The third row corresponds to the query that accessed the table named `mytable` in the `myproc_child` procedure as shown in\nthe `direct_objects_accessed` column.The `parent_query_id` column returns the query ID of the query that accessed `mytable` , which corresponds to calling `myproc_child` .\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\nThat stored procedure was initiated by the query calling `myproc_parent` , which is shown in the `root_query_id` column.\nSection Title: ACCESS_ HISTORY View: New `parent_ query_ id` and `root_ query_ id` columns \u00b6\nContent:\nRef: 1265\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/sql-reference/functions/query_history",
      "title": "QUERY_HISTORY , QUERY_HISTORY_BY_* | Snowflake Documentation",
      "excerpts": [
        "Reference Function and stored procedure reference Table QUERY_HISTORY\nCategories:\nInformation Schema , Table functions\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6\nContent:\nYou can use the QUERY_HISTORY family of table functions to query Snowflake query history along various dimensions:\nQUERY_HISTORY returns queries within a specified time range.\nQUERY_HISTORY_BY_SESSION returns queries within a specified session and time range.\nQUERY_HISTORY_BY_USER returns queries submitted by a specified user within a specified time range.\nQUERY_HISTORY_BY_WAREHOUSE returns queries executed by a specified warehouse within a specified time range.\nEach function is optimized for querying along the specified dimension. The results can be further filtered using SQL predicates.\nSee also:\nQUERY_HISTORY view (Account Usage) Monitor query activity with Query History (Snowsight dashboard)\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Syntax \u00b6\nContent:\n```\nQUERY_HISTORY ( \n      [ END_TIME_RANGE_START => <constant_expr> ] \n      [, END_TIME_RANGE_END => <constant_expr> ] \n      [, RESULT_LIMIT => <num> ] \n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] ) \n\n QUERY_HISTORY_BY_SESSION ( \n      [ SESSION_ID => <constant_expr> ] \n      [, END_TIME_RANGE_START => <constant_expr> ] \n      [, END_TIME_RANGE_END => <constant_expr> ] \n      [, RESULT_LIMIT => <num> ] \n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] ) \n\n QUERY_HISTORY_BY_USER ( \n      [ USER_NAME => '<string>' ] \n      [, END_TIME_RANGE_START => <constant_expr> ] \n      [, END_TIME_RANGE_END => <constant_expr> ] \n      [, RESULT_LIMIT => <num> ] \n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] ) \n\n QUERY_HISTORY_BY_WAREHOUSE ( \n      [ WAREHOUSE_NAME => '<string>' ] \n      [, END_TIME_RANGE_START => <constant_expr> ] \n      [, END_TIME_RANGE_END => <constant_expr> ] \n      [,\n ... \nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Usage notes \u00b6\nContent:\nReturns queries run by the current user. Also returns queries run by any user when the executing role, or a higher role in a hierarchy, has either of the following privileges:For more information, see Virtual warehouse privileges . The MONITOR or OPERATE privilege on the user-managed warehouses where the queries were run. The MONITOR or OPERATE privilege on the task. Exception: If the task executes an owner\u2019s right stored procedure or UDF, the role requires at least MONITOR privilege on the warehouse on which the task executed to view the stored procedure query and the UDF query. The MONITOR EXECUTION privilege on the account in which the task resides. Exceptions: Neither stored procedures nor user-defined functions (UDFs) can run this query. When you call an Information Schema table function, your session must use the INFORMATION_SCHEMA, *or* the function name must be fully-qualified.\n ... \nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `query_type` | VARCHAR | DML, query, etc. If the query is currently running, or the query failed, then the query type may be UNKNOWN. |\n| `session_id` | NUMBER | Session that executed the statement. |\n| `authn_event_id` | NUMBER | ID for the event for the authentication of the user for this query. This ID corresponds to the value in the `event_id` column in the LOGIN_HISTORY view. ^ |\n| `user_name` | VARCHAR | User who issued the query. |\n ... \nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `role_name` | VARCHAR | Role that was active in the session at the time of the query. |\n| `warehouse_name` | VARCHAR | Warehouse that the query executed on, if any. |\n| `warehouse_size` | VARCHAR | Size of the warehouse when this statement executed. |\n| `warehouse_type` | VARCHAR | Type of the warehouse when this statement executed. |\n| `cluster_number` | NUMBER | The cluster (in a multi-cluster warehouse) that this statement executed on. |\n| `query_tag` | VARCHAR | Query tag set for this statement through the QUERY_TAG session parameter. |\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `execution_status` | VARCHAR | Execution status for the query: resuming_warehouse, running, queued, blocked, success, failed_with_error, or failed_with_incident. |\n| `error_code` | NUMBER | Error code, if the query returned an error |\n| `error_message` | VARCHAR | Error message, if the query returned an error |\n| `start_time` | TIMESTAMP_LTZ | Statement start time |\n ... \nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `credits_used_cloud_services` | NUMBER | Number of credits used for cloud services. |\n| `release_version` | VARCHAR | Release version in the format of `_major_release_ . _minor_release_ . _patch_release_` . |\n| `external_function_total_invocations` | NUMBER | The aggregate number of times that this query called remote services. For important details, see the Usage Notes. |\n| `external_function_total_sent_rows` | NUMBER | The total number of rows that this query sent in all calls to all remote services. |\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `external_function_total_received_rows` | NUMBER | The total number of rows that this query received from all calls to all remote services. |\n| `external_function_total_sent_bytes` | NUMBER | The total number of bytes that this query sent in all calls to all remote services. |\n| `external_function_total_received_bytes` | NUMBER | The total number of bytes that this query received from all calls to all remote services. |\n| `is_client_generated_statement` | BOOLEAN | Indicates whether the query was client-generated. |\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `query_hash` | VARCHAR | The hash value computed based on the canonicalized SQL text. |\n| `query_hash_version` | NUMBER | The version of the logic used to compute `QUERY_HASH` . |\n| `query_parameterized_hash` | VARCHAR | The hash value computed based on the parameterized query. |\n| `query_parameterized_hash_version` | NUMBER | The version of the logic used to compute `QUERY_PARAMETERIZED_HASH` . |\n| `transaction_id` | NUMBER | ID of the transaction that contains the statement or `0` if the statement is not executed within a transaction. |\nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `query_acceleration_bytes_scanned` | NUMBER | Number of bytes scanned by the query acceleration service . |\n| `query_acceleration_partitions_scanned` | NUMBER | Number of partitions scanned by the query acceleration service. |\n| `query_acceleration_upper_limit_scale_factor` | NUMBER | Upper limit scale factor that a query would have benefited from. |\n ... \nSection Title: QUERY_ HISTORY , QUERY_ HISTORY_ BY_ * \u00b6 > Output \u00b6\nContent:\n| Column Name | Data Type | Description |\n| `query_id` | VARCHAR | The statement\u2019s unique id. |\n| `query_text` | VARCHAR | Text of the SQL statement. |\n| `database_name` | VARCHAR | Database that was specified in the context of the query at compilation. |\n| `schema_name` | VARCHAR | Schema that was specified in the context of the query at compilation. |\n| `rows_inserted` | NUMBER | Number of rows inserted by the query. |\n| `query_retry_time` | NUMBER | Total execution time (in milliseconds) for query retries caused by actionable errors. For more information, see Query retry columns . |\n| `query_retry_cause` | VARCHAR | Error that caused the query to retry. If there is no query retry, the field is NULL. For more information, see Query retry columns . |\n| `fault_handling_time` | NUMBER | Total execution time (in milliseconds) for query retries caused by errors that are *not* actionable. For more information, see Query retry columns . |"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/sql-reference/account-usage/access_history",
      "title": "ACCESS_HISTORY view - Source: Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSQL data types reference\nSQL command reference\nFunction and stored procedure reference\nClass reference\nScripting reference\nGeneral reference\nAPI reference\nReference General reference SNOWFLAKE database Account Usage ACCESS_HISTORY\nSchema:\nACCOUNT_USAGE\n ... \nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\n```\n\nCopy |\n\n### Column descriptions \u00b6\n\nThe following table provides a description of each column in the view. |Column Name |Data Type |Description |\n| --- | --- | --- |\n|`query_id` |VARCHAR |An internal, system-generated identifier for the SQL statement. This value is also mentioned in the QUERY\\_HISTORY view . |\n|`query_start_time` |TIMESTAMP\\_LTZ |The statement start time (UTC time zone). |\n|`user_name` |VARCHAR |The user who issued the query. |\n|`direct_objects_accessed` |ARRAY |A JSON array of data objects such as user-defined functions (i.e. UDFs and UDTFs), stored procedures, tables, views, and columns\ndirectly named in the query explicitly or through shortcuts such as using an asterisk (i.e. `*` ). Virtual columns can be returned in this field. For additional notes about UDFs, see Usage notes .\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\n|\n|`base_objects_accessed` |ARRAY |A JSON array of all base data objects to execute a query, including columns, external functions, UDFs, and stored procedures. In this example, the fields in the first array specify a UDF. These same fields in the first array also specify a stored procedure,\nwhen applicable. Note the following:\n\n* This field specifies view names or view columns, including virtual columns, if a shared view is accessed in a data sharing consumer\n  account. * For additional notes about UDFs, see Usage notes . |\n|`objects_modified` |ARRAY |A JSON array that specifies the objects that were associated with a write operation in the query. The UDF and stored procedure array is the same as what is shown earlier and appears in the arrays for `baseSources` and `directSources` depending on how the access took place. For brevity, this example omits the UDF and stored procedure array.\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\nFor additional notes about UDFs, see Usage notes . |\n|`object_modified_by_ddl` |OBJECT |Specifies the DDL operation on a database, schema, table, view, and column. These operations also include statements that specify a\nrow access policy on a table or view, a masking policy on a column, and tag updates (e.g. set a tag, change a tag value) on the\nobject or column. |\n|`policies_referenced` |ARRAY |Specifies information about the enforced masking policy set on the column and the enforced row access policy set on the table,\nincluding policies set on intermediate objects or columns. |\n|`parent_query_id` |VARCHAR |The query ID of the parent job or NULL if the job does not have a parent. |\n|`root_query_id` |VARCHAR |The query ID of the top most job in the chain or NULL if the job does not have a parent.\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\n|\n\n### JSON field descriptions \u00b6\n\nThe following table defines the fields in the JSON array for the `base_objects_accessed` , `direct_objects_accessed` , and `objects_modified` columns. |Field |Data Type |Description |\n| --- | --- | --- |\n|accountName [[ 1 ]]() |VARCHAR |The account locator of the consumer account that queried the provider\u2019s data object. If the query wasn\u2019t executed by a consumer,\nthis field is omitted. |\n|columnId |NUMBER |A column ID that is unique within the account. This value is identical to the columnID in the COLUMNS view . |\n|columnName |VARCHAR |The name of the accessed column. For policies, specifies the column on which the masking policy is set. |\n|objectId |NUMBER |An identifier for the object, which is unique within a given account and domain. This number will match:\n\n* The `TABLE_ID` number for a table, view, or materialized view.\n ... \nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\n|\n|policyName |VARCHAR |The fully-qualified name of the policy. |\n|policyId |NUMBER |An identifier for the policy, which is unique within a given account and domain. This value matches the identifier for a masking\npolicy in the MASKING\\_POLICIES view or the identifier for a row access policy in the ROW\\_ACCESS\\_POLICIES view . |\n|policyKind |VARCHAR |Either: MASKING\\_POLICY or ROW\\_ACCESS\\_POLICY |\n|argumentSignature |VARCHAR |The name and data type for each argument in the UDF or stored procedure. |\n|dataType | |The data type of the return value for a UDF or stored procedure. This value helps to differentiate two or more UDFs that have the same name but different return types. |\n|joinObjects |VARCHAR |If a query contains a join, returns an array containing the joined objects and type of join. |\n|joinObject |VARCHAR |The table or view that was joined with the accessed object.\n ... \nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\ncolumns: {\n\"email\": {\nobjectId: {\n\"value\": 1\n} ,\n\"subOperationType\": \"ADD\"\n}\n}\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\n```\n\nCopy\n\nThe `subOperationType` value can be one of the following:\n\n* `ADD` specifies adding a compound property (e.g. add a column, set allowed values). * `DROP` specifies removing a compound property. * `ALTER` specifies modifying a compound property. The `objectId` specifies the identifier for the column or object, except for allowed tag values which do not have an\nidentifier. ## Usage notes \u00b6\n\nLatency and historical data :\n    * The view displays data starting from February 22, 2021. * Latency for the view may be up to 180 minutes (3 hours). Ancestor queries :\n    The `parent_query_id` and `root_query_id` columns begin to record data starting on January 15-16, 2024, depending on when\nyour Snowflake account was updated based on the `2023_08` behavior change bundle transitioning to enabled by default.\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\nThis date is\nnecessary to distinguish between the following records in the view:\n\n* Queries that ran before the bundle was enabled by default. * Queries that ran after the feature was enabled by default but do not have a value in the `parent_query_id` . General notes :\n    * For increased performance, filter queries on the `query_start_time` column and choose narrower time ranges. For sample queries,\n  see Querying the ACCESS\\_HISTORY View . * Secure Views. The log record contains the underlying base table (i.e. `base_objects_accessed` ) to generate the view. Examples\n  include queries on other Account Usage and Organization Usage views and queries on base tables for extract, transform, and load\n  (i.e. ETL) operations. * Records in the QUERY\\_HISTORY view do not always get recorded in the\n  ACCESS\\_HISTORY view. The structure of the SQL statement determines whether Snowflake records an entry in the ACCESS\\_HISTORY view.\n ... \nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\nThe provider cannot\n  see the record that corresponds to `v1` . Hybrid tables :\n    Short-running queries that operate exclusively against hybrid tables will no\nlonger generate a record in the QUERY\\_HISTORY view, in QUERY\\_HISTORY view , or\nin the output of the QUERY\\_HISTORY table function. To monitor such queries, use the AGGREGATE\\_QUERY\\_HISTORY . To monitor Access History for such queries, use the AGGREGATE\\_ACCESS\\_HISTORY . This view allows you to more easily monitor high-throughput operational\nworkloads for Access History. Snowflake Native App Framework notes :\n    Some queries related to a Snowflake Native App are redacted. For details, see Information redacted from SQL commands and views .\nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\nTag-based masking notes :\n    If a user accesses a table or view protected by a tag-based masking policy , the `policies_referenced` column contains the masking policy applied through the tag when Snowflake enforces the masking policy on the\nprotected column. The ACCESS\\_HISTORY view does not record any tag information. UDFs & Stored Procedure notes :\n    These notes apply to external functions, UDFs and UDTFs for all languages, including when these functions have the `SECURE` property,\nand stored procedures with owner\u2019s rights and caller\u2019s rights:\n\nColumn details:\n\n* The `direct_objects_accessed` column records explicit mention of these functions and procedures in a query. Snowflake does not record nested UDFs (i.e. a UDF mentioned in the definition of another UDF) in this column. * The `base_objects_accessed` column records external functions, shared functions, non-SQL UDFs, and stored procedures that are\n  called in a query.\n ... \nSection Title: ACCESS_HISTORY view \u00b6 > Columns \u00b6 > Sample column values \u00b6\nContent:\nThe ACCESS\\_HISTORY view records the query on View\\_A and the Base\\_Table, not View\\_B and View\\_C. * The operations to update streams. * Data movement resulting from replication. * Failed queries, although logged in the QUERY\\_HISTORY view, will _not_ be logged in the ACCESS\\_HISTORY view. ## Usage Notes: Column Lineage \u00b6\n\nThese additional notes pertain to column lineage:\n\nSupported operations :\n    Column lineage tracks details for the following SQL operations:\n\n* CREATE TABLE \u2026 AS SELECT (CTAS)\n* CREATE TABLE \u2026 CLONE\n* INSERT \u2026 SELECT \u2026\n* MERGE\n* UPDATE , two possible variations, for example:\n  \n    + Self-update:\n        \n        ```\n        UPDATE mydb . s1 . t1 SET col_1 = col_1 + 1 ;\n        ```\n        \n        Copy\n    + Two table update:\n        \n        ```\n        UPDATE mydb . s1 . t1 FROM mydb . s2 . t2 SET t1 . col1 = t2 ."
      ]
    },
    {
      "url": "https://stackoverflow.com/questions/78914764/how-to-get-the-parent-query-id-and-root-id-in-snowflake",
      "title": "How to get the parent Query Id and root Id in Snowflake? - Stack Overflow",
      "excerpts": [
        "How to get the parent Query Id and root Id in Snowflake? - Stack Overflow\nSkip to main content\n[Stack Overflow](https://stackoverflow.com)\n ... \nSection Title: Collectives\u2122 on Stack Overflow\nContent:\nFind centralized, trusted content and collaborate around the technologies you use most.\nLearn more about Collectives\n**Teams**\nQ&A for work\nConnect and share knowledge within a single location that is structured and easy to search.\n[Learn more about Teams](https://stackoverflow.co/teams/)\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nAsk Question\nAsked 1 year, 1 month ago\nModified 1 year ago\nViewed 155 times\n0\nI have written a script that retrieves the status of all procedures, including any child procedures executed within a parent procedure. The script works correctly when all child procedures complete successfully. However, it fails to capture and populate details if any child procedure encounters a failure.\nThe steps my script follows are:\nIt identifies the procedure name.\nIt checks the query history for all relevant details of the procedure.\nIt also queries the access history to capture any child procedures or associated queries and corresponding Parent and Root Query Id.\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nThe issue seems to be that access history only retains data for queries that have successfully completed. **My requirement is to obtain the parent or root query ID,** regardless of whether the query succeeded or failed. If a procedure has run, it should be visible in the results, irrespective of its outcome.\nHow can I modify my approach to achieve this?\n**Script**\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\n```\nWITH PARENT_RUN AS (\n    SELECT\n    Q.QUERY_ID,\n    Q.QUERY_TEXT,\n    Q.DATABASE_NAME AS RUN_DB,\n    Q.SCHEMA_NAME AS RUN_SCHEMA,\n    Q.QUERY_TYPE,\n    Q.SESSION_ID,\n    Q.USER_NAME,\n    Q.ROLE_NAME,\n    Q.WAREHOUSE_NAME,\n    Q.WAREHOUSE_SIZE,\n    Q.WAREHOUSE_TYPE,\n    Q.QUERY_TAG,\n    Q.EXECUTION_STATUS,\n    Q.ERROR_CODE,\n    Q.ERROR_MESSAGE,\n    Q.START_TIME,\n    Q.END_TIME,\n    Q.EXECUTION_TIME,\n    Q.COMPILATION_TIME,\n    Q.QUEUED_PROVISIONING_TIME,\n    A.PARENT_QUERY_ID,\n    A.ROOT_QUERY_ID\n    FROM\n        SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY Q\n    JOIN SNOWFLAKE.ACCOUNT_USAGE.ACCESS_HISTORY A\n    ON Q.QUERY_ID = A.QUERY_ID\n    WHERE\n        Q.QUERY_TYPE = 'CALL'\n            AND (Q.QUERY_TEXT ILIKE 'CALL <parent Proc Name>(%')\n        AND Q.START_TIME > '2000-01-01 00:00:00'\n    ),\n    CHILD_QUERY_ID AS (\n        SELECT\n            A.QUERY_ID,\n        FROM PARENT_RUN Q\n        JOIN\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nSNOWFLAKE.ACCOUNT_USAGE.ACCESS_HISTORY A\n        ON Q.QUERY_ID = A.PARENT_QUERY_ID OR Q.QUERY_ID = A.ROOT_QUERY_ID\n    ),\n    CHILD_RUN AS (\n    SELECT\n    Q.QUERY_ID,\n    Q.QUERY_TEXT,\n    Q.DATABASE_NAME AS RUN_DB,\n    Q.SCHEMA_NAME AS RUN_SCHEMA,\n    Q.QUERY_TYPE,\n    Q.SESSION_ID,\n    Q.USER_NAME,\n    Q.ROLE_NAME,\n    Q.WAREHOUSE_NAME,\n    Q.WAREHOUSE_SIZE,\n    Q.WAREHOUSE_TYPE,\n    Q.QUERY_TAG,\n    Q.EXECUTION_STATUS,\n    Q.ERROR_CODE,\n    Q.ERROR_MESSAGE,\n    Q.START_TIME,\n    Q.END_TIME,\n    Q.EXECUTION_TIME,\n    Q.COMPILATION_TIME,\n    Q.QUEUED_PROVISIONING_TIME,\n    A.PARENT_QUERY_ID,\n    A.ROOT_QUERY_ID\n    FROM\n        SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY Q\n    JOIN SNOWFLAKE.ACCOUNT_USAGE.ACCESS_HISTORY A\n    ON Q.QUERY_ID = A.QUERY_ID\n    JOIN CHILD_QUERY_ID C\n    ON Q.QUERY_ID = C.QUERY_ID\n    WHERE\n        Q.QUERY_TYPE = 'CALL' AND Q.START_TIME >  '2000-01-01 00:00:00'\n    ),\n    FINAL_AUDIT AS (\n        SELECT *\n ... \nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nsnowflake-cloud-data-platform\nsnowflake-schema\nShare\nImprove this question\nFollow\nasked Aug 26, 2024 at 13:45\nNIKHIL SUTHAR NIKHIL SUTHAR\n2,451 1 1 gold badge 11 11 silver badges 33 33 bronze badges\n5\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nI\u2019m not sure I would approach the problem like that.\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nAssuming that your starting point is a call to a stored procedure, then everything executed by that stored procedure will have the same session id as the SP and will start/end within the start/end period of the SP - so just query based on thatNickW\u2013 NickW2024-08-27 19:21:39 +00:00Commented Aug 27, 2024 at 19:21\nYes I am using session id only for a workaroundNIKHIL SUTHAR\u2013 NIKHIL SUTHAR2024-08-29 11:00:55 +00:00Commented Aug 29, 2024 at 11:00\nOnly issue with session id will be if someone calling the stored procedure from Snowflake worksheet then session will be same for all queryNIKHIL SUTHAR\u2013 NIKHIL SUTHAR2024-08-29 11:01:54 +00:00Commented Aug 29, 2024 at 11:01\nYes, but as sessions can\u2019t run queries in parallel, anything running between the start and end time of the SP call must be a child query of that SPNickW\u2013 NickW2024-08-29 14:41:38 +00:00Commented Aug 29, 2024 at 14:41\nThe problem has been solved with new view that\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nSnowflake has recently provided. Below is the answer @NickWNIKHIL SUTHAR\u2013 NIKHIL SUTHAR2024-09-17 17:42:50 +00:00Commented Sep 17, 2024 at 17:42\nSection Title: How to get the parent Query Id and root Id in Snowflake?\nContent:\nAdd a comment |\nRelated questions\n2\nHow to get last query id in a Snowflake transaction\n0\nSnowflake not showing Results when seen from the query history\n1\nQuery history only today\nRelated questions\n2\nHow to get last query id in a Snowflake transaction\n0\nSnowflake not showing Results when seen from the query history\n1\nQuery history only today\n0\nQueries working in snowflake web UI but not consistently through the python sqlalchemy connector\n0\nSnowflake a working procedure is not being successfully executed when calling it within a scheduled task\n2\nSnowflake get query_id for running query?\n2\nsnowflake query performance tuning\n1\nQuery to get the counts of all the objects in a Snowflake database\nSection Title: How to get the parent Query Id and root Id in Snowflake? > 0\nContent:\nSorted by: Reset to default\nHighest score (default) Trending (recent votes count more) Date modified (newest first) Date created (oldest first)\n ... \nSection Title: How to get the parent Query Id and root Id in Snowflake? > Your Answer > Sign up or\nContent:\nSign up using Google\nSign up using Email and Password\nSubmit"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/user-guide/ui-snowsight-lineage",
      "title": "Data Lineage | Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSnowflake Horizon Catalog\nApplications and tools for connecting to Snowflake\nVirtual warehouses\nDatabases, Tables, & Views\nData types\nData Integration\nSnowflake Openflow\nApache Iceberg\u2122\nApache Iceberg\u2122 Tables\nSnowflake Open Catalog\nData engineering\nData loading\nDynamic Tables\nStreams and Tasks\ndbt Projects on Snowflake\nData Unloading\nStorage Lifecycle Policies\nMigrations\nQueries\nListings\nCollaboration\nSnowflake AI & ML\nSnowflake Postgres\nAlerts & Notifications\nSecurity\nData Governance\nPrivacy\nOrganizations & Accounts\nBusiness continuity & data recovery\nPerformance optimization\nCost & Billing\nGuides Data Governance Data lineage\nSection Title: Data Lineage \u00b6\nContent:\nEnterprise Edition Feature\nThis feature requires Enterprise Edition (or higher). To inquire about upgrading, please contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nSnowflake tracks how data flows from source to target objects, for example from a table to a view, and lets you see\nwhere the data in an object came from or where it goes. This information is called *data lineage* , and it helps you\nunderstand the relationships between your Snowflake objects.\nData lineage captures two types of relationship:\nData movement, such as when data is copied or materialized from one object to another. For example, CREATE TABLE AS\nSELECT (CTAS), INSERT, or MERGE operations on tables result in data movement.\nObject dependencies, when an object references a base object but does not materialize or copy data, such as when a\nview references a table.\nSnowflake data lineage provides these benefits:\n ... \nSection Title: Data Lineage \u00b6 > Identify masking policies \u00b6\nContent:\nOpen the Lineage tab , and select the object you are interested in. A side panel opens.\nTo view the masking policy on a column of the object, find the column in the Columns section. If the column is protected by a\nmasking policy, a symbol appears next to the column name. Hover over the symbol to see the masking policy name and details.If there\u2019s a problem with the masking policy, for example there are multiple masking policies assigned to the same column, Policy Error appears instead of the mask symbol. If you hover over Policy Error , an explanation of the error appears. For\nadditional help identifying why the error might have occurred, see Tag and policy discovery and Troubleshoot tag-based masking policies .\nSection Title: Data Lineage \u00b6 > Lineage created by a stored procedure or task \u00b6\nContent:\nA stored procedure or task can result in lineage between an upstream object and a downstream object. You can select the arrow that connects\nthe objects to obtain more information about the stored procedure or task. You must have privileges to access the stored procedure or task\nto view this information.\nIf the downstream object was created by a stored procedure, the Stored Procedures section contains the following\ninformation:\nDirect \u2014 Displays the name of the stored procedure that, when executed, resulted in the downstream object.\nRoot \u2014 If the direct stored procedure is nested within other stored procedures, this field displays the name of the stored\nprocedure that is at the top of the hierarchy of nested procedures.\nTo view additional information about a stored procedure, select the Go to procedure icon next to its name.\nKeep in mind the following:\nSection Title: Data Lineage \u00b6 > Lineage created by a stored procedure or task \u00b6\nContent:\nIf you call a stored procedure anonymously , details about the stored procedure do not appear in the\nlineage.\nDetails about stored procedures and tasks are not backfilled. Lineage that occurred before the introduction of support for stored\nprocedures and tasks doesn\u2019t include details about the stored procedure or task.\nSection Title: Data Lineage \u00b6 > Retrieve lineage programmatically \u00b6\nContent:\nYou can use the GET_LINEAGE (SNOWFLAKE.CORE) function to retrieve lineage information programmatically. This\nfunction returns a subset of the information provided by the Lineage tab in Snowsight.\n ... \nSection Title: Data Lineage \u00b6 > Supported objects \u00b6\nContent:\nData lineage supports data movement and dependency between table-like objects . A\n\u201ctable-like\u201d object is any object that can be queried like a table, including tables (nothing is more table-like than a\ntable). Table-like objects include:\nTables\nDynamic tables\nExternal tables\nIceberg tables\nViews\nMaterialized views\nStages can also participate in data lineage relationships, as can the following machine learning objects.\nDatasets\nFeature Views (which are actually a dynamic tables or views inside Snowflake)\nModels\nColumn lineage is supported between columns in any two table-like objects. You can, for example, select a column in a table\nto view downstream column lineage, which shows the other table-like objects where that column appears.\nAdditionally, you can see tag and masking policy associations if you are using a role that has privileges for managing\ntags and masking policies.\nSection Title: Data Lineage \u00b6 > Supported objects \u00b6 > Lineage for objects from external data sources \u00b6\nContent:\nSnowflake can track data lineage for sources and destinations outside of Snowflake. This provides visibility into how data flows from\nexternal ETL tools and databases into your Snowflake objects, creating a comprehensive view of your entire data pipeline.\nFor more information, see External lineage .\n ... \nSection Title: Data Lineage \u00b6 > Access control for lineage information \u00b6\nContent:\nA user must have privileges to access the QUERY_HISTORY view to see the SQL statement that resulted in the\ntarget object.\nSection Title: Data Lineage \u00b6 > Lineage history and retention \u00b6\nContent:\nLineage was introduced to Snowflake in November 2024. Lineage information is available as follows:\nLineage for an object dependency (for example, a view based on a table) that occurred before this date *is* available.\nLineage for data movement (for example, using a CTAS statement to create a table from another table) that occurred before this date *is not* available.\nHistorical information is retained as follows:\nColumn lineage is retained for one year.\nObject lineage is retained for one year.\nSection Title: Data Lineage \u00b6 > Limitations and considerations \u00b6\nContent:\nLineage is not available for the following kinds of objects:\nObjects in a shared database. Objects in the shared SNOWFLAKE database. Objects in the INFORMATION_SCHEMA of a database. Dynamic tables appear in the lineage graph for other objects, but the Lineage tab does not appear for dynamic tables\nthemselves. Deleted tables are not shown in the lineage graph, but renamed tables are shown. Temporary tables are not shown in the lineage graph. Lineage does not include a table that was used for filtering or joining when data did not move from the table to the downstream object. In\nthe following example, table `t2` is not considered part of the lineage of table `target_table` :Copy\nLineage cannot track the movement of data that results from separate, disjointed queries.\nSection Title: Data Lineage \u00b6 > Limitations and considerations \u00b6\nContent:\nFor example, the following set of queries does not result in lineage from table `sourceTable1` to table `target_table` .CopyThis limitation applies to anything that caused the data movement, including stored procedures. You cannot use the GET_LINEAGE (SNOWFLAKE.CORE) function to obtain lineage information related to a stored\nprocedure.\nSection Title: Data Lineage \u00b6 > Limitations and considerations \u00b6\nContent:\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nAbout upstream and downstream relationships\nGet started\nColumn lineage\nWork with tags\nIdentify masking policies\nLineage created by a stored procedure or task\nRetrieve lineage programmatically\nSupported operations for data lineage\nSupported objects\nAccess control for lineage information\nLineage history and retention\nLimitations and considerations\nRelated content\nML Lineage: Trace ML data flow\nExternal lineage\nLanguage: **English**\nEnglish\nFran\u00e7ais\nDeutsch\n\u65e5\u672c\u8a9e\n\ud55c\uad6d\uc5b4\nPortugu\u00eas"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/sql-reference/account-usage/query_attribution_history",
      "title": "QUERY_ATTRIBUTION_HISTORY view | Snowflake Documentation",
      "excerpts": [
        "Section Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6\nContent:\nThis Account Usage view can be used to determine the compute cost of a given query run on warehouses in your account\nin the last 365 days (1 year).\nFor more information, see Viewing cost by tag in SQL .\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column name | Data type | Description |\n| QUERY_ID | VARCHAR | Internal/system-generated identifier for the SQL statement. |\n| PARENT_QUERY_ID | VARCHAR | Query ID of the parent query or NULL if the query does not have a parent. |\n| ROOT_QUERY_ID | VARCHAR | Query ID of the topmost query in the chain or NULL if the query does not have a parent. |\n| WAREHOUSE_ID | NUMBER | Internal/system-generated identifier for the warehouse that the query was executed on. |\n| WAREHOUSE_NAME | VARCHAR | Name of the warehouse that the query executed on. |\n| QUERY_HASH | VARCHAR | The hash value computed based on the canonicalized SQL text. |\n| QUERY_PARAMETERIZED_HASH | VARCHAR | The hash value computed based on the parameterized query. |\n| QUERY_TAG | VARCHAR | Query tag set for this statement through the QUERY_TAG session parameter. |\n| USER_NAME | VARCHAR | User who issued the query. |\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column name | Data type | Description |\n| QUERY_ID | VARCHAR | Internal/system-generated identifier for the SQL statement. |\n| PARENT_QUERY_ID | VARCHAR | Query ID of the parent query or NULL if the query does not have a parent. |\n| ROOT_QUERY_ID | VARCHAR | Query ID of the topmost query in the chain or NULL if the query does not have a parent. |\n| WAREHOUSE_ID | NUMBER | Internal/system-generated identifier for the warehouse that the query was executed on. |\n| START_TIME | TIMESTAMP_LTZ | Time when query execution started (in the local time zone). |\n| END_TIME | TIMESTAMP_LTZ | Time when query execution ended (in the local time zone). |\n| CREDITS_ATTRIBUTED_COMPUTE | NUMBER | Number of credits attributed to this query. Includes only the credit usage for the query execution and doesn\u2019t include any warehouse idle time. |\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column name | Data type | Description |\n| QUERY_ID | VARCHAR | Internal/system-generated identifier for the SQL statement. |\n| PARENT_QUERY_ID | VARCHAR | Query ID of the parent query or NULL if the query does not have a parent. |\n| ROOT_QUERY_ID | VARCHAR | Query ID of the topmost query in the chain or NULL if the query does not have a parent. |\n| WAREHOUSE_ID | NUMBER | Internal/system-generated identifier for the warehouse that the query was executed on. |\n| CREDITS_USED_QUERY_ACCELERATION | NUMBER | Number of credits consumed by the Query Acceleration Service to accelerate the query. NULL if the query is not accelerated. . . The total cost for an accelerated query is the sum of this column and the CREDITS_ATTRIBUTED_COMPUTE column. |\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Usage notes \u00b6\nContent:\nLatency for this view can be up to eight hours. This view displays results for any role granted the USAGE_VIEWER or GOVERNANCE_VIEWER database role . The value in the `credits_attributed_compute` column contains the warehouse credit usage for executing the query,\ninclusive of any resizing and/or autoscaling of multi-cluster warehouse(s). This cost is attributed based on\nthe weighted average of the resource consumption.The value doesn\u2019t include any credit usage for warehouse idle time. Idle time is a period\nof time in which no queries are running in the warehouse and can be measured at the warehouse level.The value doesn\u2019t include any other credit usage that is incurred as a result of query execution.\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Usage notes \u00b6\nContent:\nFor example, the following are not included in the query cost:\nData transfer costs\nStorage costs\nCloud services costs\nCosts for serverless features\nCosts for tokens processed by AI services\nFor queries that are executed concurrently, the cost of the warehouse is attributed to individual queries based on the\nweighted average of their resource consumption during a given time interval. Short-running queries (<= ~100ms) are currently too short for per query cost attribution and are not included in the view. Data for all columns is available starting from mid-August, 2024. Some data prior to this date might be available in the view, but\nmight be incomplete.\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Examples \u00b6 > Query costs for related queries \u00b6\nContent:\nTo determine the costs of a specific query and similar queries using the query parameterized hash, replace `<query_id>` and execute the following statements:\n```\nSET query_id = '<query_id>' ; \n\n WITH query_hash_of_query AS ( \n  SELECT query_parameterized_hash \n  FROM SNOWFLAKE . ACCOUNT_USAGE . QUERY_ATTRIBUTION_HISTORY \n  WHERE query_id = $ query_id \n  LIMIT 1 \n ) \n SELECT \n  query_parameterized_hash , \n  COUNT (*) AS query_count , \n  SUM ( credits_attributed_compute ) AS recurrent_query_attributed_credits \n FROM SNOWFLAKE . ACCOUNT_USAGE . QUERY_ATTRIBUTION_HISTORY \n WHERE start_time >= DATE_TRUNC ( 'MONTH' , CURRENT_DATE ) \n  AND start_time < CURRENT_DATE \n  AND query_parameterized_hash = ( SELECT query_parameterized_hash FROM query_hash_of_query ) \n GROUP BY ALL ;\n```\nCopy\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Examples \u00b6 > Query costs for the current user \u00b6\nContent:\nTo determine the costs of queries executed by the current user for the current month, execute the following statement:\n```\nSELECT user_name , SUM ( credits_attributed_compute ) AS credits \n  FROM SNOWFLAKE . ACCOUNT_USAGE . QUERY_ATTRIBUTION_HISTORY \n  WHERE user_name = CURRENT_USER () \n    AND start_time >= DATE_TRUNC ( 'MONTH' , CURRENT_DATE ) \n    AND start_time < CURRENT_DATE \n  GROUP BY user_name ;\n```\nCopy\nFor an example of attributing warehouse costs to users, see Resources shared by users from different departments .\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Examples \u00b6 > Query costs for stored procedures \u00b6\nContent:\nFor stored procedures that issue multiple hierarchical queries, you can compute the attributed query costs for the\nprocedure by using the root query ID for the procedure.\nTo find the root query ID for a stored procedure, use the ACCESS_HISTORY view . For example,\nto find the root query ID for a stored procedure, set the `query_id` and execute the following statements:CopyFor more information, see Ancestor queries with stored procedures .\nTo sum the query cost for the entire procedure, replace `<root_query_id>` and execute the following statements:Copy\nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Examples \u00b6 > Additional examples \u00b6\nContent:\nFor more examples, see Resources shared by users from different departments .\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nColumns\nUsage notes\nExamples\nQuery costs for related queries\nQuery costs for the current user\nQuery costs for stored procedures\nAdditional examples\nRelated content\nOverview of warehouses\n ... \nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > ... > Your Privacy > Strictly Necessary Cookies\nContent:\nAlways Active\nThese cookies are necessary for the website to function and cannot be switched off. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not then work. These cookies do not store any personally identifiable information.\nCookies Details\u200e\n ... \nSection Title: QUERY_ ATTRIBUTION_ HISTORY view \u00b6 > Privacy Preference Center > Your Privacy > Targeting Cookies\nContent:\nTargeting Cookies\nThese cookies may be set through our site by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant adverts on other sites. They do not store directly identifiable personal information, but are based on uniquely identifying your browser and internet device. If you do not allow these cookies, you will experience less targeted advertising.\nCookies Details\u200e"
      ]
    },
    {
      "url": "https://seemoredata.io/blog/snowflake-query-history/",
      "title": "Snowflake Query History: Accessing, Examples, and Troubleshooting",
      "publish_date": "2025-05-29",
      "excerpts": [
        "Solution\n[Continuous Cost Control](https://seemoredata.io/data-cost-control/)\n[Warehouse Optimization](https://seemoredata.io/data-warehouse-optimization/)\n[Usage-Based Data Pipeline Optimization](https://seemoredata.io/usage-based-optimization/)\n[Data efficiency AI Agent](https://seemoredata.io/data-efficiency-ai-agent/)\nProduct\n[Root Cause Anomalies Detection](https://seemoredata.io/snowflake-root-cause-anomalies-detection/)\n[SmartPulse](https://seemoredata.io/smart-pulse-hourly-autonomous-snowflake-warehouse-optimization/)\n[AI Auto-Clustering](https://seemoredata.io/intelligent-snowflake-auto-clustering/)\n[Integrations](https://seemoredata.io/integrations/)\n[Snowflake optimization](https://seemoredata.io/integrations/snowflake/)\n[ETL / ELT optimization](https://seemoredata.io/integrations/etl/)\n[Orchestration optimization](https://seemoredata.io/integrations/orchestration/)\n[BI optimization](https://seemoredata.io/integrations/bitools-2/)\n[All\n ... \nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting\nContent:\n[](https://www.addtoany.com/add_to/tumblr?linkurl=https%3A%2F%2Fseemoredata.io%2Fblog%2Fsnowflake-query-history%2F&linkname=Snowflake%20Query%20History%3A%20Accessing%2C%20Examples%2C%20and%20Troubleshooting \"Tumblr\") [](https://www.addtoany.com/add_to/facebook?linkurl=https%3A%2F%2Fseemoredata.io%2Fblog%2Fsnowflake-query-history%2F&linkname=Snowflake%20Query%20History%3A%20Accessing%2C%20Examples%2C%20and%20Troubleshooting \"Facebook\") [](https://www.addtoany.com/add_to/twitter?linkurl=https%3A%2F%2Fseemoredata.io%2Fblog%2Fsnowflake-query-history%2F&linkname=Snowflake%20Query%20History%3A%20Accessing%2C%20Examples%2C%20and%20Troubleshooting \"Twitter\")\nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting\nContent:\nAs data engineers and administrators, having comprehensive visibility into the queries running on your Snowflake instance is crucial. Snowflake\u2019s query history feature provides a detailed log of all executed queries, enabling you to monitor performance, troubleshoot issues, and optimize resource usage. Understanding how to effectively access and utilize this feature can significantly enhance your ability to manage and optimize your data environment.\nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting\nContent:\nIn this blog, we will explore the fundamentals of accessing Snowflake query history, provide practical examples of how to leverage this feature for various use cases, and share troubleshooting techniques to resolve common issues. Whether you\u2019re looking to identify long-running queries, analyze resource consumption, monitor user activity, or ensure data security, mastering Snowflake query history is key to maintaining a robust and efficient data platform. Let\u2019s dive into the essential strategies and best practices for managing query history in Snowflake.\nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting > What is Snowflake Query History?\nContent:\nSnowflake\u2019s Query History feature is an essential tool for data engineers and administrators to monitor, analyze, and optimize their SQL queries and data operations. It provides a comprehensive view of all the queries executed within a Snowflake account, including details about query performance, resource usage, and execution statistics.\nKey components of Snowflake Query History include:\nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting > What is Snowflake Query History?\nContent:\n**Query Details** : Each entry in the query history contains information like query ID, SQL text, execution status (e.g., success, failure), start and end times, duration, and the role and user who executed the query. **Filtering and Searching** : Users can filter and search the query history based on various criteria such as time range, user, role, warehouse, status, and SQL text. **Usage and Performance Analysis** : Query history can be used to analyze query performance, identify long-running queries, and optimize resource usage. **Auditing and Compliance** : Maintaining a query history is crucial for auditing purposes, ensuring compliance with regulatory requirements, and tracking user activity.\nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting > What is Snowflake Query History?\nContent:\n**Accessing Query History** : Users can access query history through the Snowflake web interface, SQL commands, or the Snowflake Information Schema views like QUERY_HISTORY, QUERY_HISTORY_BY_*, and LOGIN_HISTORY.\n ... \nSection Title: ... > Accessing Query History in Snowflake\nContent:\nTo get query history snowflake offers multiple interfaces, allowing users to choose the method that best suits their needs. These interfaces provide a comprehensive view of all executed queries, enabling detailed analysis and optimization of data operations.\nHere is how to check query history in snowflake:\n ... \nSection Title: Snowflake Query History: Accessing, Examples, and Troubleshooting > Key Components of Query History\nContent:\nUnderstanding the key components of Snowflake\u2019s query history is crucial for data engineers and administrators aiming to monitor, analyze, and optimize their SQL queries and data operations by accessing a query history table in snowflake. These components provide comprehensive insights into query performance, resource utilization, and user activity, facilitating efficient management and troubleshooting.\n ... \nSection Title: ... > Best Practices for Managing Snowflake Query History\nContent:\nManaging query history in Snowflake is crucial for optimizing performance, troubleshooting issues, and ensuring efficient use of resources. This guide covers the best practices for effectively managing Snowflake query history, aimed at data engineers and administrators who want to harness the full potential of Snowflake\u2019s capabilities.\n ... \nSection Title: ... > Snowflake in Action: Examples of How to Access and Use Snowflake Query History\nContent:\nSnowflake\u2019s query history feature is a powerful tool for tracking, analyzing, and optimizing query performance. By understanding and utilizing query history, data engineers can ensure efficient use of resources, troubleshoot issues, and enhance overall system performance. This blog will explore various examples of how to access and use Snowflake query history to achieve these goals.\nSection Title: ... > Accessing Snowflake Query History\nContent:\nSnowflake query history can be accessed through the Snowflake web interface or by querying the QUERY_HISTORY view in the INFORMATION_SCHEMA or SNOWFLAKE.ACCOUNT_USAGE schema.\nExample SQL Query to Access Query History:\nSELECT *\nFROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY\nWHERE START_TIME > DATEADD(day, -7, CURRENT_TIMESTAMP());\nThis query retrieves all queries executed in the last seven days."
      ]
    },
    {
      "url": "https://sonra.io/snowflake-data-lineage-guide/",
      "title": "Master Snowflake Data Lineage \u2013 Features, Tools & Tips - Sonra",
      "publish_date": "2025-12-10",
      "excerpts": [
        "Section Title: ... > ACCESS_HISTORY \u2013 Snowflake lineage from query\nContent:\nSnowflake stores the data lineage mappings for each write query (DML) you run in the ACCESS_HISTORY view in the [ACCOUNT_USAGE](https://docs.snowflake.com/en/sql-reference/account-usage) schema.\nThis schema holds object metadata as well as historical usage data for your Snowflake account.\n**Object metadata** is about database objects (like tables, views, schemas, etc.) that describe its structure, properties, and other attributes of the object.\n**Usage data** shows how database objects (like tables, views, and warehouses) are accessed and queried by your Snowflake users. You can use this information for optimising performance, managing costs, and data governance.\n ... \nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Note\nContent:\nACCESS_HISTORY stores the following information\nThe type, name, and ID of objects that were accessed in a query. This information is [stored as JSON](https://sonra.io/snowflake-json-store-load-guide/) arrays in columns DIRECT_OBJECTS_ACCESSED and BASE_OBJECTS_ACCESSED.\nData lineage at the column level for DML such as INSERT, CTAS, MERGE etc. The column OBJECTS_MODIFIED contains the mappings between source and target columns in a query.\nOperations that involve DDL such as creating or altering a table are logged in column OBJECT_MODIFIED_BY_DDL.\nIf a query references a policy, e.g. a data masking policy it is logged in column POLICIES_REFERENCED.\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Note > Note\nContent:\nSnowflake stores most but not all queries in ACCESS_HISTORY.\nFor a comprehensive list of what type of queries Snowflake stores in ACCESS_HISTORY have a look at the [usage notes](https://docs.snowflake.com/en/sql-reference/account-usage/access_history) .\nLet\u2019s go through some examples to understand what Snowflakes stores in column DIRECT_OBJECTS_ACCESSED before comparing it to BASE_OBJECTS_ACCESSED\n ... \nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Examples for DIRECT_OBJECTS_ACCESSED\nContent:\nAll columns that I used in my SQL query are listed in the JSON array. This includes the Salary column in the WHERE clause.\nInformation about where exactly the column was used in the query is not available, e.g. we do not know from the JSON that the columns Hire_Date, Age etc. are part of the SELECT clause (projected columns) and that Salary is part of the WHERE clause.\nThe database and schema are not listed as separate objects but are included as part of the Table objectName. If you need this info you will need to parse it out manually.\nIf you run a query such as SELECT * FROM table1, Snowflake will look up the columns in table1 and resolve the asterisk (*) to the actual column names and column IDs.\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Stored procedures and ACCESS_HISTORY\nContent:\nQueries inside a stored procedure can also be tracked via ACCESS_HISTORY. Columns parent_query_id and root_query_id can be used to unnest queries inside a stored procedure.\nLet\u2019s go through an example.\nI have created a stored procedure with a couple of SQL queries.\n|1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46 |CREATE OR REPLACE PROCEDURE Get_Employees_Age_Range (\nmin_age INTEGER ,\nmax_age INTEGER\n)\nRETURNS STRING\nLANGUAGE SQL\nAS\n$\nDECLARE\nresult STRING ;\nemployee_count INTEGER ;\nBEGIN\nSELECT COUNT ( * )\nINTO : employee_count\nFROM EMPLOYEE_DETAILS_SRC\nWHERE Age BETWEEN : min_age AND : max_age ;\nIF ( employee_count = 0 ) THEN\nRETURN 'No employees found in age range ' || min_age || ' to ' || max_age ;\nEND IF ;\nSELECT LISTAGG ( Name , ', ' )\nINTO : result\nFROM EMPLOYEE_DETAILS_SRC\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Stored procedures and ACCESS_HISTORY\nContent:\nWHERE Age BETWEEN : min_age AND : max_age ;\n-- Insert into tracking table\nINSERT INTO EMPLOYEE_AGE_RANGES (\nage_range_min ,\nage_range_max ,\nemployee _ list\n)\nVALUES (\n: min_age ,\n: max_age ,\n: result\n) ;\nRETURN 'Successfully inserted ' || employee_count || ' employees for age range '\n|| min_age || ' to ' || max_age || ': ' || result ;\nEXCEPTION\nWHEN OTHER THEN\nRETURN 'Error occurred: ' || SQLSTATE || ' - ' || SQLERRM ;\nEND ;\n$ ; |\n| --- | --- |\nLet\u2019s execute this stored procedure.\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Stored procedures and ACCESS_HISTORY\nContent:\n| 1 | CALL Get_Employees_Age_Range ( 35 , 45 ) ; |\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Stored procedures and ACCESS_HISTORY\nContent:\nThis gives us the following result in ACCESS_HISTORY.DIRECT_OBJECTS_ACCESSED.\n|1\n2\n3\n4\n5\n6\n7\n8\n9 |[\n{\n\"argumentSignature\" : \"(MIN_AGE NUMBER, MAX_AGE NUMBER)\" ,\n\"dataType\" : \"VARCHAR(16777216)\" ,\n\"objectDomain\" : \"Procedure\" ,\n\"objectId\" : 6387 ,\n\"objectName\" : \"GET_EMPLOYEES_AGE_RANGE\"\n}\n] |\n| --- | --- |\nAs you can see a few additional columns have been added\n**Argument signature (argumentSignature):** The argumentSignature column outlines the input parameters a function or procedure requires,\n**Return data type (dataType):** This column specifies the data type that the procedure or function returns to the caller\nIt is worthwhile noting that the BASE_OBJECTS_ACCESSED column is not populated.\nIn order to get the details for the SQL inside the stored procedure, I used the query_id of the call to the stored procedure to filter on ACCESS_HISTORY.ROOT_QUERY_ID\n|1\n2\n3\n4\n5\n6\n7 |select\n*\nfrom\nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > Stored procedures and ACCESS_HISTORY\nContent:\nsnowflake . account_usage . access _ history a\njoin snowflake . account_usage . query _ history b on a . query_id = b . query_id\nwhere\na . root_query_id = '01b7ebc8-0303-9870-0000-011d02c012ee' |\n| --- | --- |\nAs you know, it\u2019s possible to nest calls to stored procedures inside a stored procedure thereby creating a tree or a cascade, if you will, of stored procedure calls.\nACCESS_HISTORY provides column ROOT_QUERY_ID, PARENT_QUERY_ID, and QUERY_ID to [recursively iterate over this hierarchy](https://docs.snowflake.com/en/user-guide/access-history) .\nSection Title: ... > DIRECT_OBJECTS_ACCESSED vs. BASE_OBJECTS_ACCESSED\nContent:\nData engineers love to *matryoshka* their code with views \ud83d\ude01! They\u2019ll stack database objects layer by layer, just like those famous Russian nesting dolls. One view will reference another, which references another, and so on\u2026 until you\u2019re in the basement of a database dollhouse, or that weird half-bath under the stairs!\nThe column BASE_OBJECTS_ACCESSED in ACCESS_HISTORY works well for this scenario. There are times when you need to include or reference another database object. The most (in)famous example is the nesting of views. But you can also nest UDFs, UDTFs, and Stored Procedures.\nWhile DIRECT_OBJECTS_ACCESSED shows only the immediate objects a query directly calls, BASE_OBJECTS_ACCESSED shows *any* base objects that were accessed. However, information is not available for intermediate objects.\nLet\u2019s go through some detailed examples to make this point clear.\n**Example of View**\n ... \nSection Title: ... > Flattening OBJECTS_MODIFIED for data lineage mappings\nContent:\nWe\u2019ll need to flatten the data to make the JSON array more readable.\nThe Snowflake docs provide a [sample query](https://docs.snowflake.com/en/user-guide/access-history) that does just that.\nBecause no base objects are involved in our query, the record with SOURCE_COLUMN_TYPE value BASE is redundant.\nBy adding a small change to the sample query, we can filter out records where the query didn\u2019t involve a base object.\nLet\u2019s go through a few more examples to demonstrate the data lineage for different types of write queries\n ... \nSection Title: Master Snowflake Data Lineage \u2013 Features, Tools & Tips > ... > End to end Snowflake data lineage\nContent:\nUsing the source table to target table mappings stored in ACCESS_HISTORY.OBEJCTS_MODIFIED, you can build your own end to end data lineage solution.\nThis is a non-trivial exercise, and you\u2019re probably better off using a new feature that visualises Snowflake data lineage in Snowsight.\nHere are the steps to build your own solution.\nFlatten column OBJECTS_MODIFIED for all relevant queries.\nIdentify any root objects, i.e. source object IDs without a parent.\nUse the object IDs of source columns, source tables, target columns and target tables to recursively iterate over the hierarchy.\nAt a high level these are the steps. However, it is much harder to get a working solution. I recommend to either use the visual [Data Lineage feature in Snowsight](https://sonra.io/snowflake-data-lineage-guide/) or to use a [third party data lineage tool](https://sonra.io/snowflake-data-lineage-guide/) ."
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/sql-reference/account-usage/query_history",
      "title": "QUERY_HISTORY view | Snowflake Documentation",
      "excerpts": [
        "Reference General reference SNOWFLAKE database Account Usage QUERY_HISTORY\nSchemas:\nACCOUNT_USAGE , READER_ACCOUNT_USAGE\nSection Title: QUERY_HISTORY view \u00b6\nContent:\nThis Account Usage view can be used to query Snowflake query history by various dimensions (time range, session, user, warehouse, and so on) within the last 365 days (1 year).\nThe view is available in both the ACCOUNT_USAGE and READER_ACCOUNT_USAGE schemas with the following differences:\nThe following columns are available *only* in the reader account view:\n`reader_account_name`\n`reader_account_deleted_on`\nAlternatively, you can call the Information Schema table function, also named QUERY_HISTORY; however, note that the table function restricts\nthe results to activity over the past 7 days, versus 365 days for the Account Usage view. See the description of the QUERY_HISTORY function .\nSee also:\nQUERY_HISTORY , QUERY_HISTORY_BY_* (Information Schema table function)\nMonitor query activity with Query History (Snowsight dashboard)\nUse the Grouped Query History view in Snowsight\nSection Title: QUERY_HISTORY view \u00b6 > Columns \u00b6\nContent:\nThe *Available only in reader account usage views* column in the following table indicates whether the QUERY_HISTORY column is available in the READER_ACCOUNT_USAGE schema.\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column Name | Data Type | Description | Available only in reader account usage views |\n| `reader_account_name` | VARCHAR | Name of the reader account in which the SQL statement was executed. | \u2714 |\n| `query_id` | VARCHAR | Internal/system-generated identifier for the SQL statement. | \u2714 |\n| `query_text` | VARCHAR | Text of the SQL statement. The limit is 100K characters. Longer SQL statements are truncated. |  |\n| `database_id` | NUMBER | internal/system-generated identifier for the database that was in use. | \u2714 |\n| `session_id` | NUMBER | Session that executed the statement. | \u2714 |\n| `authn_event_id` | NUMBER | ID for the event for the authentication of the user for this query. This ID corresponds to the value in the `event_id` column in the LOGIN_HISTORY view. |  |\n| `user_name` | VARCHAR | User who issued the query. |  |\n| `role_name` | VARCHAR | Role that was active in the session at the time of the query. | \u2714 |\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column Name | Data Type | Description | Available only in reader account usage views |\n| `reader_account_name` | VARCHAR | Name of the reader account in which the SQL statement was executed. | \u2714 |\n| `query_id` | VARCHAR | Internal/system-generated identifier for the SQL statement. | \u2714 |\n| `query_text` | VARCHAR | Text of the SQL statement. The limit is 100K characters. Longer SQL statements are truncated. |  |\n| `database_id` | NUMBER | internal/system-generated identifier for the database that was in use. | \u2714 |\n| `transaction_id` | NUMBER | ID of the transaction that contains the statement or 0 if the statement is not executed within a transaction. |  |\n| `child_queries_wait_time` | NUMBER | Time (in milliseconds) to complete the cached lookup when calling a memoizable function . |  |\n| `role_type` | VARCHAR | Specifies whether an APPLICATION, DATABASE_ROLE, or ROLE executed the query. |  |\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Columns \u00b6\nContent:\n| Column Name | Data Type | Description | Available only in reader account usage views |\n| `reader_account_name` | VARCHAR | Name of the reader account in which the SQL statement was executed. | \u2714 |\n| `query_id` | VARCHAR | Internal/system-generated identifier for the SQL statement. | \u2714 |\n| `query_text` | VARCHAR | Text of the SQL statement. The limit is 100K characters. Longer SQL statements are truncated. |  |\n| `database_id` | NUMBER | internal/system-generated identifier for the database that was in use. | \u2714 |\n| `secondary_role_stats` | VARCHAR | A JSON-formatted string that contains three fields regarding secondary roles that were evaluated in the query: a list of secondary roles or `ALL` depending on the session, a count of the number of secondary roles, and the internal/system-generated ID for each secondary role. The count and number of IDs have a maximum of 50. |  |\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Usage notes \u00b6 > Query history for hybrid tables \u00b6\nContent:\nThe following notes explain when records are logged in the QUERY_HISTORY view for queries against hybrid tables:\nSection Title: QUERY_HISTORY view \u00b6 > Usage notes \u00b6 > Query history for hybrid tables \u00b6\nContent:\nShort-running queries that operate exclusively against hybrid tables do not generate a record in this\nview or QUERY_HISTORY (Information\nSchema table function). To monitor such queries, use the AGGREGATE_QUERY_HISTORY view. This view allows you to more easily monitor high-throughput operational\nworkloads for trends and issues. Short-running queries that operate exclusively against hybrid tables do not provide a query profile\nthat you can inspect in Snowsight. Queries against hybrid tables do generate both a record in the QUERY_HISTORY view and a query profile if any of the\nfollowing conditions are met:\nA query is executed against any table type other than the hybrid table type. This\ncondition ensures that there is no behavior change for any existing\nnon-Unistore workloads. A query fails with an EXECUTION_STATUS of `failed_with_incident` (see QUERY_HISTORY ).\nSection Title: QUERY_HISTORY view \u00b6 > Usage notes \u00b6 > Query history for hybrid tables \u00b6\nContent:\nThis\ncondition ensures that you can investigate and report the specific failed\nquery to receive assistance. A query is running longer than approximately 500 milliseconds. This\ncondition ensures that you can investigate performance issues for slow queries. Query result size is too large. A query is associated with a Snowflake transaction. A query contains a system function with side effects. A query is not one of the following statement types: SELECT, INSERT,\nDELETE, UPDATE, MERGE. A query is executed from SnowSQL, Snowsight, or Classic Console. This\ncondition ensures that you can manually generate a full query profile to\ninvestigate performance issues for any specific query even if it is not\ncategorized as long-running. Even if a query does not meet any of these criteria, queries can be\nperiodically sampled to generate a record in the QUERY_HISTORY view and a\nquery profile to help your investigation.\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Privacy Preference Center > Your Privacy\nContent:\nWhen you visit any website, it may store or retrieve information on your browser, mostly in the form of cookies. This information might be about you, your preferences or your device and is mostly used to make the site work as you expect it to. The information does not usually directly identify you, but it can give you a more personalized web experience. Because we respect your right to privacy, you can choose not to allow some types of cookies. Click on the different category headings to find out more and change our default settings. However, blocking some types of cookies may impact your experience of the site and the services we are able to offer.\n[More information](https://cookiepedia.co.uk/giving-consent-to-cookies)\nSection Title: QUERY_HISTORY view \u00b6 > Privacy Preference Center > Your Privacy > Strictly Necessary Cookies\nContent:\nAlways Active\nThese cookies are necessary for the website to function and cannot be switched off. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not then work. These cookies do not store any personally identifiable information.\nCookies Details\u200e\n ... \nSection Title: QUERY_HISTORY view \u00b6 > Privacy Preference Center > Your Privacy > Targeting Cookies\nContent:\nTargeting Cookies\nThese cookies may be set through our site by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant adverts on other sites. They do not store directly identifiable personal information, but are based on uniquely identifying your browser and internet device. If you do not allow these cookies, you will experience less targeted advertising.\nCookies Details\u200e"
      ]
    }
  ],
  "usage": [
    {
      "name": "sku_search",
      "count": 1
    }
  ]
}
