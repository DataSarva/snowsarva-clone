{
  "extract_id": "extract_11207c039f324c92bad9f8588eb256a4",
  "results": [
    {
      "url": "https://www.flexera.com/blog/finops/snowflake-native-apps/",
      "title": "Snowflake Native Apps 101: Build and monetize data apps (2026)",
      "publish_date": "2026-01-27",
      "excerpts": [
        "Flexera Open Primary Navigation\n\n* Solutions\n  \n  Spend management by vendor\n  \n  [Flexera is a Leader in 2025 cloud financial management tools](https://info.flexera.com/CM-REPORT-Gartner-Magic-Quadrant-Cloud-Financial-Management-Tools)\n  \n  Discover recognized CFM vendors to watch in the 2025 Gartner\u00ae Magic Quadrant\u2122\n  \n  [View report](https://info.flexera.com/CM-REPORT-Gartner-Magic-Quadrant-Cloud-Financial-Management-Tools)\n* Products\n  \n  Flexera One\n  \n    + IT Visibility\n    + ITAM\n    + Snow Atlas\n    + Cloud License Management\n    + SaaS Management\n  \n    + FinOps\n    + Cloud Cost Optimization\n    + Cloud Commitment Management\n    + Container Optimization\n    + Virtual Machine Optimization\n    + Data Cloud Optimization\n  \n    + Application Readiness\n    + Security\n    + Integrations\n    + Technology Intelligence Platform\n    + All Products\n  \n  [Introducing Flexera One SaaS Management](https://www.flexera.com/products/flexera-one/saas-management)\n  \n  Discover comprehensive SaaS visibility for taming SaaS sprawl, wasted spend and compliance risks.\n  \n  [Book your personalized demo](https://www.flexera.com/products/flexera-one/saas-management)\n* Success\n  \n  Customer Success\n  \n  Services & Training\n  \n    + Services\n    + Training\n  \n  Support\n  \n    + [Flexera support portal](https://community.flexera.com/s/support-hub)\n    + [Flexera product documentation](https://docs.flexera.com)\n    + [Snow product documentation](https://docs.snowsoftware.io/)\n  \n    + Technology Intelligence Awards\n    + [Flexera community](https://community.flexera.com/s/)\n  \n  [2025 Technology Intelligence Awards](https://info.flexera.com/ITAM-REPORT-State-of-IT-Asset-Management)\n  \n  The results are in\u2014see how our 2025 winners and honorable mentions are shaping the future of Technology Intelligence.\n  \n  [See the winners](https://www.flexera.com/customer-success/awards)\n* Resources\n  \n  Resources\n  \n    + Webinars\n    + Videos\n    + Datasheets\n    + Whitepapers & reports\n  \n    + Blog\n    + Case studies\n    + Events\n    + Analyst research\n    + Glossary\n    + Demos & trials\n    + Business value calculator\n  \n  [Flexera 2026 IT Priorities Report](https://www.flexera.com/resources/reports/ITV-REPORT-IT-Priorities)\n  \n  AI ROI, sustainability, cost and risk: Discover the latest IT trends shaping tomorrow\u2019s IT landscape in Flexera\u2019s 2026 IT Priorities Report.\n  \n  [View report](https://www.flexera.com/resources/reports/ITV-REPORT-IT-Priorities)\n* About\n  \n  Company\n  \n    + About\n    + Careers\n    + Contact us\n    + Leadership\n  \n  Partners\n  \n    + Partner program\n    + Partner locator\n  \n  Press center\n  \n    + Press releases\n    + Articles\n    + Awards\n  \n  Social responsibility\n  \n    + ESG\n    + Belonging and inclusion\n  \n  [The Flexera 2025 State of the Cloud Report](https://info.flexera.com/CM-REPORT-State-of-the-Cloud)\n  \n  How are GenAI rising cloud costs, security and sustainability shaping your cloud strategies in 2025?\n  \n  [View report](https://info.flexera.com/CM-REPORT-State-of-the-Cloud)\n\nCustomers Open External Links\n\n* [Community](https://community.flexera.com/)\n* [Product login](https://app.flexera.com/login)\n* [Spot login](https://console.spotinst.com/auth/signIn)\n* [Partner Portal](https://partnerhub.flexera.com/)\n\nSearch\n\nBook a demo\n\n1. Home\n2. Blog\n3. [FinOps](https://www.flexera.com/blog/finops/)\n4. Snowflake Native Apps 101: Build and monetize data apps (2026)\n\n### [FinOps](https://www.flexera.com/blog/finops/)\n\nSubscribe\n\nTopics\n\nSaaS Management FinOps IT Visibility IT Asset Management Product News Application Readiness Security Perspectives\n\n[FinOps](https://www.flexera.com/blog/finops/)\n\n# Snowflake Native Apps 101: Build and monetize data apps (2026)\n\n[](https://www.flexera.com/blog/author/pramit/ \"Pramit Marattha\")\n\n[Pramit Marattha](https://www.flexera.com/blog/author/pramit/ \"Pramit Marattha\")\n\n[](https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fwww.flexera.com%2Fblog%2Ffinops%2Fsnowflake-native-apps%2F&title=Snowflake%20Native%20Apps%20101%3A%20Build%20and%20monetize%20data%20apps%20%282026%29&source=https%3A%2F%2Fwww.flexera.com%2Fblog%2Ffinops%2Fsnowflake-native-apps%2F) [](https://twitter.com/intent/tweet?source=https%3A%2F%2Fwww.flexera.com%2Fblog%2Ffinops%2Fsnowflake-native-apps%2F&text=Snowflake%20Native%20Apps%20101%3A%20Build%20and%20monetize%20data%20apps%20%282026%29%20https%3A%2F%2Fwww.flexera.com%2Fblog%2Ffinops%2Fsnowflake-native-apps%2F) \n\nThis post originally appeared on the chaosgenius.io blog. Chaos Genius has been [acquired by Flexera](https://www.flexera.com/more/ProsperOps-Chaos-Genius) .\n\nBuilding and deploying [data applications](https://www.snowflake.com/guides/applications/) often comes with unnecessary complexity. Snowflake has significantly reduced this by introducing **Snowflake Native Apps** . Snowflake Native Apps allow you to build, run and monetize data apps directly within the Snowflake ecosystem. No external integrations. No infrastructure headaches. Snowflake previously supported [Connected Apps](https://www.snowflake.com/guides/connected-apps) , which operated outside Snowflake, connected via [APIs](https://docs.snowflake.com/en/api-reference) and required manual data movement. Native Apps, by contrast, run entirely within Snowflake, leveraging its secure and scalable infrastructure . They\u2019re built using the _Snowflake Native App Framework_ , allowing you to develop secure, scalable and integrated Snowflake apps that leverage Snowflake\u2019s environment without leaving the Snowflake platform.\n\nIn this article, we will discuss the features, benefits and inner workings of Snowflake Native Apps and walk you through the step-by-step process of creating a Snowflake Native App and publishing and monetizing your Native Apps through the Snowflake Marketplace.\n\n## What Are Snowflake Native Applications?\n\n**Snowflake Native Apps** are applications built using the Snowflake Native App Framework, which allows developers to create, test and deploy applications directly within Snowflake\u2019s Data Cloud. These Native Apps leverage Snowflake\u2019s core features like stored procedures , user-defined functions (Snowflake UDFs) and the [Snowpark API](https://docs.snowflake.com/en/developer-guide/snowpark/index) , all while keeping the data secure by running the code on your data stored in Snowflake. Native apps are available on the Snowflake Marketplace . You can discover and install them quickly, just like downloading an app on your smartphone.\n\n**TL;DR:  \n** **What They Are** \u2014 Snowflake Native Apps run entirely within Snowflake, eliminating the need to move data out for processing.  \n**How They Work** \u2014 Snowflake Native Apps operate in your Snowflake account, using your existing data without external connections. Developers create and distribute them via the Snowflake Marketplace.  \n**Why Use Them** :\n\n* **Fast** \u2014 Snowflake Native Apps process data directly in Snowflake, reducing latency.\n* **Secure** \u2014 Snowflake Native Apps don\u2019t access or store data outside your account, relying on Snowflake\u2019s encryption and access controls.\n* **Scalable** \u2014 Snowflake Native Apps can grow alongside your Snowflake resources, handling larger datasets or more users.\n\nSnowflake Native Apps (Source: [Snowflake](https://www.snowflake.com/en/data-cloud/workloads/applications/native-apps/) )\n\n### Key Technical Characteristics of Snowflake Native Apps\n\n#### 1) **Native Integration with Snowflake Services**\n\nSnowflake Native Apps work directly with Snowflake\u2019s core services. They use stored procedures , user-defined functions (Snowflake UDFs UDFs) and the Snowpark API, making them efficient and seamless.\n\n#### 2) **Simplified Development and Testing**\n\nYou can build Snowflake Native Applications using the Snowflake Native App Framework. Snowflake Native App Framework streamlines development and testing. You can create, test and deploy Snowflake apps within Snowflake, reducing development time.\n\n#### 3) **Monetization via Snowflake Marketplace**\n\nProviders can list and sell Snowflake apps in the Snowflake Marketplace . Consumers install these apps directly into their Snowflake accounts, simplifying deployment and making app monetization straightforward.\n\n#### 4) **Security and Governance**\n\nSnowflake Native Applications don\u2019t transfer data outside the platform. Providers can package their logic securely, protecting intellectual property. Users maintain control of access permissions, with data security managed by Snowflake\u2019s encryption and governance features .\n\n#### 5) **Data Sharing**\n\nSnowflake Native Apps leverage [Snowflake\u2019s secure data sharing](https://docs.snowflake.com/en/user-guide/data-sharing-intro) . Apps can access shared datasets without creating duplicates or requiring data to leave the user\u2019s Snowflake account.\n\n#### 6) **Advanced Feature Support**\n\nSnowflake Native Applications use Snowflake features like:\n\n* User-Defined Functions (Snowflake UDFs)\n* Stored Procedures\n* [Snowpark](https://docs.snowflake.com/en/developer-guide/snowpark/index)\n\n#### 7) **Versioning and Patching**\n\nSnowflake Native App Framework supports versioning and patching, allowing you to manage updates easily. This keeps your apps up to date.\n\n#### 8) **Streamlit Integration**\n\nYou can integrate your apps with Streamlit , which allows you to create interactive dashboards within Snowflake. While the integration is still evolving, it supports embedding visualizations in your apps for end-user analytics.\n\n#### 9) **Encapsulation in Application Packages**\n\nSnowflake Native Apps are bundled into packages containing all necessary components (e.g., data content, application logic, metadata and setup scripts). This makes deployment simple and reduces compatibility issues.\n\n#### 10) **Source Control and Tool Integration**\n\nYou can integrate with external tools like [IDEs](https://en.wikipedia.org/wiki/Integrated_development_environment) , [CI/CD pipelines](https://www.redhat.com/en/topics/devops/what-cicd-pipeline) and source control systems. This flexibility helps teams adopt DevOps practices when developing Snowflake Native Applications.\n\n#### 11) **AI and ML Workflows**\n\nSnowflake Native Applications support machine learning and AI tasks through Snowpark. You can integrate external ML libraries, process training data and deploy models directly within Snowflake.\n\n#### 12) **Cross-Cloud Deployment (AWS + Azure + with limitations on GCP)**\n\nSnowflake Native Applications are compatible with multiple clouds ( [AWS](https://www.snowflake.com/en/why-snowflake/partners/all-partners/aws/) , [Azure](https://www.snowflake.com/en/why-snowflake/partners/all-partners/microsoft/) and limit on [GCP](https://www.snowflake.com/technology-partners/google-cloud-platform/) ). This feature enables users to run apps across different infrastructures, though GCP support has limitations.\n\n## What Are the Benefits of Snowflake Native Apps \u2014 For Providers?\n\nSnowflake Native Apps offer significant advantages for providers looking to build, distribute and monetize their applications within the Snowflake ecosystem. Here are some of the benefits:\n\n### \u27a5 Simplified Development\n\nProviders can use Snowflake\u2019s tools to build apps that leverage Snowflake\u2019s high availability and scalability. This completely eliminates the need for separate infrastructure, reducing development overhead and speeding up time to market\u200b.\n\nSnowflake Native Apps run within customers\u2019 Snowflake accounts, meaning data stays within their environment, which minimizes the complexity of data integration and security management\u200b.\n\n### \u27a5 **On-Platform Monetization Opportunities**\n\nProviders can easily sell and monetize their Snowflake apps directly within the Snowflake ecosystem via Snowflake Marketplace , bypassing the need for third-party systems.\n\n### \u27a5 **Easy Management**\n\nSince apps are hosted within Snowflake\u2019s infrastructure, you don\u2019t need to manage separate resources. Snowflake offers always-on availability, global reach, built-in governance and secure operations.\n\n### \u27a5 **Data Protection**\n\nSnowflake Native Apps interact directly with the customer\u2019s Snowflake account. This approach keeps customer data within their environment, reducing security risks and compliance burdens. You avoid the complexity of managing sensitive data, as Snowflake\u2019s internal security and governance capability can handle it for you.\n\n### \u27a5 **Zero Infrastructure Management and Lower Operational Costs**\n\nTraditional Snowflake apps often require providers to pay for their own compute and storage. With Snowflake Native Applications, you leverage the customer\u2019s compute resources, reducing your operating costs and improving profit margins.\n\n### \u27a5 **Access to New Customers**\n\nSnowflake Marketplace gives you exposure to a global Snowflake customer base. Here, customers can find, test and purchase your apps. This built-in distribution network simplifies how you reach and onboard users while enabling seamless deployment directly into customer environments.\n\n## What Are the Benefits of Snowflake Native Apps \u2014 For Consumers?\n\nSnowflake Native Apps offer significant advantages for end-users, enhancing their ability to integrate, utilize and manage data applications seamlessly within the Snowflake ecosystem. Here are some of the key benefits of Native Snowflake apps for consumers:\n\n### \u27a5 **Quick and Easy Access**\n\nConsumers can easily search for Snowflake Native Applications on the Snowflake Marketplace or in private listings and directly install and use them with a single click.\n\n### \u27a5 **Secure Data Use**\n\nSince Snowflake Native Applications run directly in the consumer\u2019s Snowflake account, data does not need to leave the platform. This eliminates the risks associated with data transfers and ensures compliance with Snowflake\u2019s robust governance and security controls.\n\n### \u27a5 **Enhanced Performance**\n\nSnowflake Native apps utilize the consumer\u2019s Snowflake compute resources, which ensures optimal performance tailored to the existing workload. Consumers benefit from Snowflake\u2019s underlying scalability and processing power, resulting in faster query execution and application responsiveness\u200b.\n\n### \u27a5 **Streamlined Trial and Deployment**\n\nConsumers can easily test applications via trial periods. Transitioning from trial to full versions is simple and data generated during the trial is retained for future use, making the adoption process seamless and risk-free.\n\n### \u27a5 **Simplified Application Management**\n\nConsumers can manage access privileges, event logging and app-related tasks directly within their Snowflake account.\n\n## How Do Snowflake Native Applications Work?\n\nSnowflake Native Applications leverage the _Snowflake Native App Framework_ to build and deploy data-driven applications directly within the Snowflake ecosystem. These Snowflake apps harness Snowflake\u2019s core features\u2014secure data sharing, analytics, compute and governance\u2014enabling seamless integration and monetization, without requiring data to move outside the platform. The framework supports applications ranging from analytical tools to fully containerized services.\n\nSnowflake Native App Framework allows:\n\n* Providers to share data, business logic and application interfaces (e.g., Streamlit apps, stored procedures) using [Snowpark API](https://docs.snowflake.com/en/developer-guide/snowpark/index) , [Python](https://www.python.org/) , [SQL](https://www.w3schools.com/sql/) and [JavaScript](https://www.w3schools.com/js/) .\n* Applications to be listed as free or paid offerings on the Snowflake Marketplace or shared privately with select accounts.\n* Developers to benefit from streamlined testing environments, version control via external repositories and detailed logging for troubleshooting.\n* Built-in support for structured and unstructured event logging to streamline troubleshooting and performance tracking.\n* Integration with Streamlit to build interactive, user-friendly visual interfaces.\n\nOn top of that, the Snowflake Native Framework also provides an enhanced developer experience, including:\n\n* A unified testing environment for app lifecycle management.\n* Integration with version control systems for seamless code and resource management.\n* Incremental app updates with versioning and patch support.\n\nSnowflake Native Apps extend the functionality of features like Secure Data Sharing and Collaboration, ensuring providers can offer scalable, governed applications to other Snowflake users.\n\n### Architecture of the Snowflake Native App Framework\n\nThe architecture of the Snowflake Native App Framework operates on a provider-consumer model:\n\n* **Provider** \u2014 Creates and shares data and application logic using the framework.\n* **Consumer** \u2014 Installs and interacts with applications shared by providers.\n\nSnowflake Native Applications are packaged as **Application Packages** , which contains the necessary logic, metadata and configuration to deploy a Snowflake Native App. This includes:\n\n* **Manifest file** : Configuration details, including setup script locations and versioning.\n* **Setup script** : Contains SQL commands for installation and updates.\n\nThe provider publishes the Snowflake Native app via:\n\n* **Marketplace Listings** \u2014 Accessible to all Snowflake users for broad distribution.\n* **Private Listings** \u2014 Targeted sharing with specific accounts across regions.\n\nUpon installation, Snowflake creates a corresponding database object for the app, which runs the setup script to establish necessary resources in the consumer\u2019s account. Additional configurations like logging or privilege grants can be applied post-installation.\n\nSnowflake Native App Architecture\n\n### How do Snowflake Native Applications work with Snowpark Container Services?\n\nFor advanced use cases, Snowflake Native Applications can utilize [**Snowpark Container Services**](https://docs.snowflake.com/en/developer-guide/snowpark-container-services/overview) , which enable Snowflake apps to manage containerized workloads within Snowflake. This approach supports high-performance applications, such as machine learning and AI-driven analytics, without externalizing data.\n\nComponents unique to containerized Snowflake apps:\n\n* **Services specification file** \u2014 Applications reference container images stored in the provider\u2019s repository.\n* **Compute pool** \u2014 A collection of virtual machine nodes where containerized workloads execute.\n\nSnowflake Native App with Snowpark Container Architecture\n\nFeatures of Snowpark Container Services include:\n\n* Support for AI/ML workloads with low latency.\n* Persistent data and model storage close to compute resources for efficiency.\n* Seamless deployment across GPU/CPU configurations.\n\n## Step-by-Step Guide to Create a Snowflake Native App\n\nNow that we have covered the features, benefits and inner workings/architecture of Snowflake Native Applications, let\u2019s dive into a step-by-step guide on how you can create a simple Snowflake Native App on Snowflake.\n\nBefore you start building a Snowflake Native App, make sure you meet these requirements:\n\n## Prerequisite:\n\n* **Snowflake CLI** : Install the Snowflake CLI on your machine.\n* [**Visual Studio Code**](https://code.visualstudio.com/) : If you haven\u2019t already installed VSCode, download it from here.\n* **ACCOUNTADMIN Role** : Use the ACCOUNTADMIN role for all steps in this tutorial.\n* **Second Snowflake Account** : If installing your app from a private listing, you need access to a second Snowflake account.\n* **Set a Current Warehouse** : Use the USE WAREHOUSE command to specify the active warehouse.\n* **SQL Command Session** : Run all SQL commands within the same session. The session context must remain consistent as the steps build on one another.\n\nLet\u2019s kick off by covering the main pieces you\u2019ll be working with.\n\n**Application Package**\n\nThink of this as a container for your entire application. It holds:\n\n* Shared data\n* Application logic\n* Deployment artifacts\n\n**Setup Script**\n\nThe blueprint of your application\u2019s initialization. This script:\n\n* Creates schemas\n* Sets up application roles\n* Defines initial objects and permissions\n\n**Manifest File**\n\nYour app\u2019s configuration metadata. It tells Snowflake:\n\n* Which files to include\n* How to structure the deployment\n* Runtime behaviors\n\n**Project Definition File**\n\nDefines deployment specifics:\n\n* Application package name\n* Stages\n* Artifacts to include\n\n### **Step 1** \u2014Configuring the Environment\n\n```\nCREATE DATABASE IF NOT EXISTS my_app_db;\nUSE DATABASE my_app_db;\nCREATE SCHEMA IF NOT EXISTS my_app_schema;\n```\n\nThis sets up a dedicated space for your app\u2019s data and logic.\n\nNow make sure you have an active warehouse set for executing your SQL commands. You can create a new warehouse or use an existing one:\n\n```\nCREATE WAREHOUSE IF NOT EXISTS <warehouse> WITH WAREHOUSE_SIZE = 'SMALL';\nUSE WAREHOUSE <warehouse>;\n```\n\n### **Step 2** \u2014Setting Up Snowflake CLI\n\nTo get started, you need to install and configure Snowflake CLI. It allows users to execute SQL queries and carry out a wide range of DDL and DML operations.\n\nTo download Snowflake CLI, first download from the [SnowSQL download page](https://www.snowflake.com/en/developers/downloads/snowsql/) and then open a new terminal window. Execute the following code to test your connection:\n\n```\nsnow connection add\n```\n\nOnce you have done that, enter all the credentials when prompted.\n\nAdding Snowflake CLI credentials\n\nThat\u2019s it!\n\n> For detailed instructions on installing Snowflake CLI, [refer to the official documentation](https://docs.snowflake.com/developer-guide/snowflake-cli/installation/installation) .\n> \n> \n\n### **Step 3** \u2014Initializing a New Project\n\nNow that your environment is set up, you will initialize a new project folder for your app using the Snowflake CLI. Open your terminal and execute:\n\n```\nsnow init --template app_basic snowflake_native_app_demo\n```\n\nInitializing Snowflake Native App project\n\nThis command creates a directory named **snowflake\\_native\\_app\\_demo** , which contains a basic structure for your Snowflake Native App project.\n\nFolder structure of Demo Snowflake Native App\n\nHere\u2019s what is inside the app directory:\n\nFolder structure of Demo Snowflake Native App\n\n**OR**\n\nYou can clone the starter project which is provided by Snowflake by running the following command:\n\n```\ngit clone https://github.com/Snowflake-Labs/sfguide-getting-started-with-native-apps.git\n```\n\nCloning Starter Snowflake Native App project\n\n### **Step 4** \u2014Creating Application Files\n\nNavigate to the **snowflake\\_native\\_app\\_demo** directory and create several essential files:\n\n**\u27a5 Configuring Setup Script**\n\nThis SQL script runs automatically when a consumer installs your app. Modify **app/setup\\_script.sql** with the following content (add comment for now, we will update the script later on):\n\n```\n-- Snowflake Native App Setup script\n```\n\n**\u27a5 Configuring Manifest File**\n\nThis YAML file contains configuration information about your app. Create/Update **app/manifest.yml** with this:\n\n**\u27a5 Configuring Project Definition File**\n\nThis YAML file defines objects that can be deployed to Snowflake. Create/Update **snowflake.yml** in the root of your project with this:\n\n```\ndefinition_version: 2\nentities:\n\t\tsnowflake_native_app_demo_package:\n\t\t\ttype: application package\n\t\t\t stage: stage_content.hello_snowflake_stage\n\t\t\t manifest: app/manifest.yml\n\t\t\t identifier: snowflake_native_app_demo_package\n\t\t\tartifacts:\n\t\t\t\t - src: app/*\n\t\t\t\t\t\tdest: ./\n\t demo_snowflake_native_app:\n\t\t\t type: application\n\t\t\tfrom:\n\t\t\t\t\ttarget: snowflake_native_app_demo_package\n\t\t\t debug: false\n```\n\nThis file is central to setting up a Snowflake Native App. It specifies key details about the app\u2019s configuration and how resources are managed within Snowflake.\n\nTo create an application package, you need the [CREATE APPLICATION PACKAGE](https://docs.snowflake.com/en/sql-reference/sql/create-application-package) privilege. If your role doesn\u2019t have this, you can grant it with the Snowflake CLI:\n\n```\nsnow sql -q \"GRANT CREATE APPLICATION PACKAGE ON ACCOUNT TO ROLE accountadmin\" -c <connection_name>\n```\n\nGranting Create Application Package to account admin\n\n> Replace **connection\\_name** with the connection name specified in your **config.toml** file.\n> \n> \n\n**snowflake.yml** file defines objects and configuration details. Here\u2019s what it includes:\n\n**a) Application Package**\n\nServes as the container for app-related objects. Example: snowflake\\_native\\_app\\_demo\\_package\n\n**b) Application Object**\n\nCreated from the application package. Example: **demo\\_snowflake\\_native\\_app**\n\n**c) Named Stage**\n\nHolds application files. Example: **stage\\_content.hello\\_snowflake\\_stage** . The stage name is schema-qualified and created inside the application package.\n\nIt stores files for setup scripts or runtime use.\n\n**Artifacts Section**\n\nSpecifies file rules for deployment. Example: Files in app/ are uploaded to the root of the stage.\n\nExample mappings:\n\n```\ntutorial/app/manifest.yml \u2192 @snowflake_native_app_demo_package.stage_content.hello_snowflake_stage\ntutorial/app/README.md \u2192 @snowflake_native_app_demo_package.stage_content.hello_snowflake_stage\ntutorial/app/setup_script.sql \u2192 @snowflake_native_app_demo_package.stage_content.hello_snowflake_stage\n```\n\n> Use <% \u2026 %> syntax for dynamic referencing. Example: <% ctx.entities.pkg.identifier %> accesses the package identifier.\n> \n> \n\n**Debug Mode**\n\nThe debug field in **snowflake.yml** is set to **false** for production. Debug mode is typically enabled by default during development.\n\n**\u27a5 Configuring README File**\n\nThis file provides a description of your application. Create **app/README.md** with a brief description:\n\n```\nThis is a demo Snowflake Native App.\n```\n\n### **Step 5** \u2014Writing the Snowflake Native Application Logic\n\nNow let\u2019s get to the essence of Snowflake Native App development\u2014adding application logic and installing your first app. This involves creating stored procedures, setting up application roles and configuring privileges for seamless execution. Here\u2019s how you can achieve this:\n\n**\u27a5 Add a Stored Procedure to the Setup Script**\n\nThe setup script is central to your app\u2019s functionality. By extending it, you can define key components like roles and stored procedures.\n\nFirst let\u2019s define an Application Role. To do so, add the following to your **setup\\_script.sql** file:\n\n```\nCREATE APPLICATION ROLE IF NOT EXISTS snowflake_native_app_public;\nCREATE SCHEMA IF NOT EXISTS native_app_core;\nGRANT USAGE ON SCHEMA native_app_core TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nAs you can see, this creates an application-specific role ( _snowflake\\_native\\_app\\_public_ ) and a schema (native\\_app\\_core) for the app. And the role is restricted to the app\u2019s context and manages access to app-specific objects.\n\nNext, add a stored procedure that your app can call:\n\n```\nCREATE OR REPLACE PROCEDURE native_app_core.HELLO()\n\tRETURNS STRING\n\tLANGUAGE SQL\n\tEXECUTE AS OWNER\n\tAS\nBEGIN\n\t RETURN 'Demo Snowflake Native App!';\nEND;\n```\n\nThis stored procedure outputs a simple greeting\u2014useful as a test or base for more complex logic.\n\nFinally, grant the application role permission to use the procedure:\n\n```\nGRANT USAGE ON PROCEDURE native_app_core.hello() TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nNow this role can access and execute the stored procedure.\n\nHere is how your **setup\\_script.sql** file should look like:\n\nWriting the Snowflake Native Application Logic\n\nOnce your setup script includes the necessary logic, install the app in stage dev mode using the Snowflake CLI. Dev mode lets you test app behavior before deploying it to production.\n\nTo test it, run the following Snowflake CLI command:\n\n```\nsnow app run -c connection_name\n```\n\nDeploying and Running Snowflake Native App via Snowflake CLI\n\nAs you can see, if the command runs successfully, it outputs a URL where you can see your app in Snowsight.\n\nChecking a Deployed Snowflake Native App in Snowsight\n\nTo run the stored procedure that you added to **setup\\_script.sql** in a previous section, run the following Snowflake CLI command:\n\n```\nsnow sql -q \"call demo_snowflake_native_app.native_app_core.hello()\" -c connection_name\n```\n\nYou should see the following result/output:\n\nRunning deployed Stored procedure via Snowflake CLI\n\n### **Step 6** \u2014Adding Data Content to Your Snowflake Native App\n\nIn this step, you\u2019ll enhance your Snowflake Native App by incorporating shared data content. This involves creating and sharing a table within your app package and granting access to app users. Additionally, you\u2019ll create a view for secure data access by consumers.\n\nFirst, let\u2019s create a table to share with the app. To do so, you can add a table to your app package by writing a SQL script and specifying its execution in the project definition file.\n\nSo let\u2019s create and populate the table. To do that, you need to create a folder **scripts** and inside that folder, create a file called **shared\\_content.sql** . Then, add the following code:\n\n```\nUSE APPLICATION PACKAGE <% ctx.entities.snowflake_native_app_demo_package.identifier %>;\n\nCREATE SCHEMA IF NOT EXISTS shared_data;\nUSE SCHEMA shared_data;\nCREATE TABLE IF NOT EXISTS wealthy_individuals (\n\t\tid INT,\n\t\t name VARCHAR,\n\t\tstatus VARCHAR\n);\n\nTRUNCATE TABLE wealthy_individuals;\n\nINSERT INTO wealthy_individuals VALUES\n\t\t (1, 'Elon', 'Billionaire'),\n\t\t(2, 'Bernard', 'Billionaire'),\n\t\t(3, 'Jeff', 'Billionaire'),\n\t\t (4, 'Warren', 'Billionaire'),\n\t\t(5, 'Larry', 'Billionaire'),\n\t\t(6, 'Sergey', 'Billionaire'),\n\t\t (7, 'Gautam', 'Billionaire'),\n\t\t(8, 'Carlos', 'Billionaire'),\n\t\t (9, 'Mukesh', 'Billionaire'),\n\t\t(10, 'Bill', 'Millionaire'),\n\t\t(11, 'Mark', 'Millionaire'),\n\t\t(12, 'Larry', 'Millionaire'),\n\t\t (13, 'Michael', 'Millionaire'),\n\t\t(14, 'Aman', 'Millionaire'),\n\t\t(15, 'Warren', 'Billionaire');\n```\n\nNow, grant access to the table and schema using:\n\n```\nGRANT USAGE ON SCHEMA shared_data TO SHARE IN APPLICATION PACKAGE <% ctx.entities.snowflake_native_app_demo_package.identifier %>;\nGRANT SELECT ON TABLE wealthy_individuals TO SHARE IN APPLICATION PACKAGE <% ctx.entities.snowflake_native_app_demo_package.identifier %>;\n```\n\nThe placeholder `<% ctx.entities.snowflake_native_app_demo_package.identifier %>` dynamically resolves to your application package identifier during deployment.\n\n**Add the Script to the Project Definition File**\n\nUpdate the **snowflake.yml** file to include the new script in post-deployment hooks:\n\n```\ndefinition_version: 2\nentities:\n\t snowflake_native_app_demo_package:\n\t\t\t type: application package\n\t\t\tstage: stage_content.hello_snowflake_stage\n\t\t\tmanifest: app/manifest.yml\n\t\t\tidentifier: snowflake_native_app_demo_package\n\t\t\t artifacts:\n\t\t\t\t\t- src: app/*\n\t\t\t\t\t dest: ./\n\t\t\t meta:\n\t\t\t\t post_deploy:\n\t\t\t\t\t\t - sql_script: scripts/shared_content.sql\n\t\tdemo_snowflake_native_app:\n\t\t\ttype: application\n\t\t\t from:\n\t\t\t\t target: snowflake_native_app_demo_package\n\t\t\tdebug: false\n```\n\nNext, modify the **setup\\_script.sql** file to create a view that app consumers can use to query the data.\n\n**Create a Versioned Schema:**\n\n```\nCREATE OR ALTER VERSIONED SCHEMA code_schema;\nGRANT USAGE ON SCHEMA code_schema TO APPLICATION ROLE snowflake_native_app_public;\n```\n\n**Create the View:**\n\n```\nCREATE VIEW IF NOT EXISTS code_schema.accounts_view\n\t AS SELECT roll_number, NAME, VALUE\n\t FROM shared_data.wealthy_individuals;\nGRANT SELECT ON VIEW code_schema.accounts_view TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nAfter adding the table and view, test the updated app to make sure everything works as expected. Let\u2019s deploy the updates:\n\n```\nsnow app run -c connection_name\n```\n\nDeploying and Running Snowflake Native App via Snowflake CLI\n\nThis uploads the edited files to the stage, runs **scripts/shared\\_content.sql** and deploys the app.\n\nNow, finally to verify the data access, fire the command below:\n\n```\nsnow sql -q \"SELECT * FROM demo_snowflake_native_app.code_schema.accounts_view\" -c connection_name\n```\n\nVerifying Snowflake data access\n\nThe output should list the sample data from the accounts table.\n\n### **Step 7** \u2014Adding Python Code to Your Snowflake Native App\n\nLet\u2019s enhance our Snowflake Native App by incorporating Python-based logic using User-Defined Functions (Snowflake UDFs). We\u2019ll add both an inline Python UDF and one that references an external Python module.\n\nInline Python UDFs enable you to embed Python logic directly within your setup script. To do so, update your setup script to include the following code:\n\n```\nCREATE OR REPLACE FUNCTION code_schema.squareroot(i INT)\nRETURNS INT\nLANGUAGE PYTHON\nRUNTIME_VERSION = '3.11'\nHANDLER = 'squareroot_py'\nAS\n$$\ndef squareroot_py(i):\n\t return i * i\n$$;\n\nGRANT USAGE ON FUNCTION code_schema.squareroot(INT) TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nAs you can see, this:\n\n* Creates a Python UDF named squareroot in the code\\_schema schema.\n* Uses Python 3.11 runtime.\n* Grants the necessary usage privilege to the snowflake\\_native\\_app\\_public role.\n\nNow let\u2019s reference a Python file for modular and reusable logic. First, let\u2019s add this code to your setup script:\n\n```\nCREATE OR REPLACE FUNCTION code_schema.cuberoot(i INT)\nRETURNS FLOAT\nLANGUAGE PYTHON\nRUNTIME_VERSION = 3.11\nIMPORTS = ('/python/cube_python.py')\nHANDLER = 'cube_python.cuberoot';\n\nGRANT USAGE ON FUNCTION code_schema.cuberoot(INT) TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nNow let\u2019s add the external Python file. To do this, in the project folder, create a subdirectory: **python/** . Inside this folder, create a file named **cube\\_python.py** with the following content:\n\n```\ndef cuberoot(i):\n\t return i * i * i\n```\n\nUpdate the project definition file to include the Python file:\n\n```\nartifacts:\n\t- src: python/cube_python.py\n```\n\nAfter adding the Python UDFs, deploy and validate their functionality.\n\n**Deploy the Updates:**\n\n```\nsnow app run -c connection_name\n```\n\nDeploying and Running Snowflake Native App via Snowflake CLI\n\nThis uploads the updated files to the stage and deploys the app.\n\n**Test the Inline Python UDF:**\n\n```\nsnow sql -q \"SELECT demo_snowflake_native_app.code_schema.squareroot(2)\" -c connection_name\n```\n\nOutput:\n\nTesting the Inline Python UDF \u2013 Snowflake Native App\n\n**Test the External Python UDF:**\n\n```\nsnow sql -q \"SELECT demo_snowflake_native_app.code_schema.cuberoot(2)\" -c connection_name\n```\n\nOutput:\n\nTesting the External Python UDF \u2013 Snowflake Native App\n\n### **Step 8** \u2014Adding a Streamlit App to Your Snowflake Native App\n\nNow, let\u2019s integrate a Streamlit-based user interface into your Snowflake Native App. Streamlit is an open-source framework designed for building interactive data applications, offering features for data visualization and user interaction.\n\nHead over to your project folder and create a subdirectory named **streamlit/** . Inside the streamlit folder, create a file named **streamlit\\_app.py** . Then, add the following Python code to **streamlit\\_app.py** :\n\n```\n# Import python packages\nimport streamlit as st\nfrom snowflake.snowpark import Session\n\nst.title(\"Demo Snowflake Native Application\")\nst.write(\n\t\t\"\"\"Demo of Snowflake Native Application\"\"\")\n\n# Get the current credentials\nsession = Session.builder.getOrCreate()\n\n# Create an example data frame\ndata_frame = session.sql(\"SELECT * FROM code_schema.accounts_view\")\n\n# Execute the query and convert it into a Pandas data frame\nqueried_data = data_frame.to_pandas()\n\n# Display the Pandas data frame as a Streamlit data frame.\nst.dataframe(queried_data, use_container_width=True)\n```\n\nNext, add the following to the artifacts section of the project definition file:\n\n```\nartifacts:\n\t - src: streamlit/streamlit_app.py\n```\n\nThis is how your **snowflake.yml** should look:\n\n```\ndefinition_version: 2\nentities:\n\t\tsnowflake_native_app_demo_package:\n\t\t\ttype: application package\n\t\t\t stage: stage_content.hello_snowflake_stage\n\t\t\t manifest: app/manifest.yml\n\t\t\t identifier: snowflake_native_app_demo_package\n\t\t\tartifacts:\n\t\t\t\t - src: app/*\n\t\t\t\t\t\tdest: ./\n\t\t\t\t - src: python/cube_python.py\n\t\t\t\t\t- src: streamlit/streamlit_app.py\t\t\t\t\n\t\t\tmeta:\n\t\t\t\t\tpost_deploy:\n\t\t\t\t\t\t- sql_script: scripts/shared_content.sql\n\t demo_snowflake_native_app:\n\t\t\t type: application\n\t\t\tfrom:\n\t\t\t\t\ttarget: snowflake_native_app_demo_package\n\t\t\t debug: false\n```\n\nThen, create the Streamlit object. To do that, add the following to the end of the **setup\\_script.sql** file:\n\n```\nCREATE STREAMLIT IF NOT EXISTS code_schema.snowflake_streamlit_native_app\n\tFROM '/streamlit'\n\t MAIN_FILE = '/streamlit_app.py'\n;\n```\n\nAdd the following statement to the same script to allow the application role to access the Streamlit object:\n\n```\nGRANT USAGE ON STREAMLIT code_schema.hello_snowflake_streamlit TO APPLICATION ROLE snowflake_native_app_public;\n```\n\nDeploy the updates by running the following command to update the app:\n\n```\nsnow app run -c connection_name\n```\n\nDeploying and Running Snowflake Native App via Snowflake CLI\n\nAfter deployment, a URL will be printed in the console. Navigate to this URL to interact with the app. Click the **snowflake\\_streamlit\\_native\\_app** tab to view the Streamlit interface.\n\nChecking a Deployed Streamlit App in Snowsight\n\n### **Step 9** \u2014Versioning Your Snowflake Native App\n\nLets formalize your Snowflake Native App by creating a version. While previous steps utilized \u201cstage development\u201d mode for rapid iteration, adding a version is essential for listing the application package and sharing it with other Snowflake users.\n\nRun the following command to create version V1 for the **snowflake\\_native\\_app\\_demo\\_package** application package:\n\n```\nsnow app version create v1 -c connection_name\n```\n\nVersioning Snowflake Native App\n\nHere is how you would check the version of the app to see whether it was added successfully or not. To do so, run the following command:\n\n```\nsnow app version list -c connection_name\n```\n\nVersioning Snowflake Native App\n\n### **Step 10** \u2014Installing and Testing the Versioned App\n\nTo install and test the versioned app, run the following command to install the app based on the created version:\n\nDeploying and Running Snowflake Native App via Snowflake CLI\n\n### **Step 11** \u2014Viewing Snowflake Native App in Snowsight\n\nAfter finalizing your Snowflake Native App, you can use Snowsight, Snowflake\u2019s web interface, to explore your app visually, instead of relying solely on SQL commands.\n\nTo start, sign in to Snowsight using your Snowflake credentials. Once logged in, switch to the **ACCOUNTADMIN** role to ensure you have the necessary permissions. You can do this by selecting your username from the navigation menu, opening the account menu and switching from the current active role (e.g., PUBLIC) to **ACCOUNTADMIN** . Next, navigate to the **Data Products** section and select **Apps** from the menu.\n\nNavigating to Data Products > Apps section\n\nLocate your application, **DEMO\\_SNOWFLAKE\\_NATIVE\\_APP** , in the list.\n\nChecking a Deployed Snowflake Native App in Snowsight\n\nClicking on it opens the **Read Me** tab, which displays the content of the **README.md** file you created earlier in this tutorial.\n\nTo view the Streamlit interface, find and select **SNOWFLAKE\\_STREAMLIT\\_NATIVE\\_APP** .\n\nChecking a Deployed Streamlit App in Snowsight\n\n## Monetization and Distribution of Snowflake Native App\n\nNow that we have covered the detailed steps of how you can create and build Snowflake Native Applications from scratch, let\u2019s go through the process of how you can monetize your Snowflake Native Applications via Snowflake Marketplace. But before that, let\u2019s actually understand what Snowflake Marketplace is.\n\nThe Snowflake Marketplace is a platform where users can discover, evaluate and purchase a variety of products, including third-party data, data services, Snowflake Native Apps and AI products. It serves as a public data exchange integrated within the Snowflake Data Cloud, facilitating seamless and secure transactions between data providers and consumers.\n\nThe Snowflake marketplace offers various types of data products, such as:\n\n* Raw datasets\n* Refined and enriched data\n* Historical datasets for forecasting and machine learning\n* Real-time data streams (like weather or traffic updates)\n* Specialized identity or audience data for analytics\n* Snowflake Native Applications\n* Pre-built data pipelines and transformations\n\nSnowflake Marketplace leverages Snowflake\u2019s architecture to facilitate the secure sharing of data and applications. Transactions are managed natively, eliminating the need for third-party billing systems. Vendors can offer their products through various pricing models, such as pay-as-you-go, one-time payment, usage-based payment, or subscription-based plans, while benefiting from Snowflake\u2019s built-in analytics to track customer engagement.\n\nLet\u2019s jump right into the juicy part of the article: a step-by-step guide to monetizing Snowflake Native Applications via Snowflake Marketplace.\n\n### Step-By-Step Monetization Process of a Snowflake Native App via Snowflake Marketplace\n\n#### **Step 1** \u2014Prepare Your Snowflake Native Application Package\n\nBefore monetization, make sure your Snowflake Native App meets Snowflake\u2019s submission requirements:\n\n* The app must be fully functional upon installation, with all necessary resources and configurations included.\n* It must not depend on external systems for core functionality.\n* Should Leverage Snowflake-stored or shared data for operations.\n* Include the following files:\n  \n    + **manifest.yml** (outlines app permissions and dependencies).\n    + **readme.md** (describes app functionality, post-installation setup steps and sample usage SQL).\n    + Setup scripts and external components like Streamlit files or UDF code\n\n#### **Step 2** \u2014Define the Default Release Directive\n\nNow, set the release directive to specify the app version and patch available for distribution:\n\nList available versions and patches:\n\n```\nsnow app version list -c connection_name\n```\n\nThen, set the default release directive:\n\n```\nsnow sql -q \"ALTER APPLICATION PACKAGE <your_app_package> SET DEFAULT RELEASE DIRECTIVE VERSION = v1 PATCH = 0\"\n```\n\nVersioning Snowflake Native App\n\nAs you can see, this command sets version **v1** and patch **0** as the default for your app, ensuring it is ready for deployment\u200b.\n\n#### **Step 3** \u2014Create and Configure a Private Listing on the Snowflake Marketplace\n\nTo share your app via the Snowflake Marketplace, start by signing in to Snowsight and navigating to **Data Products > Provider Studio** .\n\nNavigating to Provider Studio in Snowflake\n\nClick **\\+ Listing** to create a new listing and proceed with configuration. Enter a name for the listing and specify the discovery permissions, choosing whether the listing will be public or restricted to specific consumers (e.g., select \u201c **Only specified consumers** \u201d for private sharing and select \u201c **Anyone on the Marketplace** \u201d for public listing).\n\nCreating a private listing for only specified consumers \u2013 Snowflake Native App\n\nAttach the application package you prepared earlier as the core data content for the listing. Provide a detailed description outlining your app\u2019s features and usage scenarios. If creating a private listing, add the account identifiers of intended consumers in the \u201c **Add** **Consumer accounts** \u201d section. Finally, publish your listing for approval.\n\nCreating a private listing for only specified consumers \u2013 Snowflake Native App\n\n#### **Step 4** \u2014Create and Configure a Public Paid Listing on the Snowflake Marketplace\n\nNow, to create a public listing, you need to first contact your Snowflake business development partner to approve your paid listing. If you don\u2019t have a business development partner, you\u2019ll need to [submit a case with Marketplace Operations](https://snowflakecommunity.force.com/s/provider-onboarding-case) . Before proceeding, verify that your [role has the required privileges to create a listing](https://other-docs.snowflake.com/en/collaboration/provider-becoming) .\n\nOnce everything is in place, you need to log in to Snowsight and go to Data Products > Provider Studio from the menu. Select **\\+ Listing** to open the Create Listing window. Here, name your listing and set its visibility. To make the listing publicly discoverable, choose \u201c **Anyone on the Marketplace** \u201d under the discovery settings.\n\nCreating a paid private listing for only specified consumers \u2013 Snowflake Marketplace\n\nNext, you need to decide how consumers will access your data product: choose \u201c **Free** \u201d for no-cost access, \u201c **Personalized/Limited Trial** \u201d to offer a trial version with full access upon request, or \u201c **Paid** \u201d if you plan to charge consumers directly.\n\nAfter setting the access type, click **Next** to generate a draft listing. Lastly, refine and configure the draft by including all necessary details to ready it for publication on the Snowflake Marketplace.\n\n#### **Step 5** \u2014Submit Listing for Approval\n\nAll listings on the Snowflake Marketplace must undergo a review and approval process before publication. If a listing is rejected, review the provided feedback, make the necessary updates and resubmit it for approval.\n\nBefore publishing make sure that your listing configuration is complete, you have the **ACCOUNTADMIN** role or **OWNERSHIP** privilege for the associated data product and all sample SQL queries in the listing are validated successfully. To submit your listing, sign in to Snowsight, navigate to **Data Products \u27a4 Provider Studio** , go to the Listings tab, select your draft listing and click **Submit for Approval** .\n\nSubmitting listing for final approval from Snowflake\n\n#### **Step 6** \u2014Final Approval and Publishing\n\nOnce submitted, Snowflake will review your listing and provide an **Approved** or **Denied** status. If denied, review the feedback, make the necessary updates and resubmit the listing. After receiving approval, return to the **Listings** tab, select your approved listing and click **Publish** . Upon publication, the listing will be visible to consumers in all current and future Snowflake Marketplace regions. Regional availability can be managed through cross-cloud auto-fulfillment settings and you can create referral links for direct access to your listing.\n\n## Further Reading\n\n* [Snowflake Native Apps](https://www.snowflake.com/en/data-cloud/workloads/applications/native-apps/)\n* [What Are Native Apps?](https://www.snowflake.com/guides/what-are-native-apps/)\n* [About the Snowflake Native App Framework](https://docs.snowflake.com/en/developer-guide/native-apps/native-apps-about)\n* [Snowflake Native App Framework on AWS and Azure](https://www.snowflake.com/en/blog/native-app-framework-available-aws-azure/)\n* [Introducing the Snowflake Native App Framework](https://www.snowflake.com/en/blog/introducing-snowflake-native-application-framework/)\n* [Getting Started with Snowflake Native Apps](https://quickstarts.snowflake.com/guide/getting_started_with_native_apps/)\n* [Snowflake Native Apps Example](https://github.com/snowflakedb/native-apps-examples)\n\n## Conclusion\n\nAnd that\u2019s a wrap! Snowflake Native Apps are built using the Snowflake Native App Framework. This allows developers to create, test and launch apps right in Snowflake. The framework simplifies the process of building, launching and integrating advanced tools. It ensures security and governance by tapping into the Snowflake ecosystem. For providers, these apps provide an easy way to sell their solutions on the Snowflake Marketplace, reaching thousands of customers. Meanwhile, consumers get instant access to the apps without needing a complex setup.\n\nIn this article, we have covered:\n\n* What are Native Apps in Snowflake?\n* Key features and characteristics of Snowflake Native Apps\n* What are the benefits of Snowflake Native Apps for providers?\n* What are the benefits of Snowflake Native Apps for consumers?\n* How do Snowflake Native Apps work?\n* Step-by-step guide to create a Snowflake Native App\n* Monetization and distribution of Snowflake Native Apps\n* Step-by-step monetization process via Snowflake Marketplace\n\n\u2026 and so much more!\n\n## FAQs\n\n**What are Native Apps in Snowflake?**\n\nSnowflake Native Apps are designed specifically to operate within the Snowflake ecosystem without requiring external access or movement of sensitive data outside its environment.\n\n**How can I develop and test a Snowflake Native App locally?**\n\nDevelopers can set up their environments using tools like VSCode along with necessary extensions provided by Snowflakes such as CLI support.\n\n**Can I share my Snowflake Native App with other users?**\n\nYes! Once published on the marketplace after meeting compliance requirements.\n\n**Does the Snowflake Native App framework support logging and monitoring?**\n\nYes! Snowflake Native App framework includes telemetry tools that allow developers to monitor application performance post-deployment.\n\n**What is Streamlit\u2019s role in Snowflake Native apps?**\n\nStreamlit allows developers to create interactive web interfaces that enhance user engagement directly within their Snowflake Native Applications.\n\n**Can I update my Snowflake Native App after deployment?**\n\nYes! Providers have control over release cycles allowing them to push updates seamlessly even after deployment.\n\nRelated posts:\n\n* [Empowering users with intuitive, actionable data: introducing Data Explorer](https://www.flexera.com/blog/it-visibility/empowering-users-with-intuitive-actionable-data-introducing-data-explorer/ \"Empowering users with intuitive, actionable data: introducing Data Explorer\")\n* [From Spot Eco to Flexera One Cloud Commitment Management: A new era of automated cloud cost optimization](https://www.flexera.com/blog/finops/from-spot-eco-to-flexera-one-cloud-commitment-management-a-new-era-of-automated-cloud-cost-optimization/ \"From Spot Eco to Flexera One Cloud Commitment Management: A new era of automated cloud cost optimization\")\n* [The practical FinOps roadmap series: What to do before you start practicing FinOps (1/4)](https://www.flexera.com/blog/finops/the-practical-finops-roadmap-series-what-to-do-before-you-start-practicing-finops-1-4/ \"The practical FinOps roadmap series: What to do before you start practicing FinOps (1/4)\")\n* [FinOps and ITAM: A unified approach to optimizing technology investments](https://www.flexera.com/blog/finops/finops-and-itam-a-unified-approach-to-optimizing-technology-investments/ \"FinOps and ITAM: A unified approach to optimizing technology investments\")\n* [Elevate your packaging efficiency: Introducing \u2018My Requests\u2019 in AdminStudio](https://www.flexera.com/blog/application-readiness/elevate-your-packaging-efficiency-introducing-my-requests-in-adminstudio/ \"Elevate your packaging efficiency: Introducing \u2018My Requests\u2019 in AdminStudio\")\n* [What\u2019s new at Flexera: May 2025](https://www.flexera.com/blog/product/whats-new-at-flexera-may-2025/ \"What\u2019s new at Flexera: May 2025\")\n\n### Want to know more?\n\nTechnology is evolving rapidly\u2014and it's important to stay on top of the latest trends and critical insights. Check out the latest blogs related to FinOps below.\n\nFinOps\n\n## [2025 State of the Cloud](https://info.flexera.com/CM-REPORT-State-of-the-Cloud?lead_source=Website%20Visitor&id=Blog-Resources \"2025 State of the Cloud\")\n\nMarch 12, 2024\n\nFinOps\n\n## [Cloud Cost Optimization demo](https://info.flexera.com/CM-DEMO-Cloud-Cost-Optimization-Request \"Cloud Cost Optimization demo\")\n\nFebruary 22, 2023\n\nFinOps\n\n## [Practical Guide for a Successful Cloud Journey](https://info.flexera.com/CM-GUIDE-Successful-Cloud-Journey?lead_source=Website%20Visitor&id=Blog-Resources \"Practical Guide for a Successful Cloud Journey\")\n\nFebruary 9, 2022\n\nFinOps\n\n## [Cloud Migration and Modernization Datasheet](https://www.flexera.com/sites/default/files/datasheet-foundation-cloudscape.pdf \"Cloud Migration and Modernization Datasheet\")\n\nFinOps\n\n## [Agentic FinOps for AI: autonomous optimization for Snowflake, Databricks and AI cloud costs](https://www.flexera.com/blog/finops/agentic-finops-for-ai-autonomous-optimization-for-snowflake-databricks-and-ai-cloud-costs/ \"Agentic FinOps for AI: autonomous optimization for Snowflake, Databricks and AI cloud costs\")\n\nFebruary 12, 2026\n\nFinOps\n\n## [Snowflake BUILD 2025: Quick recap of new features](https://www.flexera.com/blog/finops/snowflake-build-2025/ \"Snowflake BUILD 2025: Quick recap of new features\")\n\nJanuary 28, 2026\n\n\u00d7\n\nGet updates delivered to your inbox\n\nSubscribe\n\n## How can we help?\n\nSales Team\n\n[Community](https://community.flexera.com/s/)\n\nSubscribe\n\nFlexera\n\n* [](https://www.linkedin.com/company/flexera?elqTrackId=62e00a6465d449b0824c83c70706dff9&elq=00000000000000000000000000000000&elqaid=6833&elqat=2&elqCampaignId=&elqcst=272&elqcsid=143 \"LinkedIn\")\n* [](https://twitter.com/flexera?elqTrackId=ab8f06bd7aea498e807592d19ac2ab00&elq=00000000000000000000000000000000&elqaid=6833&elqat=2&elqCampaignId=&elqcst=272&elqcsid=143 \"Twitter\")\n* [](https://www.instagram.com/weareflexera?elqTrackId=fcfa0064605a42baaebfabe8fedd5c50&elq=00000000000000000000000000000000&elqaid=6833&elqat=2&elqCampaignId=&elqcst=272&elqcsid=143 \"Instagram\")\n* [](https://www.youtube.com/user/FlexeraSoftware?elqTrackId=c6e9107020754655a13aca3ac7aa3cd4&elq=00000000000000000000000000000000&elqaid=6833&elqat=2&elqCampaignId=&elqcst=272&elqcsid=143 \"YouTube\")\n\n* Privacy policy\n* Terms and conditions\n* Site map"
      ],
      "full_content": null
    }
  ],
  "errors": [],
  "warnings": [
    {
      "type": "warning",
      "message": "Neither objective nor search_queries were provided, provide at least one to increase the relevance of excerpts.",
      "detail": null
    }
  ],
  "usage": [
    {
      "name": "sku_extract_excerpts",
      "count": 1
    }
  ]
}
