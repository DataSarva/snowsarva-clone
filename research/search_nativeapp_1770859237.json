{"search_id":"search_187642cd54844017ad06956e4d758fd8","results":[{"url":"https://docs.snowflake.com/en/developer-guide/native-apps/manifest-overview","title":"Create the manifest file for an app | Snowflake Documentation","excerpts":["[DOCUMENTATION](https://docs.snowflake.com)\n/\n[Get started](/en/user-guide-getting-started)\n[Guides](/en/guides)\n[Developer](/en/developer)\n[Reference](/en/reference)\n[Release notes](/en/release-notes/overview)\n[Tutorials](/en/tutorials)\n[Status](https://status.snowflake.com)\n[Overview](/en/developer \"Overview\")\nBuilders\n[Snowflake DevOps](/en/developer-guide/builders/devops \"Snowflake DevOps\")\n[Observability](/en/developer-guide/builders/observability \"Observability\")\nSnowpark Library\n[Snowpark API](/en/developer-guide/snowpark/index \"Snowpark API\")\n[Spark workloads on Snowflake](/en/developer-guide/snowpark-connect/snowpark-connect-overview \"Spark workloads on Snowflake\")\nMachine Learning\n[Snowflake ML](/en/developer-guide/snowflake-ml/overview \"Snowflake ML\")\nSnowpark Code Execution Environments\n[Snowpark Container Services](/en/developer-guide/snowpark-container-services/overview \"Snowpark Container Services\")\n[Functions and procedures](/en/developer-guide/extensibility \"Functions and procedures\")\n[Logging, Tracing, and Metrics](/en/developer-guide/logging-tracing/logging-tracing-overview \"Logging, Tracing, and Metrics\")\nSnowflake APIs\n[Snowflake Python APIs](/en/developer-guide/snowflake-python-api/snowflake-python-overview \"Snowflake Python\nAPIs\")\n[Snowflake REST APIs](/en/developer-guide/snowflake-rest-api/snowflake-rest-api \"Snowflake REST APIs\")\n[SQL API](/en/developer-guide/sql-api/index \"SQL API\")\nApps\n[Streamlit in Snowflake](/en/developer-guide/streamlit/about-streamlit \"Streamlit in Snowflake\")\n[Snowflake Native App Framework](/en/developer-guide/native-apps/native-apps-about \"Snowflake Native App Framework\")\n[Snowflake Declarative Sharing](/en/developer-guide/declarative-sharing/about \"Snowflake Declarative Sharing\")\n[Snowflake Native SDK for Connectors](/en/developer-guide/native-apps/connector-sdk/about-connector-sdk \"Snowflake Native SDK for Connectors\")\nExternal Integration\n[External Functions](/en/sql-reference/external-functions \"External Functions\")\n[Kafka and Spark Connectors](/en/user-guide/connectors \"Kafka and Spark Connectors\")\nSnowflake Scripting\n[Snowflake Scripting Developer Guide](/en/developer-guide/snowflake-scripting/index \"Snowflake Scripting Developer Guide\")\nTools\n[Snowflake\nCLI](/en/developer-guide/snowflake-cli/index \"Snowflake CLI\")\n[Git](/en/developer-guide/git/git-overview \"Git\")\nDrivers\n[Overview](/en/developer-guide/drivers \"Overview\")\n[Considerations when drivers reuse sessions](/en/developer-guide/driver-connections \"Considerations when drivers reuse sessions\")\nReference\n[API Reference](/en/api-reference \"API Reference\")\n[Developer](/en/developer) [Snowflake Native App Framework](/en/developer-guide/native-apps/native-apps-about) Create the manifest file\nSection Title: Create the manifest file for an app [¶]( \"Link to this heading\")\nContent:\n[](../../_images/logo-snowflake-black.png) Feature — Generally Available\nThe Snowflake Native App Framework is generally available on supported cloud platforms. For additional information, see [Support for private connectivity, VPS, and government regions](limitations.html) .\nThis topic describes how to create the manifest file for an app.\nSection Title: ... > About the manifest file [¶]( \"Link to this heading\")\nContent:\nThe manifest file contains information that the application package\nrequires to create and manage a Snowflake Native App. This includes the location\nof the setup script, version definitions, and configuration information\nfor the app.\nThe manifest file has the following requirements:\nThe name of the manifest file must be `manifest.yml` .\nThe manifest file must be uploaded to a named stage so that it is\naccessible to the application package.\nThe manifest file must exist at the root of the directory structure on\nthe named stage where other application files are stored.\nSection Title: ... > Version 1 and version 2 of the manifest file [¶]( \"Link to this heading\")\nContent:\nSnowflake Native Apps supports two versions of the manifest file. The version is\nspecified using the `manifest_version` field.\n`manifest_version: 1`\nThis version of the manifest file supports the current and\nlegacy functionality of Snowflake Native Apps. `manifest_version: 2`\nThis version of the manifest file provides support for additional\nfeatures, including automated granting of privileges.\nSection Title: ... > Security considerations when using version 2 of the manifest file [¶]( \"Link to this heading\")\nContent:\nWhen using version 2 of the manifest file, consider the following security implications:\nWhen a provider configures an app to use `manifest_version: 2` in the manifest file, automated granting of\nprivileges is enabled. By default this allows Snowflake to automatically\ngrant certain privileges to the app. For information on the privileges\nthat can be automatically granted to the app, see [Privileges granted by automated granting of privileges](requesting-auto-privs.html) .\nDuring installation, Snowsight displays a notification about\nthe privileges requested by the app. When a consumer installs an app\nthat uses automated granting of privileges, they agree that the app may\nbe granted these privileges during upgrades without requiring additional\nconsent.\nSection Title: ... > Security considerations when using version 2 of the manifest file [¶]( \"Link to this heading\")\nContent:\nConsumers can create feature policies that restrict the objects an app\ncan create. For more information on creating feature policies, see [Use feature policies to limit the objects an app can create](ui-consumer-feature-policies) .\nSection Title: ... > Specify the privileges required by an app with containers [¶]( \"Link to this heading\")\nContent:\nLike other apps, the `privileges` field of the manifest file\nspecifies the privileges that an app with containers requests from\nconsumers.\nThe following privileges are specific to an app with containers:\nCREATE COMPUTE POOLThis privilege is required to allow the app to create a compute pool in the consumer account. It is not required if the consumer creates\nthe compute pool manually.\nBIND SERVICE ENDPOINTThis privilege is required to allow an endpoint to be accessible outside of Snowflake.\nThe following example shows how to add these privileges to the `privileges` block:\n```\nprivileges : \n - CREATE COMPUTE POOL : \n description : 'Required to allow the app to create a compute pool in the consumer account.' \n - BIND SERVICE ENDPOINT : \n description : 'Required to allow endpoints to be externally accessible.'\n```\nCopy\nSection Title: ... > Specify the container images used by an app with containers [¶]( \"Link to this heading\")\nContent:\nTo specify the location of the container images used by the app with\ncontainers, add the `images` property to the `artifacts.container_services` block.\nYou must include an entry for each image. The path specified includes\nthe name of the database, schema, and image repository. This path has\nthe following form:\n```\n/<database>/<schema>/<image_repository>/<image_name>:tag\n```\nCopy\nThe following example shows how to specify the `images` property:\n```\nartifacts \n ... \n container_services \n ... \n images \n - /dev_db/dev_schema/dev_repo/image1 \n - /dev_db/dev_schema/dev_repo/image2\n```\nCopy\nSection Title: ... > Specify the user interface endpoint for an app with containers [¶]( \"Link to this heading\")\nContent:\nTo specify the endpoint for the user interface of the app with\ncontainers, add the `default_web_endpoint` property to the `artifacts` block.\nThe `default_web_endpoint` property is optional. If this property\nis specified, the endpoint must also be defined in the service\nspecification file.\nNote\nOnly one of the `default_web_endpoint` and `default_streamlit` can be specified.\nThis entry in the manifest file has two additional properties:\n`service`\nSpecifies the name of the service of the user interface.\n`endpoint`\nSpecifies the name of the endpoint.\nThe following example shows how to specify the `default_web_endpoint` property.\n```\ndefault_web_endpoint : \n service : ux_schema.ux_service \n endpoint : ui\n```\nCopy\nSection Title: ... > Example manifest files [¶]( \"Link to this heading\")\nContent:\nThe following examples show typical manifest files for different types of use cases.\nSection Title: ... > Example manifest file for using automated granting of privileges [¶]( \"Link to this heading\")\nContent:\nThe following manifest file shows how to configure an app to use\nautomated granting of privileges. This example uses version 2 of the\nmanifest file. The `privileges` block specifies the privileges that the app requires.\n```\nmanifest_version : 2 \n version : \n name : v1 \n artifacts : \n readme : readme.md \n setup_script : setup.sql \n privileges : \n - CREATE TABLE : \n description : \"Allows the app to create tables in the consumer account\" \n - CREATE WAREHOUSE : \n description : \"Allows the app to create warehouses in the consumer account\"\n```\nCopy\nWhen the app is installed, Snowflake automatically grants the CREATE TABLE and CREATE WAREHOUSE privileges to the app.\nSection Title: ... > Example manifest file files for an app with containers [¶]( \"Link to this heading\")\nContent:\nSnowflake Native Apps supports entries in the manifest file that are specific to\nan app with containers. The following example manifest file\nshows a typical manifest file for an app with containers:\n```\nmanifest_version : 2 \n version : \n name : v1 \n artifacts : \n readme : readme.md \n setup_script : setup.sql \n container_services : \n images : \n - /dev_db/dev_schema/dev_repo/image1 \n - /dev_db/dev_schema/dev_repo/image2 \n default_web_endpoint : \n service : ux_schema.ux_service \n endpoint : ui \n privileges : \n - CREATE COMPUTE POOL : \n description : \"...\" \n - BIND SERVICE ENDPOINT : \n description : \"...”\n```\nCopy\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\n[Share your feedback](/feedback)\n[Read the latest on our blog](https://www.snowflake.com/blog/)\nSection Title: ... > Example manifest file files for an app with containers [¶]( \"Link to this heading\")\nContent:\n[Get your own certification](https://learn.snowflake.com)\n[Privacy Notice](https://www.snowflake.com/privacy-policy/) [Site Terms](https://www.snowflake.com/legal/snowflake-site-terms/) Cookies Settings © 2025 Snowflake, Inc. All Rights Reserved.\nOn this page\n[About the manifest file]()\n[Version 1 and version 2 of the manifest file]()\n[Security considerations when using version 2 of the manifest file]()\n[Specify the privileges required by an app with containers]()\n[Specify the container images used by an app with containers]()\n[Specify the user interface endpoint for an app with containers]()\n[Example manifest files]()\nRelated content\n[Snowflake Native App manifest file reference](/developer-guide/native-apps/manifest-reference)\nLanguage: **English**\nSection Title: ... > Example manifest file files for an app with containers [¶]( \"Link to this heading\")\nContent:\n[English](/en/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)\n[Français](/fr/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)\n[Deutsch](/de/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)\n[日本語](/ja/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)\n[한국어](/ko/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)\n[Português](/pt/developer-guide/native-apps/manifest-overview?utm_cta=website-glossary-managed-warehouse-ebk)"]},{"url":"https://www.snowflake.com/en/developers/guides/build-a-native-app-with-spcs/","title":"Build a Snowflake Native App with Snowpark Container Services","excerpts":["[Skip to content]()\nData for Breakfast Around the World\nDrive impact across your organization with data and agentic intelligence.\n[register now](https://www.snowflake.com/en/data-for-breakfast/)\n[Snowflake for Developers](https://www.snowflake.com/content/snowflake-site/global/en/developers) [Guides](https://www.snowflake.com/content/snowflake-site/global/en/developers/guides) Build a Snowflake Native App with Snowpark Container Services\nSection Title: Build a Snowflake Native App with Snowpark Container Services\nContent:\nBuild\nCharles Yorek\n[fork repo](https://github.com/Snowflake-Labs/sfquickstarts/tree/master/site/sfguides/src/build-a-native-app-with-spcs)\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Overview\nContent:\nThe Snowflake Native App Framework is a powerful way for application providers to build, deploy and market applications via the Snowflake Marketplace. In this example you will learn how to incorporate Snowpark Container Services into a Snowflake Native App allowing you to deploy a variety of new capabilities to a consumers Snowflake account.\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Overview > Prerequisites\nContent:\nA Snowflake account with ACCOUNTADMIN access\nFamiliarity with Snowflake Snowsight Interface\nBasic Knowledge of Docker and Container Concepts\nAbility to install and run software on your computer\nBasic experience using git\nSnowpark Container Services is available across a [range of cloud providers and regions](https://docs.snowflake.com/en/developer-guide/snowpark-container-services/overview) . For this lab ensure that you have an account in one of the supported regions.\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Overview > What You’ll Learn\nContent:\nHow to create an app using the Snowflake Native App framework\nHow to build and push container images to a Snowflake account\nHow to integrate those images into a Snowflake Native App and allow consumers to create Services\nHow to test the Snowflake Native App Provider and Consumer experience within a single Snowflake account\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Overview > What You’ll Need\nContent:\nA [GitHub](https://github.com/) Account\n[VSCode](https://code.visualstudio.com/download) Installed\n[Docker Desktop](https://www.docker.com/products/docker-desktop/) Installed\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Overview > What You’ll Build\nContent:\nIn this quickstart we'll create a Snowflake Native App that uses Snowpark Container Services to deploy the following into a Snowflake account:\nVue-based JavaScript frontend\nFlask-based Python middle tier\nnginx as a router\nOnce deployed, the application can be accessed via a [Service Endpoint](https://docs.snowflake.com/en/sql-reference/sql/show-endpoints) which then queries the\nTPC-H 100 data set and returns the top sales clerks. The frontend provides date pickers to restrict the range of the sales data and a slider to determine how many top clerks to display. The data is presented in a table sorted by highest seller to lowest.\nSection Title: Build a Snowflake Native App with Snowpark Container Services > ... > Overview\nContent:\nIn preparation for building our Snowflake Native App we need to download the code artifacts for the Native App along with the files to create our Container images from Github.\nSection Title: ... > Step 2.1 - Clone or Download Github Repo\nContent:\nThe code for the Native App and Container Images are on Github. Start by cloning or downloading the repository into a separate folder.\ngit clone https://github.com/Snowflake-Labs/sfguide-build-a-native-app-with-spcs\n```\n\nCopy\n```\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Native App Provider Setup > Overview\nContent:\nTo simulate a Native App provider experience we will create a role called 'naspcs_role' and grant it the necessary privileges required to create an [Application Package](https://docs.snowflake.com/en/developer-guide/native-apps/creating-app-package) as well as create a database that will store both our app code and Snowpark Container Service Images.\nSection Title: ... > Step 3.1 - Create NASPCS role and Grant Privileges\nContent:\nuse role accountadmin;\ncreate role if not exists naspcs_role;\ngrant role naspcs_role to role accountadmin;\ngrant create integration on account to role naspcs_role;\ngrant create compute pool on account to role naspcs_role;\ngrant create warehouse on account to role naspcs_role;\ngrant create database on account to role naspcs_role;\ngrant create application package on account to role naspcs_role;\ngrant create application on account to role naspcs_role with grant option;\ngrant bind service endpoint on account to role naspcs_role;\n```\n\nCopy\n```\nSection Title: ... > Step 3.2 - Create SCPS_APP Database to Store Application Files and Container Images\nContent:\nuse role naspcs_role;\ncreate database if not exists spcs_app;\ncreate schema if not exists spcs_app.napp;\ncreate stage if not exists spcs_app.napp.app_stage;\ncreate image repository if not exists spcs_app.napp.img_repo;\ncreate warehouse if not exists wh_nap with warehouse_size='xsmall';\n```\n\nCopy\n```\nSection Title: Build a Snowflake Native App with Snowpark Container Services > Consumer Privilege Setup > Overview\nContent:\nTo simulate the app consumer experience we will create a role called 'nac' and grant it the necessary privileges required to create Applications as well as set up a database to house the data we'll be querying with our Snowflake Native App.\n ... \nSection Title: Build a Snowflake Native App with Snowpark Container Services > Build and Upload Images > Overview\nContent:\nNow that we have a place in our Snowflake account to house our application code and images we need to build the images and push them to our Image Repository. We'll then upload our app files that detail how to install, setup and configure the Snowflake Native App.\n ... \nSection Title: Build a Snowflake Native App with Snowpark Container Services > ... > Step 5.2.1 - Makefile Apprach\nContent:\nCopy the 'repository_url' value after you run the above commands. After this switch to Terminal/Command Prompt and navigate to where you cloned or downloaded and unzipped the Github Repository in step 2.2. When you are at the folder run the following command:\n./configure.sh\n```\n\nCopy\n```\nYou will be prompted to paste the 'repository_url' into the command prompt and press enter to complete this configuration step.\nEnsure that Docker is running and in a Terminal/Command Prompt run the following command in the root of the Github repo you cloned or downloaded.\nmake all\n```\n\nCopy\n```\nThis should begin the process of running the required Docker BUILD and PUSH commands to upload the images to your Snowflake account.\n ... \nSection Title: Build and Push router > Step 5.3 - Upload Native App Code\nContent:\nAfter the Image upload process completes the code we'll use to build our App package needs to be uploaded to the **SPCS_APP.NAPP.APP_STAGE** stage. This can be accomplished by navigating to this stage using Snowsight - click on the 'Database' icon on the left side navigation bar and then on the **SPCS_APP database > NAPP schema > APP_STAGE stage** . You will need to do the following:\nClick on 'Select Warehouse' and choose 'WH_NAP' for the Warehouse\nClick on the '+ Files' button in the top right corner\nBrowse to the location where you cloned or downloaded the Github repo and into the '/app/src' folder\nSelect all 4 files (setup.sql, fullstack.yaml, manifest.yml, readme.md)\nClick the 'Upload' button\nWhen this is done succesfully your SPCS_APP.NAPP.APP_STAGE should look like the following in Snowsight:\n ... \nSection Title: Build and Push router > Install and Run Application > Overview\nContent:\nWe can now use the Consumer role to install our Snowflake Native App - but to get it fully deployed we will also need to create a Compute Pool for our Snowpark Containers to run on as well as start the Service.\n ... \nSection Title: Build and Push router > ... > Step 7.2 - Create Compute Pool and Grant Privileges\nContent:\nuse database nac_test;\nuse role nac;\ncreate  compute pool pool_nac for application spcs_app_instance\nmin_nodes = 1 max_nodes = 1\ninstance_family = cpu_x64_s\nauto_resume = true;\ngrant usage on compute pool pool_nac to application spcs_app_instance;\ngrant usage on warehouse wh_nac to application spcs_app_instance;\ngrant bind service endpoint on account to application spcs_app_instance;\nCALL spcs_app_instance.v1.register_single_callback(\n'ORDERS_TABLE' , 'ADD', SYSTEM$REFERENCE('VIEW', 'NAC_TEST.DATA.ORDERS', 'PERSISTENT', 'SELECT'));\n```\n\nCopy\n```\nSection Title: Build and Push router > Install and Run Application > Step 7.3 - Start App Service\nContent:\nWith the Compute Pool created and the App configured we can now run the START_APP Stored Procedure installed with the Native App to create the Service using the POOL_NAC Compute Pool and the WH_NAC Virtual Warehouse to execute queries against the Snowflake account.\ncall spcs_app_instance.app_public.start_app('POOL_NAC', 'WH_NAC');\n--After running the above command you can run the following command to determine when the Service Endpoint is ready\n--Copy the endpoint, paste into a browser, and authenticate to the Snowflake account using the same credentials you've been using to log into Snowflake\ncall spcs_app_instance.app_public.app_url();\n```\n\nCopy\n```\nWhen up and running you should see a screen like this at your service endpoint.\n ... \nSection Title: Build and Push router > Conclusion And Resources\nContent:\nCongratulations! You've now deployed a Snowflake Native App that includes Snowpark Container Service hosting a customer Frontend and Backend for a web application.\nSection Title: Build and Push router > Conclusion And Resources > What we've covered\nContent:\nIn this Quickstart we covered the following:\nHow to create a app using the Snowflake Native App framework\nHow to build and push container images to a Snowflake account\nHow to integrate those images into a Snowflake Native App and allow consumers to create Services\nHow to test the Snowflake Native App Provider and Consumer experience within a single Snowflake account\nThis Quickstart can provide a template for you to accomplish the basic steps of building a Snowflake Native App that includes a Snowpark Container Service to deploy & monetize whatever unique code to your Snowflake consumers accounts.\nSection Title: Build and Push router > Conclusion And Resources > Related Resources\nContent:\n[Snowflake Native Apps](/en/data-cloud/workloads/applications/native-apps/?_fsi=vZHZai1N&_fsi=vZHZai1N&_fsi=vZHZai1N)\n[Snowflake Native Apps Documentation](https://docs.snowflake.com/en/developer-guide/native-apps/native-apps-about)\n[Snowpark Container Services](https://docs.snowflake.com/en/developer-guide/snowpark-container-services/overview?_fsi=vZHZai1N&_fsi=vZHZai1N&_fsi=vZHZai1N)\nUpdated Dec 20, 2025\nThis content is provided as is, and is not maintained on an ongoing basis. It may be out of date with current Snowflake instances\n**Subscribe to our monthly newsletter** Stay up to date on Snowflake’s latest products, expert insights and resources—right in your inbox!\n*\n*\n ... \nSection Title: Build and Push router > Conclusion And Resources > Related Resources\nContent:\n[Financial Services](https://www.snowflake.com/en/solutions/industries/financial-services/)\n[Healthcare & Life Sciences](https://www.snowflake.com/en/solutions/industries/healthcare-and-life-sciences/)\n[Manufacturing](https://www.snowflake.com/en/solutions/industries/manufacturing/)\n[Public Sector](https://www.snowflake.com/en/solutions/industries/public-sector/)\n[Retail & Consumer Goods](https://www.snowflake.com/en/solutions/industries/retail-consumer-goods/)\n[Technology](https://www.snowflake.com/en/solutions/industries/technology/)\nLearn * [Resource Library](https://snowflake.com/en/resources/)"]},{"url":"https://docs.snowflake.com/en/developer-guide/native-apps/container-workflow","title":"Workflow: Develop an app with containers | Snowflake Documentation","excerpts":["[Developer](/en/developer) [Snowflake Native App Framework](/en/developer-guide/native-apps/native-apps-about) App with containers development workflow\n\n# Workflow: Develop an app with containers [¶]( \"Link to this heading\")\n\n[](../../_images/logo-snowflake-black.png) Feature — Generally Available\n\nThe Snowflake Native App Framework is generally available on supported cloud platforms. For additional information, see [Support for private connectivity, VPS, and government regions](limitations.html) .\n\nThis topic describes the general workflow for creating a Snowflake Native App with Snowpark Container Services.\n\n## Understand Snowpark Container Services and the Snowflake Native App Framework [¶]( \"Link to this heading\")\n\nBefore beginning to develop a Snowflake Native App with Snowpark Container Services\n\n1. Ensure that you are familiar with [Snowpark Container Services](../snowpark-container-services/overview) and the [Snowflake Native App Framework](native-apps-about) .\n   \n   The following tutorials are available for these Snowflake products:\n   \n    + [Common Setup for Snowpark Container Services Tutorials](../snowpark-container-services/tutorials/common-setup)\n    + [Create a Snowpark Container Services service](../snowpark-container-services/tutorials/tutorial-1)\n    + [Create a Snowpark Container Services job service](../snowpark-container-services/tutorials/tutorial-2)\n    + [Develop an app with the Snowflake Native App Framework](tutorials/getting-started-tutorial)\n    + [Create a Snowflake Native App with Snowpark Container Services](tutorials/na-spcs-tutorial)\n2. Review [About Snowflake Native Apps with Snowpark Container Services](native-apps-about.html) to understand how Snowflake Native App with Snowpark Container Services works.\n3. Review [Costs associated with apps with containers](container-cost-governance) to understand the\n   costs associated with developing, publishing, and using an app with containers.\n\n## Create the containers and services to be managed by an app. [¶]( \"Link to this heading\")\n\nThe first step in developing an app with containers is to set up the required containers and services using [Snowpark Container Services](../snowpark-container-services/overview) .\n\nThe basic workflow for using Snowpark Container Services is:\n\n1. Create a repository to store container images.\n   \n   This repository exists in the provider account and maintains the container images required by the\n   app. See [Create an image repository](container-containers.html)\n2. Copy the container images to the image repository.\n   \n   After creating the image repository, providers must upload the container images used by the application.\n   Snowpark Container Services support using Docker commands to perform the upload.\n   \n   See [Upload container images to the image repository](container-containers.html) for\n   more information.\n3. Create a service specification file.\n   \n   The service specification file is a YAML file used to configure and run services within\n   Snowpark Container Services. Snowflake Native App with Snowpark Container Services includes this file within the application package.\n   \n   See [Create the service specification file](container-containers.html) for more information.\n4. Configure block storage and snapshots.\n   \n   If the services in your app require using block storage, create a `spec.volumes` in your\n   service specification file.\n   \n   See [Using block storage volumes with services](../snowpark-container-services/block-storage-volume) for more information.\n5. Upload the required files to a stage.\n   \n   To make the service specification file accessible to the application package,\n   providers must upload it to the stage used to store other files required by the application package.\n   \n   See [Staging data files from a local file system](../../user-guide/data-load-local-file-system-stage) and [Staging files using Snowsight](../../user-guide/data-load-local-file-system-stage-ui) for more information on uploading files\n   to a stage.\n   \n   Note\n   \n   If you are using the Snowflake CLI, you are not required to upload the files to a stage.\n\n## Develop and publish a Snowflake Native App with Snowpark Container Services [¶]( \"Link to this heading\")\n\nThe workflow for developing and publishing an app with containers is similar to the\nworkflow for any Snowflake Native App. However, within each stage of the workflow there are\ndifferences.\n\nThe following is a typical workflow for developing and publishing an app with containers:\n\n1. Create the manifest file for the app.\n   \n   The manifest file for an app with containers includes configuration information about the\n   containers included in the app. See [Create the manifest file for an app with containers](container-manifest) for more information.\n2. Create the setup script for the app.\n   \n   The specific contents of the setup script depend on the requirements of the app. For\n   general information on creating the setup script for an app, see [Create a setup script](creating-setup-script) .\n   \n   Within the setup script you can create the following objects that are specific to\n   a Snowflake Native App with Snowpark Container Services:\n   \n    + [Add a compute pool to an app with containers](container-compute-pool)\n    + [Add services to an app](container-services)\n    + [Add job services to an app](container-services-job)\n   \n   You can also add other objects that are part of any Snowflake Native App, including:\n   \n   > + Warehouses\n   >     + External access integrations\n   >     + Secrets\n   > \n   >\n3. Create the application package.\n   \n   The process of creating an application package for an app with containers is the\n   same as other apps. See [Create an application package](creating-app-package) for more\n   information.\n4. Publish the app\n   \n   Publishing an app as a private listing or on the Snowflake Marketplace is the same\n   as other apps. See [Share an app with consumers](https://other-docs.snowflake.com/en/native-apps/provider-publishing-app-package) for more information.\n\nWas this page helpful?\n\nYes No\n\n[Visit Snowflake](https://www.snowflake.com)\n\n[Join the conversation](https://community.snowflake.com/s/)\n\n[Develop with Snowflake](https://developers.snowflake.com)\n\n[Share your feedback](/feedback)\n\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n\n[Get your own certification](https://learn.snowflake.com)\n\n[Privacy Notice](https://www.snowflake.com/privacy-policy/) [Site Terms](https://www.snowflake.com/legal/snowflake-site-terms/) © 2025 Snowflake, Inc. All Rights Reserved.\n\nOn this page\n\n1. [Understand Snowpark Container Services and the Snowflake Native App Framework]()\n2. [Create the containers and services to be managed by an app.]()\n3. [Develop and publish a Snowflake Native App with Snowpark Container Services]()\n\nRelated content\n\n1. [About the Snowflake Native App Framework](/developer-guide/native-apps/native-apps-about)\n\nLanguage: **English**\n\n* [English](/en/developer-guide/native-apps/container-workflow)\n* [Français](/fr/developer-guide/native-apps/container-workflow)\n* [Deutsch](/de/developer-guide/native-apps/container-workflow)\n* [日本語](/ja/developer-guide/native-apps/container-workflow)\n* [한국어](/ko/developer-guide/native-apps/container-workflow)\n* [Português](/pt/developer-guide/native-apps/container-workflow)\n"]},{"url":"https://docs.snowflake.com/en/developer-guide/declarative-sharing/manifest-reference","title":"Declarative Native App manifest reference | Snowflake Documentation","excerpts":["[Overview](/en/developer \"Overview\")\nBuilders\n[Snowflake DevOps](/en/developer-guide/builders/devops \"Snowflake DevOps\")\n[Observability](/en/developer-guide/builders/observability \"Observability\")\nSnowpark Library\n[Snowpark API](/en/developer-guide/snowpark/index \"Snowpark API\")\n[Spark workloads on Snowflake](/en/developer-guide/snowpark-connect/snowpark-connect-overview \"Spark workloads on Snowflake\")\nMachine Learning\n[Snowflake ML](/en/developer-guide/snowflake-ml/overview \"Snowflake ML\")\nSnowpark Code Execution Environments\n[Snowpark Container Services](/en/developer-guide/snowpark-container-services/overview \"Snowpark Container Services\")\n[Functions and procedures](/en/developer-guide/extensibility \"Functions and procedures\")\n[Logging, Tracing, and Metrics](/en/developer-guide/logging-tracing/logging-tracing-overview \"Logging, Tracing, and Metrics\")\nSnowflake APIs\n[Snowflake Python APIs](/en/developer-guide/snowflake-python-api/snowflake-python-overview \"Snowflake Python\nAPIs\")\n[Snowflake REST APIs](/en/developer-guide/snowflake-rest-api/snowflake-rest-api \"Snowflake REST APIs\")\n[SQL API](/en/developer-guide/sql-api/index \"SQL API\")\nApps\n[Streamlit in Snowflake](/en/developer-guide/streamlit/about-streamlit \"Streamlit in Snowflake\")\n[Snowflake Native App Framework](/en/developer-guide/native-apps/native-apps-about \"Snowflake Native App Framework\")\n[Snowflake Native SDK for Connectors](/en/developer-guide/native-apps/connector-sdk/about-connector-sdk \"Snowflake Native SDK for Connectors\")\nExternal Integration\n[External Functions](/en/sql-reference/external-functions \"External Functions\")\n[Kafka and Spark Connectors](/en/user-guide/connectors \"Kafka and Spark Connectors\")\nSnowflake Scripting\n[Snowflake Scripting Developer Guide](/en/developer-guide/snowflake-scripting/index \"Snowflake Scripting Developer Guide\")\nTools\n[Snowflake CLI](/en/developer-guide/snowflake-cli/index \"Snowflake CLI\")\n[Git](/en/developer-guide/git/git-overview\n ... \n[Developer](/en/developer) [Snowflake Declarative Sharing](/en/developer-guide/declarative-sharing/about) Manifest reference\nSection Title: Declarative Native App manifest reference [¶]( \"Link to this heading\")\nContent:\n[](../../_images/logo-snowflake-black.png) Preview Feature — Public\nSupport for Snowflake Declarative Native Apps is available to all accounts.\nProviders create a manifest file as part of a  .\nThe manifest file is a text-based [YAML](https://yaml.org/spec/) file, with the filename: `manifest.yml` . It’s used to declaratively share data with consumers, such as notebooks, tables, and views.\nThe manifest file also defines [app roles](app-roles) , which app owners can use to share a subset of the app’s data and features to teams in their organization teams by role.\nFor information about developing an application package, see [Application Packages in Declarative Sharing in the Native Application Framework](package) .\nSection Title: ... > Declarative Native App manifest [¶]( \"Link to this heading\")\nContent:\nThe general format of a Declarative Native App manifest contains:\n```\nmanifest_version : # Added automatically. Don't include. \n application_content : # Optional, describes associated app logic \n roles : # Optional, describes roles associated with shared_content \n shared_content : # Required, describes associated data to be shared\n```\nCopy\nSection Title: ... > Fields [¶]( \"Link to this heading\")\nContent:\nDeclarative Native App manifests include the following fields:\nSection Title: ... > `manifest_version` field [¶]( \"Link to this heading\")\nContent:\nThis field is added automatically to the manifest file when you release a new version of an application package.\nDon’t include this field when creating a manifest file to include in an application package. Editing this field manually is not supported.\nThe `manifest_version` top level field (Integer, required) specifies the version\nnumber of the manifest file.\nFor more information about versioning, see [Package Versions in Declarative Sharing in the Native Application Framework](versioning) .\nSection Title: ... > `application_content` field [¶]( \"Link to this heading\")\nContent:\nThe `application_content` field (list, optional) defines bundled content declaratively shared by the app.\nThis field includes a single `notebooks` field:\n`application_content.notebooks` (List, required): A list of named [notebooks](../../user-guide/ui-snowsight/notebooks) .\nSection Title: ... > `application_content.notebooks.{named notebook}` field [¶]( \"Link to this heading\")\nContent:\nEach named notebook supports the following name value pairs:\n`main_file` (string, required) the name of the interactive Python notebook (.ipynb) file.\n`comment` (string, optional): A comment describing the notebook.\n`runtime_environment_version` (string, optional): Specifies a particular [runtime environment version](../../user-guide/ui-snowsight/notebooks.html) for the notebook execution context, if applicable within the platform.\n`roles` (list, optional): A list of app roles that can grant access to the notebook, for example, `[sales,marketing]` . When this field is empty ( `[]` ) or omitted, then only app owners and roles with [granted IMPORTED PRIVILEGES](consumer/install.html) receive access. The included roles must be defined in the [top-level roles field]() .\n ... \nSection Title: ... > `roles` field [¶]( \"Link to this heading\")\nContent:\nThe `roles` top level field (list, optional) defines a list of [app roles](app-roles) . These roles allow app owners to provide access to shared objects in an app, such as schemas, tables, views, and notebooks, to their organization.\nEach named role can optionally contain a `comment` , which appears as a description when the app owner lists the roles in the application.\nThese roles are referenced in the manifest by shared objects, at the named `notebook` , `schema` , `table` , `view` , or `semantic_view` level. For objects at the `table` or `view` level, roles must also be specified at the `schema` level.\nNote\nSection Title: ... > `roles` field [¶]( \"Link to this heading\")\nContent:\nAll content in the manifest is accessible to the app owner, the ACCOUNTADMIN, and to roles that are granted [IMPORTED PRIVILEGES](consumer/install.html) to the app.\nThe object name defined in this manifest file is used for the runtime object resolution. If the provider changes the object name without updating the manifest file with a new version, consumers will lose access to the object.\nSection Title: ... > `roles` example [¶]( \"Link to this heading\")\nContent:\n```\nroles : \n - sales : \n - marketing : \n\n application_content : \n notebooks : \n - salesbook : \n roles : [ sales , marketing ] \n main_file : NOTEBOOK1.ipynb \n comment : Sales and marketing notebook \n\n shared_content : \n databases : \n - sales : \n schemas : \n - orders : \n roles : [ sales , marketing ] \n tables : \n - january_2025 : # App owners/assignees only \n - february_2025 : \n roles : [ sales ] # Accessible to sales only \n - march_2025 : \n roles : [ marketing ] # Accessible to marketing only \n - customer_info : \n schemas : \n - customer_contact : \n roles : [ customer_support ] \n views : \n - customer_address : \n roles : [ customer_support ] # Accessible to customer_support \n - customer_details : \n roles : [] # App owners/assignees only\n```\nCopy\nFor more information about roles, see [app roles](app-roles) .\n ... \nSection Title: ... > `schemas.{named schema}` field [¶]( \"Link to this heading\")\nContent:\nEach named schema supports the following name value pairs:\n`tables` (list, [[OneOfRequired]]() ): A list of named tables.\n`views` (list, [[OneOfRequired]]() ): A list of named views.\n`semantic_views` (list, [[OneOfRequired]]() ): A list of named semantic views.\n`roles` (list, optional): A list of app roles that the objects in the schema can use; for example, `[sales,marketing]` . When this field is empty ( `[]` ) or omitted, then only app owners and roles with [granted IMPORTED PRIVILEGES](consumer/install.html) receive access. The included roles must be defined in the [top-level roles field]() .\n[ OneOfRequired ] ( [1]() , [2]() , [3]() , [4]() , [5]() )\nat least one of `tables` , `views` , or `semantic_views` is required.\nSection Title: ... > `tables.{named table}` field [¶]( \"Link to this heading\")\nContent:\nEach named table (list, required) supports the following name value pair:\n`roles` (list, optional): A list of app roles that can access the table; for example, `[sales]` . When this field is empty ( `[]` ) or omitted, then only app owners and roles with [granted IMPORTED PRIVILEGES](consumer/install.html) receive access. The included roles must be defined in the [top-level roles field]() and included in the [{named schema}.roles]() field.\nSection Title: ... > `views.{named view}` field [¶]( \"Link to this heading\")\nContent:\nEach named view (List, required [[OneOfRequired]]() ): supports the following name value pair:\n`roles` (list, optional): A list of app roles that can access the view; for example, `[marketing]` . When this field is empty ( `[]` ) or omitted, then only app owners and roles with [granted IMPORTED PRIVILEGES](consumer/install.html) receive access. The included roles must be defined in the [top-level roles field]() and included in the [{named schema}.roles]() field.\nSection Title: ... > `semantic_views.{named semantic view}` field [¶]( \"Link to this heading\")\nContent:\nEach named semantic view (List, required [[OneOfRequired]]() ): supports the following name value pair:\n`roles` (list, optional): A list of app roles that can access the semantic view; for example, `[sales]` . Note that, when sharing a semantic view, its referenced tables or views must be shared as well. When this field is empty ( `[]` ) or omitted, then only app owners and roles with [granted IMPORTED PRIVILEGES](consumer/install.html) receive access. The included roles must be defined in the [top-level roles field]() and included in the [{named schema}.roles]() field.\n ... \nSection Title: ... > `shared_content` example [¶]( \"Link to this heading\")\nContent:\n```\nroles : \n - sales : \n - marketing : \n\n shared_content : \n required_databases : \n sales_projections \n customer_analytics \n databases : \n - sales : \n schemas : \n - orders : \n roles : [ sales , marketing ] \n tables : \n - january_2025 : # App owners/assignees only \n - february_2025 : \n roles : [ sales ] # Accessible to sales only \n - march_2025 : \n roles : [ marketing ] # Accessible to marketing only \n - customer_info : \n schemas : \n - customer_contact : \n roles : [ customer_support ] \n views : \n - customer_address : \n roles : [ customer_support ] # Accessible to customer_support \n - customer_details : \n roles : [] # App owners/assignees only\n```\nCopy\nSection Title: ... > Manifest file example [¶]( \"Link to this heading\")\nContent:\nThe following code block is an example of a Declarative Native App manifest file:\n```\nmanifest_version : 2 \n\n roles : \n - VIEWER : \n comment : \"The VIEWER role provides access to only one view.\" \n - ANALYST : \n comment : \"The ANALYST role provides access to both views and the table.\" \n\n shared_content : \n databases : \n - SNAF_POPULATION_DB : \n schemas : \n - DATA_SCHEMA : \n roles : [ VIEWER , ANALYST ] \n tables : \n - COUNTRY_POP_BY_YEAR : \n roles : [ ANALYST ] \n views : \n - COUNTRY_POP_BY_YEAR_2000 : \n roles : [ VIEWER , ANALYST ] \n\n application_content : \n notebooks : \n - intro_notebook : \n roles : [ VIEWER , ANALYST ] \n main_file : INTRO_NB.ipynb \n - analyst_notebook : \n roles : [ ANALYST ] \n main_file : ANALYST_NB.ipynb\n```\nCopy\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)"]},{"url":"https://docs.snowflake.com/en/developer-guide/snowflake-cli/native-apps/project-definitions","title":"Project definition files | Snowflake Documentation","excerpts":["[DOCUMENTATION](https://docs.snowflake.com)\n/\n[Get started](/en/user-guide-getting-started)\n[Guides](/en/guides)\n[Developer](/en/developer)\n[Reference](/en/reference)\n[Release notes](/en/release-notes/overview)\n[Tutorials](/en/tutorials)\n[Status](https://status.snowflake.com)\n[Developer](/en/developer) [Snowflake CLI](/en/developer-guide/snowflake-cli/index) [Using Snowflake Native Apps](/en/developer-guide/snowflake-cli/native-apps/overview) About project definitions\nSection Title: Project definition files [¶]( \"Link to this heading\")\nContent:\nA project definition file called `snowflake.yml` declares a directory as a Snowflake Native App project. It is a version-controlled file that resides at the root of a Snowflake Native App project directory and can either be created manually or by Snowflake CLI as part of project initialization. As long as you can provide this structured file in the directory but choose to use your own independent project structure, Snowflake CLI can discover the relevant files and carry out its functionality as usual.\nFor Native Apps, your `snowflake.yml` would look similar to the following:\nSection Title: Project definition files [¶]( \"Link to this heading\")\nContent:\n```\ndefinition_version : 2 \n entities : \n pkg : \n type : application package \n identifier : <name_of_app_pkg> \n stage : app_src.stage \n manifest : app/manifest.yml \n artifacts : \n - src : app/* \n dest : ./ \n - src : src/module-add/target/add-1.0-SNAPSHOT.jar \n dest : module-add/add-1.0-SNAPSHOT.jar \n - src : src/module-ui/src/* \n dest : streamlit/ \n meta : \n role : <your_app_pkg_owner_role> \n warehouse : <your_app_pkg_warehouse> \n post_deploy : \n - sql_script : scripts/any-provider-setup.sql \n - sql_script : scripts/shared-content.sql \n app : \n type : application \n identifier : <name_of_app> \n from : \n target : pkg \n debug : <true|false> \n meta : \n role : <your_app_owner_role> \n warehouse : <your_app_warehouse>\n```\nCopy\n ... \nSection Title: ... > Application package entity properties [¶]( \"Link to this heading\")\nContent:\n*required* , *string* |Must be `application package` . |\n|**manifest**\n*optional* , *string* |The location of the Snowflake Native App `manifest.yml` file in your project.\nNote\nWith version 3.2, this property switched from required to optional. |\n|**deploy_root**\n*optional* , *string* |Subdirectory at the root of your project where the build step copies the artifacts. Once copied to this location, you can deploy them to a Snowflake stage.\nDefault: `output/deploy` |\n|**generated_root**\n*optional* , *string* |Subdirectory of the deploy root where Snowflake CLI writes generated files.\nDefault: `__generated` |\n|**stage**\n*optional* , *string* |Identifier of the stage that stores the application artifacts. The value uses the form `<schema_name>.<stage_name>` . The stage lives within the Application Package object. You can change the name to avoid name collisions.\nDefault: `app_src.stage` |\n|**artifacts**\nSection Title: ... > Application package entity properties [¶]( \"Link to this heading\")\nContent:\n*required* , *sequence* |List of file source and destination pairs to add to the deploy root, as well as an optional Snowpark annotation processor. You can use the following artifact properties:\n`src` : Path to the code source file or files\n`dest` : Path to the directory to deploy the artifacts.Destination paths that reference directories must end with a `/` . A glob pattern’s destination that does not end with a `/` results in an error. If omitted, `dest` defaults to the same string as `src` .You can also pass in a string for each item instead of a `dict` , in which case the value is treated as both `src` and `dest` .\n`processors` : Name of the processor to use to process the `src` code files. See [More information about artifacts processors]() for more details.\nIf `src` refers to just one file (not a glob), `dest` can refer to a target `<path>` or a `<path/name>` .\n ... \nSection Title: ... > Application entity properties [¶]( \"Link to this heading\")\nContent:\n*optional* , *sequence* |List of optional events to share with the provider in addition to the mandatory events. All events listed here must be declared in the `configuration.telemetry_event_definitions` section of the `manifest.yml` file. This field is supported only when `share_mandatory_events` is set to `true` .\n```\ntelemetry : \n share_mandatory_events : true \n optional_shared_events : \n - DEBUG_LOGS\n```\nCopy |\n|**debug**\n*optional* , *boolean* |Whether to enable debug mode when using a named stage to create an application.\nDefault: `True` |\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\nNote\nSnowflake CLI supports event sharing only in `snowflake.yml` files based on definition version 2 or later. If you currently use an earlier version, see [Migrating project definition files from version 1.x to 2.0](../project-definitions/migrate-projects) .\n[Event sharing](../../native-apps/event-definition) allows applications to send telemetry events back to application package owners. When testing an application with an application package requiring event sharing, you must explicitly enable event sharing for the application installation to succeed.\nTo enable sharing of specific events, you must also have the events configured in the `configuration.telemetry_event_definitions` section in the `manifest.yml` file for the application package. You must also have the MANAGE EVENT SHARING global privilege to authorize event sharing for the application.\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\nAfter event sharing is enabled in your application’s manifest, you must add a `telemetry` section to your `snowflake.yml` file that specifies the events you want to share from your application. The following code shows a sample `telemetry` section:\n```\ndefinition_version : 2 \n entities : \n app : \n type : application \n from : \n target : pkg \n telemetry : \n share_mandatory_events : true \n optional_shared_events : \n - DEBUG_LOGS \n\n ...\n```\nCopy\nThe following examples illustrate different ways to share events in the `snowflake.yml` file. All of the examples are based on the following section in the application package’s `manifest.yml` file:\n```\nconfiguration : \n telemetry_event_definitions : \n - type : ERRORS_AND_WARNINGS \n sharing : MANDATORY \n - type : DEBUG_LOGS \n sharing : OPTIONAL\n```\nCopy\n ... \nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\n```\n\nCopy\n\n## More information about artifacts processors [¶]( \"Link to this heading\")\n\nIf you include the `artifacts.processors` field in the project definition file, the `snow app bundle` command invokes custom processing for Python code files in the `src` directory or file.\n\nThis section covers a list of supported processors.\n\n### Snowpark processor [¶]( \"Link to this heading\")\n\nNote\n\nThe Snowpark processor has been deprecated and will be removed in a future release.\n\nOne of the processors supported by Snowflake CLI is `snowpark` , which applies Snowpark annotation processing to Python files. The following code examples show the basic structure and syntax for different processing environments:\n\n* To execute code in a conda environment, use the following:\n\n```\npkg :\nartifacts :\nsrc : <some_src>\ndest : <some_dest>\nprocessors :\nname : snowpark\nproperties :\nenv :\ntype : conda\nname : <conda_name>\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\n```\n\nCopy\n\nwhere `<conda_name>` is the name of the conda environment containing the Python interpreter and the Snowpark library you want to use for Snowpark annotation processing.\n* To execute code in a Python virtual environment, use the following:\n\n```\npkg :\nartifacts :\nsrc : <some_src>\ndest : <some_dest>\nprocessors :\nname : snowpark\nproperties :\nenv :\ntype : venv\npath : <venv_path>\n```\n\nCopy\n\nwhere `<venv_path>` is the path of the Python virtual environment containing the Python interpreter and the Snowpark library you want to use for Snowpark annotation processing. The path can be absolute or relative to the project directory.\n* To execute code in the currently active environment, use any of the following equivalent definitions:\n\n```\npkg :\nartifacts :\nsrc : <some_src>\ndest : <some_dest>\nprocessors :\nname : snowpark\nproperties :\nenv :\ntype : current\n```\n\nCopy\n\nor\n\n```\npkg :\nartifacts :\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\nsrc : <some_src>\ndest : <some_dest>\nprocessors :\nname : snowpark\n```\n\nCopy\n\nor\n\n```\npkg :\nartifacts :\nsrc : <some_src>\ndest : <some_dest>\nprocessors :\nsnowpark\n```\n\nCopy\n\nFor more information about custom processing, see [Automatic SQL code generation](bundle-app.html) and the [snow app bundle](../command-reference/native-apps-commands/bundle-app) command.\n\n### Templates processor [¶]( \"Link to this heading\")\n\nSnowflake Native App projects support templates in arbitrary files, which lets you expand templates in all files in an artifact’s `src` directory.\nYou can enable this feature by including a `templates` processor in the desired `artifacts` definition, as shown in the following example:\n\n```\ndefinition_version : 2\nentities :\npkg :\ntype : application package\nidentifier : myapp_pkg\nartifacts :\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\nsrc : app/*\ndest : ./\nprocessors :\ntemplates\nmanifest : app/manifest.yml\napp :\ntype : application\nidentifier : myapp_<% fn.get_username() %>\nfrom :\ntarget : pkg\n```\n\nCopy\n\nWhen Snowflake CLI uploads the files to a stage, it automatically expands the templates before uploading them. For example, suppose your application contained an `app/README.md` file with the following content that includes the `<% ctx.entities.pkg.identifier %>` template:\n\n```\nThis is a README file for application package <% ctx.entities.pkg.identifier %>.\n```\n\nCopy\n\nThe template is then expanded to the following before uploading the file to a stage:\n\n```\nThis is a README file for application package myapp_pkg.\nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\n```\n\nCopy\n\n## Project definition overrides [¶]( \"Link to this heading\")\n\nThough your project directory must have a `snowflake.yml` file, you can choose to customize the behavior of the Snowflake CLI by providing local overrides to `snowflake.yml` , such as a new role to test out your own application package. These overrides must be put in the `snowflake.local.yml` file that lives beside the base project definition. Snowflake suggests that you add it to your `.gitignore` file so it won’t be version-controlled by git. All templates provided by Snowflake already include it in the `.gitignore` file.\n\nThis overrides file must live in the same location as your `snowflake.yml` file.\n\nThe `snowflake.local.yml` file shares the exact schema as `snowflake.yml` , except that every value that was required is now optional, in additional to the already optional ones. The following shows a sample `snowflake.local.yml` file:\n\n```\n ... \nSection Title: ... > Sharing events with providers [¶]( \"Link to this heading\")\nContent:\n```\n\nCopy\n\nEvery `snow app` command prioritizes the parameters in this file over those set in base `snowflake.yml` configuration file. Sensible defaults already provide isolation between developers using the same Snowflake account to develop the same application project, so if you are just getting started we suggest not including an overrides file. The final definition schema obtained after overriding `snowflake.yml` with `snowflake.local.yml` is called the resolved project definition. ### Limitations [¶]( \"Link to this heading\")\n\nCurrently, Snowflake CLI does not support\n\n* Multiple override files. * A blank override file. Only create this file if you want to override a value from `snowflake.yml` . Was this page helpful?"]},{"url":"https://medium.com/snowflake/developing-snowflake-native-apps-with-snowpark-container-services-part-i-e2223269418c","title":"Developing Snowflake Native Apps with Snowpark Container Services: Part I | by Maneet Taneja | Snowflake Builders Blog: Data Engineers, App Developers, AI, & Data Science | Medium","publish_date":"2024-06-04","excerpts":["Section Title: Developing Snowflake Native Apps with Snowpark Container Services: Part I\nContent:\nUsing [Snowpark Container Services within a Snowflake Native App](https://docs.snowflake.com/en/developer-guide/native-apps/container-about) gives developers the flexibility to create apps for just about any use case such as AI/ML workloads, sophisticated web experiences, data processing & analytics tools, etc., all with the safeguards provided by the Snowflake Native Apps Framework. This post will be your guide to the core concepts for developing such apps with containers, and will walk you through the development flow for Snowflake Native Apps and when to use its constructs. Where needed, the post will also draw your attention to differences when compared to developing in a typical container environment.\n ... \nSection Title: Developing Snowflake Native Apps with Snowpark Container Services: Part I > ... > Manifest file\nContent:\nEvery [application package](https://docs.snowflake.com/en/developer-guide/native-apps/creating-app-package) must have a [manifest file](https://docs.snowflake.com/en/developer-guide/native-apps/creating-manifest) . The manifest file contains the configuration and setup properties required by the application such as the location of the setup script, version information, log configuration, etc. It also allows you to specify container images that you wish to use for containers within the app. Please note that you must specify all the images that you wish to use. Here’s how you can [specify the container images](https://docs.snowflake.com/en/developer-guide/native-apps/container-manifest) under the **‘** images **’** list in the **‘** container_services **’** section.\n ... \nSection Title: Developing Snowflake Native Apps with Snowpark Container Services: Part I > ... > Manifest file\nContent:\nNow, if you are using Snowpark Container Services that expose a web UI, you may want that UI to be the landing page of the application. You can do so by specifying a ‘ [default_web_endpoint](https://docs.snowflake.com/en/developer-guide/native-apps/container-manifest) **’** field as follows. The **‘** service **’** refers to the service name you give to the service when executing the CREATE SERVICE command and the ‘endpoint’ field refers to the associated endpoint in the service’s Specification file.\n ... \nSection Title: Developing Snowflake Native Apps with Snowpark Container Services: Part I > ... > Setup script\nContent:\nApplication already has everything it needs to be able to create its services: In this case, the application can simply execute [CREATE SERVICE](https://docs.snowflake.com/en/sql-reference/sql/create-service) commands as part of grant_callback to set up its services. If the service needs a warehouse, you can also request ‘CREATE WAREHOUSE’ privilege in the manifest, and then create warehouses as needed. Application needs additional objects from the consumer before it creates its services: In some cases such as when the application needs to perform egress, it will need objects such as [external access integrations](https://docs.snowflake.com/en/developer-guide/external-network-access/creating-using-external-network-access) or secrets from the consumer.\n ... \nSection Title: Developing Snowflake Native Apps with Snowpark Container Services: Part I > ... > Setup script\nContent:\nThe procedure first checks the operation type for the reference, and if it is an ‘ADD’ operation, it checks if the reference binding should trigger a service creation. If so, it calls other procedures for service creation.\nNow, another point to note is that CREATE SERVICE commands refer to service specification files for service creation. Thus they must be packaged along with the application (typically with the manifest.yml)."]},{"url":"https://www.inovex.de/de/blog/implementing-a-practical-use-case-with-the-snowflake-native-app-framework/","title":"Implementing a Practical Use Case With the Snowflake Native App Framework - inovex GmbH","publish_date":"2024-09-09","excerpts":["Section Title: ... > App Structure & Preliminaries\nContent:\nThe file structure of the project for the lunch planner application is presented below.\nIn this blog post, we will only present the parts of the files that are relevant to the components of the lunch planner app. To see the complete project, you can visit this [repository](https://github.com/inovex/blog-snowflake-native-apps) .\nProject File Structure\n/blog-snowflake-native-apps\n/app\n/scripts/\nsetup_script.sql\n/src\n/libraries/\nexternal_api.py\ninit.py\n/streamlit/\nenvironment.yml\nlunch_planner.py\nmanifest.yml\n/scripts/\nsf_upload.py\n|1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14 |/blog-snowflake-native-apps\n/app\n/scripts/\nsetup_script.sql\n/src\n/libraries/\nexternal_api.py\ninit.py\n/streamlit/\nenvironment.yml\nlunch_planner.py\nmanifest.yml\n/scripts/\nsf_upload.py |\n| --- | --- |\nBefore setting up the application, some preliminary steps are required.\n ... \nSection Title: ... > Accessing Data of the Consumer from the Snowflake Native App\nContent:\nTo achieve this behavior, a [reference](https://docs.snowflake.com/en/sql-reference/references) needs to be defined first in the manifest.yml file.\nThe example below defines a reference named lunch_plan_table that requires SELECT, INSERT, UPDATE, and DELETE privileges on a table in the consumer account. With the register_callback property, we define the stored procedure that will be used to bind a consumer table to the reference to make it accessible for our application. Since we are binding only one consumer object (table), the multi_valued property is set to false (to bind multiple consumer objects to the same reference, the property can be set to true).\nProvider: manifest.yml (Define Reference)\nYAML\n ... \nSection Title: ... > Accessing Data of the Consumer from the Snowflake Native App\nContent:\nThe stored procedure defined in the manifest.yml file needs to be created using the setup_script.sql file, which will be executed during the installation of the application. The stored procedure gets three different arguments and can be used to add, remove, or clear all references in a consumer account. The first and third arguments are used to pass a specific reference name and a reference to a specific object. These are considered during adding or removing references in the consumer account. The second argument decides whether a reference should be added or removed, or whether all references in a consumer account should be cleared. After creating the procedure, it is also necessary to grant usage privileges on the procedure to the application role.\nProvider: setup_script.sql (Create Stored Procedure for managing References)\nPgSQL\n ... \nSection Title: ... > Accessing Data of the Consumer from the Snowflake Native App\nContent:\nNow, on the consumer side, the stored procedure can be used to bind the lunch_plan table created at the beginning of this section to the application.\nTo bind the table, the first argument should be the name of the reference, which we defined in the manifest.yml file. For the third argument, the [SYSTEM$REFERENCE](https://docs.snowflake.com/en/sql-reference/functions/system_reference) system function with information about the lunch_plan table can be used. This function returns a reference to an object (a table, view or function) and if SQL actions are executed on a reference to an object, the actions are performed using the role of the user who created the reference. For the second argument of the stored procedure, we are considering the ADD operator, since we want to add a reference to the consumer account.\nOn the Consumer Account Side: Bind Data to App\nPgSQL"]},{"url":"https://blog.twingdata.com/p/building-a-snowflake-native-app","title":"Building a Snowflake Native App - by Adam Kabak - Twing Data","publish_date":"2025-04-09","excerpts":["Section Title: Building a Snowflake Native App > Lessons from building Twing Pulse > Initial Setup\nContent:\nThe file tree below includes everything you need to get a repo started:\n[](https://substackcdn.com/image/fetch/$s_!kVjA!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F254f0f9d-2163-401e-9b06-326ebe61fe66_913x408.png)\nOn the Snowflake side, it goes without saying you’ll need a Snowflake account and, depending on the type of app you’re building, some data to test with.\nBecause testing within Snowflake with data was such an important part of my development workflow, I set up an integration with GitHub from the outset. Here are the queries you’ll need to set up a Snowflake secret, use it to create an API integration and a Snowflake Git Repository:\n ... \nSection Title: Building a Snowflake Native App > Lessons from building Twing Pulse > Required Components\nContent:\n**setup_script.sql** : A script that creates objects within the application object that are required by the app. It runs when a consumer installs or upgrades the app, or when the provider creates/upgrades the application object for testing the package.\n**manifest.yml** : Contains configuration information and the setup_script.sql path, to be used by the application package to create and manage a Snowflake app.\n**environment.yml (required if using Streamlit)** : Lists dependencies and versions used within the app. The channel must be set to Snowflake, and it’s recommended to specify Streamlit versions here.\n[](https://substackcdn.com/image/fetch/$s_!LylG!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F206b2f77-98b6-4256-9448-6497459c3fd6_512x92.png)\nSection Title: Building a Snowflake Native App > Lessons from building Twing Pulse > Required Components\nContent:\nOptionally, you might also consider a marketplace.yml file to prevent the user from ending up with an unusable app by validating region resources before install/upgrade. It also adds resource requirements to the marketplace listing.\nSection Title: Building a Snowflake Native App > Lessons from building Twing Pulse > Permission Management\nContent:\n“ *As per our enforced requirements, all account-level privileges and references listed in the application package manifest file must be requested from the consumer through Snowsight or the Python Permission SDK. The [account level privileges](https://docs.snowflake.com/en/developer-guide/native-apps/requesting-privs) listed in the manifest should be requested via the [Permissions SDK in a Streamlit](https://docs.snowflake.com/en/developer-guide/native-apps/requesting-ui) . You can do this by following these [steps](https://docs.snowflake.com/en/developer-guide/native-apps/requesting-ui) .* ”\nSnowflake Marketplace Operations Rep (via submission review email)\n ... \nSection Title: Building a Snowflake Native App > Lessons from building Twing Pulse > Backend Development\nContent:\nThe current backend for [Twing Pulse](https://app.snowflake.com/marketplace/listing/GZTSZ1DS0HH/twing-data-twing-pulse) is a set of queries set within the app/code_artifacts/Streamlit/libraries directory. To leverage these queries to return data, we use Snowpark sessions, which can be created/retrieved like this:\n[](https://substackcdn.com/image/fetch/$s_!9l6v!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2d8c634d-d02f-48e0-9986-d2efd079198e_1248x263.png)\nThe session returned from this function is used throughout the app to run queries and return data in pandas dataframes like this:\n[](https://substackcdn.com/image/fetch/$s_!Rsk2!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0d46d322-7a6a-4a5f-9c77-844e404602b4_1172x252.png)"]},{"url":"https://docs.snowflake.com/en/developer-guide/native-apps/manifest-reference","title":"Snowflake Native App manifest file reference | Snowflake Documentation","excerpts":["Section Title: ... > `manifest_version` field [¶]( \"Link to this heading\")\nContent:\nSpecifies the version of the manifest file format.\nThis field is required.\nSection Title: ... > `manifest_version: 1` [¶]( \"Link to this heading\")\nContent:\nThis version of the manifest file supports the current and legacy\nfunctionality of Snowflake Native Apps.\nExample: `manifest_version: 1`\n ... \nSection Title: ... > `name` [¶]( \"Link to this heading\")\nContent:\nSpecifies the name of the version. The version name can\nonly contain alphanumeric characters, underscores (_), hyphens (-), dollar signs ($), periods (.), and spaces.\nThis field is optional.\nExample: `name: v1`\n ... \nSection Title: ... > `container_services:` [¶]( \"Link to this heading\")\nContent:\nSpecifies the location of the container images used by an app with containers. See [Specify the container images used by an app with containers](manifest-overview.html) for more information.\nThis field is required for an app with containers.\nSection Title: ... > `uses_gpu:` [¶]( \"Link to this heading\")\nContent:\nIndicates that the app with containers uses a GPU.\nThis field is required for an app with containers.\nExample: `uses_gpu: true`\nSection Title: ... > `images:` [¶]( \"Link to this heading\")\nContent:\nSpecifies the path to each of the container images used by an app with\ncontainers.\nThis field is required for an app with containers.\nExample:\n```\nimages : \n - /spcs_app/napp/img_repo/eap_frontend \n - /spcs_app/napp/img_repo/eap_backend \n - /spcs_app/napp/img_repo/eap_router\n```\nCopy\n ... \nSection Title: ... > `grant_callback:` [¶]( \"Link to this heading\")\nContent:\nSpecifies the schema and name of the callback function for app an with\ncontainers. The callback function is a stored procedure that can create\ncompute pools, services, and perform other setup tasks required by the\napplication.\nThis field is required for an app with containers.\nFor more information, see [Create a service by using the grant_callback property](container-services.html) .\nExample: `grant_callback: my_schema.my_grant_callback`\n ... \nSection Title: ... > `privileges:` example [¶]( \"Link to this heading\")\nContent:\n```\nprivileges : \n - CREATE TABLE : \n description : 'Required to create tables in the consumer account.' \n - CREATE COMPUTE POOL : \n description : 'Required to allow the app to create a compute pool in the consumer account.' \n - BIND SERVICE ENDPOINT : \n description : 'Required to allow endpoints to be externally accessible.'\n```\nCopy\n ... \nSection Title: ... > `object_type` [¶]( \"Link to this heading\")\nContent:\nSpecifies the type of object associated with the reference, such as a schema and table, or an API integration.\nThis field is required if the `references` field is specified.\nExample: `object_type: TABLE`\nFor more information, see [Object types and privileges that a reference can contain](requesting-refs.html) .\n ... \nSection Title: ... > `configuration_callback` [¶]( \"Link to this heading\")\nContent:\nSpecifies the name of the callback function that provides the desired configuration for the object to bind to this reference.\nThis property is required if `object_type` is `EXTERNAL ACCESS INTEGRATION` or `SECRET` . This property is not applicable to other types of objects.\n ... \nSection Title: ... > `restricted_callers_rights:` field [¶]( \"Link to this heading\")\nContent:\nSpecifies configuration properties related to restricted caller’s\nrights.\nThis field is required if the app creates stored procedures or Snowpark Container Services\nservices that run with restricted caller’s rights.\nFor more information, see [Use owner’s rights and restricted caller’s rights in an app](restricted-callers-rights) .\nSection Title: ... > `enabled:` [¶]( \"Link to this heading\")\nContent:\nSpecifies whether the app is allowed to create executables with restricted caller’s rights.\nProviders must set this property to `true` if the app creates stored procedures or Snowpark Container Services services that run with restricted caller’s rights."]},{"url":"https://docs.snowflake.com/en/developer-guide/native-apps/security-na-spcs","title":"Secure a Snowflake Native App with Snowpark Container Services | Snowflake Documentation","excerpts":["[Overview](/en/developer \"Overview\")\nBuilders\n[Snowflake DevOps](/en/developer-guide/builders/devops \"Snowflake DevOps\")\n[Observability](/en/developer-guide/builders/observability \"Observability\")\nSnowpark Library\n[Snowpark API](/en/developer-guide/snowpark/index \"Snowpark API\")\n[Spark workloads on Snowflake](/en/developer-guide/snowpark-connect/snowpark-connect-overview \"Spark workloads on Snowflake\")\nMachine Learning\n[Snowflake ML](/en/developer-guide/snowflake-ml/overview \"Snowflake ML\")\nSnowpark Code Execution Environments\n[Snowpark Container Services](/en/developer-guide/snowpark-container-services/overview \"Snowpark Container Services\")\n[Functions and procedures](/en/developer-guide/extensibility \"Functions and procedures\")\n[Logging, Tracing, and Metrics](/en/developer-guide/logging-tracing/logging-tracing-overview \"Logging, Tracing, and Metrics\")\nSnowflake APIs\n[Snowflake Python APIs](/en/developer-guide/snowflake-python-api/snowflake-python-overview \"Snowflake Python\n ... \norganization\")\n[Secrets and configuration](/en/developer-guide/streamlit/app-development/secrets-and-configuration \"Secrets and configuration\")\n[Editing your app](/en/developer-guide/streamlit/app-development/editing-your-app \"Editing your app\")\nMigrations and upgrades\n[Identify your app type](/en/developer-guide/streamlit/migrations-and-upgrades/overview \"Identify your app type\")\n[Migrate to a container runtime](/en/developer-guide/streamlit/migrations-and-upgrades/runtime-migration \"Migrate to a container runtime\")\n[Migrate from ROOT_LOCATION](/en/developer-guide/streamlit/migrations-and-upgrades/root-location \"Migrate from ROOT_LOCATION\")\nFeatures\n[Git integration](/en/developer-guide/streamlit/features/git-integration \"Git integration\")\n[External access](/en/developer-guide/streamlit/features/external-access \"External access\")\n[Row access policies](/en/developer-guide/streamlit/features/row-access \"Row access policies\")\n[Sleep\n ... \nSection Title: Secure a Snowflake Native App with Snowpark Container Services [¶]( \"Link to this heading\")\nContent:\n[](../../_images/logo-snowflake-black.png) Feature — Generally Available\nThe Snowflake Native App Framework is generally available on supported cloud platforms. For additional information, see [Support for private connectivity, VPS, and government regions](limitations.html) .\nThis topic describes the security considerations for a Snowflake Native App with Snowpark Container Services. In addition to the general\nsecurity requirements for all apps, apps with containers have specific security implications\nand considerations. The security review process for apps with containers includes a thorough\nexamination of the container images they contain.\nSnowflake uses container image scanning tools to detect known vulnerabilities and\nsecurity best practice violations.\nSection Title: ... > Network isolation and egress control [¶]( \"Link to this heading\")\nContent:\nApps with containers use strict network isolation and egress control measures to help prevent unauthorized\ndata exfiltration and to protect consumer data. Each app with containers runs in its own isolated network\nenvironment, with controlled access to external systems and services.\nSnowflake uses network monitoring and filtering mechanisms to detect and block suspicious egress traffic\npatterns. App providers are required to explicitly declare all external end points in the application\nmanifest, which undergoes a security review.\nConsumer data is protected using the following:\nSecure data access patterns.\nEncryption in transit and at rest.\nFine-grained access controls.\nThe Snowflake Native App Framework ensures that app with containers can only access the specific data and resources to which\nan app has been granted access. This minimizes the risk of data exfiltration."]}],"usage":[{"name":"sku_search","count":1}]}