# FinOps Research Note — Daily Digest (Cost attribution + warehouse spend primitives)

- **When (UTC):** 2026-02-01 14:00
- **Scope:** FinOps / cost optimization
- **Why it matters (native app angle):** These are the “low-level meters” (query + warehouse metering + tags) that a Native App can reliably use to build chargeback/showback, anomaly detection, and automated recommendations without requiring expensive/fragile integrations.

## Accurate takeaways
- `SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY` includes per-query metadata useful for attribution and optimization (e.g., `warehouse_name`, `role_name`, `user_name`, `query_tag`, `bytes_scanned`, timing breakdowns, and `credits_used_cloud_services`). This makes `QUERY_TAG` a first-class hook for app-driven cost allocation and policy enforcement.  
  Source: https://docs.snowflake.com/en/sql-reference/account-usage/query_history
- `SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY` provides *hourly* credit usage per warehouse (including compute vs cloud services) and explicitly supports calculating warehouse idle cost by subtracting `CREDITS_ATTRIBUTED_COMPUTE_QUERIES` from `CREDITS_USED_COMPUTE`. Latency is documented (up to 180 minutes; cloud services up to 6 hours).  
  Source: https://docs.snowflake.com/en/sql-reference/account-usage/warehouse_metering_history
- Snowflake object tags are schema-level objects assigned as key/value pairs; they can be applied to warehouses for cost grouping (e.g., cost center), and tags support inheritance + propagation. Tag references can be queried via `ACCOUNT_USAGE.TAG_REFERENCES` and related INFORMATION_SCHEMA functions, enabling “who/what is tagged (and how)” reporting.  
  Source: https://docs.snowflake.com/en/user-guide/object-tagging/introduction
- Resource monitors are designed to control costs for *warehouses* (alerts + suspend actions), and Snowflake explicitly notes they do not cover serverless/AI services; budgets should be used for those categories.  
  Source: https://docs.snowflake.com/en/user-guide/resource-monitors

## Snowflake objects & data sources (verify in target account)
- `SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY` (ACCOUNT_USAGE)
  - Use for hourly warehouse spend + idle-cost calculations.
  - Caveat: documented latency and a recommendation to set session timezone to UTC when reconciling with ORG_USAGE.
- `SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY` (ACCOUNT_USAGE)
  - Use for per-query attribution (warehouse/user/role/query_tag), performance hints (queue times, spill bytes, scan bytes), and cloud services credits.
- Tags / attribution:
  - Tag definitions + assignments are managed via Snowflake object tagging.
  - Use `ACCOUNT_USAGE.TAG_REFERENCES` (and/or INFORMATION_SCHEMA tag reference functions) to build “warehouse → cost_center/team/env/project” mappings and audit apply method (manual vs inherited vs propagated). (Exact view/function selection depends on desired lineage fidelity.)
- Controls / enforcement:
  - `RESOURCE MONITOR` objects to enforce “spend guardrails” for user-managed warehouses.

## MVP features unlocked (PR-sized)
1) **Warehouse idle-cost card (7d/30d)**: show `idle_credits = SUM(credits_used_compute) - SUM(credits_attributed_compute_queries)` per warehouse, plus trend and “top idle offenders”.
2) **Cost allocation via tags (warehouse-level)**: join warehouse metering to warehouse tags (e.g., `COST_CENTER`, `ENV`, `TEAM`) and produce daily/weekly showback.
3) **Query-tag coverage score**: percentage of queries with `query_tag IS NOT NULL` by warehouse/team; highlight “unknown spend” areas.

## Heuristics / detection logic (v1)
- **Idle cost (warehouse)**
  - `idle_credits = credits_used_compute - credits_attributed_compute_queries` (hourly, then aggregate)
  - Alert tiers: idle_credits share > 30% for last 7 days, or absolute idle_credits > threshold.
- **Attribution completeness**
  - Query-tag coverage: `count_if(query_tag is not null) / count(*)` from `QUERY_HISTORY`.
  - Warehouse-tag coverage: % of warehouses missing required tags (COST_CENTER/TEAM/ENV).
- **Early anomaly detection (simple + cheap)**
  - For each warehouse: compare last 24h credits vs trailing 14d average for same weekday/hour bucket; flag > Nσ or >X%.

## Security/RBAC notes
- ACCOUNT_USAGE access is typically restricted (commonly `ACCOUNTADMIN`/privileged roles). For a Native App, we’ll need a crisp install-time checklist/grants so the app can read:
  - `SNOWFLAKE.ACCOUNT_USAGE` views (or alternate sources if not permitted)
  - tag reference metadata for warehouses
- Resource monitors: only `ACCOUNTADMIN` can create by default; can delegate with grants (doc implies this is grantable).

## Risks / assumptions
- **Latency + freshness:** Account Usage views have non-trivial latency; dashboards must communicate staleness and avoid “real-time” promises.
- **Attribution joins:** mapping metering → tag values requires a stable way to resolve the warehouse object identity (name vs id) and handle renames.
- **Coverage gaps:** resource monitors cover only warehouses; serverless/AI services require budgets/other mechanisms.

## Links / references
- QUERY_HISTORY (ACCOUNT_USAGE): https://docs.snowflake.com/en/sql-reference/account-usage/query_history
- WAREHOUSE_METERING_HISTORY (ACCOUNT_USAGE): https://docs.snowflake.com/en/sql-reference/account-usage/warehouse_metering_history
- Object tagging intro (incl. usage monitoring + TAG_REFERENCES): https://docs.snowflake.com/en/user-guide/object-tagging/introduction
- Resource monitors (warehouse cost controls; serverless note): https://docs.snowflake.com/en/user-guide/resource-monitors
