{
  "search_id": "search_e5da046a9aed466e940a09b0fb153353",
  "results": [
    {
      "url": "https://www.snowflake.com/en/blog/snowflake-native-apps-security/",
      "title": "Snowflake Native Apps: Secure By Design | Blog",
      "publish_date": "2025-06-27",
      "excerpts": [
        "Section Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers\nContent:\nThe [Snowflake Native App Framework](https://www.snowflake.com/en/data-cloud/workloads/applications/native-apps/) , which leverages Snowflake\u2019s advanced architecture, allows for a new level of security for applications. This security spans not just the application consumer, but also the application provider. Controlling all software and infrastructure in the Snowflake Data Cloud, Snowflake can protect the application code, reducing risk for app providers. For consumers, protection comes via extensive capabilities in [role-based access control](https://www.snowflake.com/en/fundamentals/rbac/) (RBAC), which is used to control application access.\nSection Title: ... > Challenges for applications\nContent:\nThe application market has been growing at a fast pace. This creates several challenges that prevent greater application adoption: * Data protection and governance\n ... \nSection Title: ... > Challenges for applications\nContent:\nApplication consumers, on the other hand, really liked this model for their data protection and governance because the solutions operated on the data in its existing location and, in most cases, a third party didn\u2019t need access. For the application providers, not having control over the code/executables not only puts the license at risk, but also puts their business at risk should their software be reverse engineered. Any time an application is packaged and given to a customer to run on their own hardware, reverse engineering those packages becomes much simpler. The code can be debugged and memory can be easily inspected. App builders can build in protection to try to prevent reverse engineering, such as by obfuscating executables, but this is complicated, error prone, and still doesn\u2019t provide complete protection. The emergence of SaaS applications and managed services alleviated some of these challenges, but also introduced new ones.\nSection Title: ... > Challenges for applications\nContent:\nWith the SaaS model, when application builders control all hardware and software, they maintain control over their code at all times. The builder can also push any urgent updates and security patches as needed. The challenge in this shift in the industry is that these applications often require the application consumer to provide access to or a copy of their data to the third-party provider. The builder has, or can have, direct access to this information, which puts more risk on the application consumer. The data that is being stored is outside the consumer\u2019s systems, so the third party has to be evaluated for trust and security risk, and processes have to be carefully checked for compliance.\nSection Title: ... > Compute and data isolation\nContent:\nSnowflake Native Apps (currently in public preview on AWS and private preview on GCP and Azure) are deployed into the application consumer\u2019s Snowflake account. This offers an advantage in that the application is hosted in isolation from other consumers and their data. Multi-tenant applications are often difficult to secure and require a significant amount of engineering and testing to verify data cannot be accessed by unauthorized or malicious users. For example, if a [managed application](https://www.snowflake.com/blog/powered-by-snowflake-building-a-connected-application-for-growth-and-scale/) is vulnerable to a SQL Injection attack, it\u2019s very possible the attacker could gain access to other users\u2019 data. In the case of a Snowflake Native App, the application has only been granted access to the application consumer\u2019s data in the consumer\u2019s own account.\nSection Title: ... > Compute and data isolation\nContent:\nIf an exploit is found, thanks to the way Snowflake Native Apps isolates each tenant\u2019s data, an application user would only gain access to their own data that they provided to the application.\nSection Title: ... > Compute and data isolation\nContent:\nSnowflake Native Apps are deployed into the consumer\u2019s account. In most application models, this would also allow the consumer access to the builder\u2019s binaries and the servers hosting them. Snowflake\u2019s architecture, in which the servers are administered by Snowflake and not by the customer, helps providers protect the application code from prying eyes. Here you can see the objects and code when the application is installed in the provider\u2019s account in debug mode:\nWhen installed in the consumer account, the views and functions were configured to not be accessible. The SHOWME_VIEW and SUPERSECRETSAUCE can still be used by the SHOWME_PROC during execution, but the existence of and the code backing all these objects is protected.\nSection Title: ... > Compute and data isolation\nContent:\nSnowflake can allow the consumer to access parts of the application and data, which are granted to the application without giving application consumers, even ACCOUNTADMIN, access to the code/data/logs. With Snowflake Native Apps, providers that had concerns about protecting their code are no longer limited to SaaS options. A whole new market is opening up for consumers and providers that want more control over their data.\nSection Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers > ... > Package security\nContent:\n[Snowpark for Python](https://www.snowflake.com/en/data-cloud/snowpark/) is commonly used in Snowflake Native Apps to provide features which were not possible using Snowflake\u2019s SQL engine. While Python is extremely powerful, it could be a vector for additional exploits\u2014and our customers spoke loudly that package security and governance was of utmost concern. Any developer on the internet can publish a Python package, or in some cases hijack an existing project. To mitigate these concerns, Snowflake teamed up with [Anaconda](https://anaconda.com) to deliver a vast number of packages to run directly in Snowflake. Because Anaconda maintains its own security practices around curation, patches, scanning and release security, customers can optionally rely on Anaconda to provide up-to-date packages.\nSection Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers > ... > Package security\nContent:\nWhen building Snowflake Native Apps, you can use any package in the [Snowflake conda channel](https://repo.anaconda.com/pkgs/snowflake/) . The packages in the conda channel are vetted and patched by Anaconda. Snowflake Native App publishing and upgrades are gated on a security scan, which checks for known security vulnerabilities in the application. Approval is only granted after the app passes the scan. Snowflake also scans packages and code included in Snowflake Native Apps for security concerns prior to making them available in [Snowflake Marketplace](https://app.snowflake.com/marketplace/) .\nSection Title: ... > Upgrading applications\nContent:\nApplication consumers have always expected that the SaaS applications they purchase would be upgraded and kept secure by the application provider. Snowflake offers application providers a way to push updates to customers in an automated rollout, improving both user experience and security. Even though Snowflake Native Apps are installed and run in the application consumer\u2019s account, the application provider still has control over the release cycle. To release a new version of the application, the builder can create a new [release directive](https://docs.snowflake.com/en/developer-guide/native-apps/versioning) to push that update to a select set of users or to all users. This capability gives the provider confidence in knowing that all applications are patched (or upgraded) even though the application is deployed in many accounts.\nSection Title: ... > Data control and sovereignty\nContent:\nApplication consumers install a Snowflake Native App from a provider in their own account. Access to any data that application needs must be granted to the application by the consumer administrator, so it is well known what the application can access and use. In Snowflake Native Apps, the data doesn\u2019t need to be moved or sent to a third party, which makes it much easier to be compliant with security requirements and data sovereignty rules.\nSection Title: ... > Application permissions\nContent:\nWhen a provider publishes an application, it includes a [manifest](https://docs.snowflake.com/en/developer-guide/native-apps/creating-manifest) file. This manifest contains the permissions to be granted to the application, which can be reviewed by the application consumer during installation. By default, a Snowflake Native App has no permissions outside of the application itself, including data access or the ability to create database objects (tables, tasks, warehouses, etc). Additional rights can be granted to the application, but that must be done by the application consumer administrators through explicit grants or [references](https://docs.snowflake.com/en/developer-guide/native-apps/requesting-refs) . Application code runs as a new application role, with owner\u2019s rights, such that it can only access what that role has been granted to do.\nSection Title: ... > Application permissions\nContent:\nThis means that the application can\u2019t access data that the caller has access to\u2014it must be explicitly granted permission.\n ... \nSection Title: ... > A secure framework for applications\nContent:\nSnowflake Native Apps were developed to fulfill needs that were previously unmet in the industry, and Snowflake is uniquely positioned to provide applications from providers to consumers while protecting each party. Snowflake Native Apps leverage some of the biggest strengths in managed applications, provider-managed code and upgrades, and protecting the provider's code, along with the biggest strengths of traditional applications, which keep control and sovereignty of data in the consumers' hands. Check out the [Snowflake Native App Framework](https://www.snowflake.com/en/data-cloud/workloads/applications/native-apps/) or use our [Quickstart tutorial](https://quickstarts.snowflake.com/guide/getting_started_with_native_apps) to develop a Snowflake Native app for yourself. We look forward to seeing what you build!\n ... \nSection Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers > Where Data Does More\nContent:\n30-day free trial\nNo credit card required\nCancel anytime\n[start for free](https://signup.snowflake.com/)\nwatch a demo\n**Subscribe to our monthly newsletter** Stay up to date on Snowflake\u2019s latest products, expert insights and resources\u2014right in your inbox!\nIndustries * [Advertising, Media & Entertainment](https://www.snowflake.com/en/solutions/industries/advertising-media-entertainment/)\nSection Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers > Where Data Does More\nContent:\n[Financial Services](https://www.snowflake.com/en/solutions/industries/financial-services/)\n[Healthcare & Life Sciences](https://www.snowflake.com/en/solutions/industries/healthcare-and-life-sciences/)\n[Manufacturing](https://www.snowflake.com/en/solutions/industries/manufacturing/)\n[Public Sector](https://www.snowflake.com/en/solutions/industries/public-sector/)\n[Retail & Consumer Goods](https://www.snowflake.com/en/solutions/industries/retail-consumer-goods/)\n[Technology](https://www.snowflake.com/en/solutions/industries/technology/)\nLearn * [Resource Library](https://snowflake.com/en/resources/)\n ... \nSection Title: How Snowflake Native Apps Deliver Security for App Builders and Consumers > Where Data Does More\nContent:\n[](https://www.facebook.com/snowflakedb/ \"Facebook\")\n[](https://www.youtube.com/user/snowflakecomputing \"YouTube\")"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/developer-guide/native-apps/security-overview",
      "title": "Security requirements and guidelines for a Snowflake Native App | Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n\n/\n\nGet started\n\nGuides\n\nDeveloper\n\nReference\n\nRelease notes\n\nTutorials\n\n[Status](https://status.snowflake.com)\n\nDeveloper Snowflake Native App Framework Security requirements and guidelines\n\n# Security requirements and guidelines for a Snowflake Native App \u00b6\n\n Feature \u2014 Generally Available\n\nThe Snowflake Native App Framework is generally available on supported cloud platforms. For additional information, see Support for private connectivity, VPS, and government regions .\n\nThis topic provides an overview of the security requirements and guidelines\nwhen developing a Snowflake Native App. It also provides general information about automated\nsecurity scan and review process when publishing an app to consumers.\n\nCaution\n\nIt is your responsibility to ensure that no personal data, sensitive data,\nexport-controlled data, or other regulated data is entered into any files included\nin your application package.\n\n## Overview of Snowflake Native App security requirements \u00b6\n\nThe Snowflake Native App Framework provides security requirements and best practices that providers must follow when\ndeveloping a Snowflake Native App. For security requirements and best practices for an app, see Security requirements and best practices for a Snowflake Native App . For security requirements for an app with containers, see Secure a Snowflake Native App with Snowpark Container Services .\n\nTo publish an app to consumers, either as a private listing or on Snowflake Marketplace,\nSnowflake implements a security review process that requires a security scan of the components\nof an app. If an app does not pass the automated security review, a manual review occurs.\n\nAll apps that are published to consumers must pass this security review.\n\n## Potential security risks \u00b6\n\nThe following are some of the possible security risks that can occur when running an app:\n\n* Data exfiltration:\n  \n  Malicious apps could copy consumer data to external functions or logs.\n* Compute abuse:\n  \n  Apps could perform unauthorized tasks, such as cryptomining, at the consumer\u2019s expense.\n* Ransomware\n  \n  Apps could encrypt or corrupt consumer data, demanding payment for restoration.\n* Privilege escalation:\n  \n  Apps could attempt to gain unauthorized permissions within the consumer\u2019s account.\n\nTo mitigate these and other possible security risks, the Snowflake Native App Framework uses a security review to evaluate\nan app for security risks and to ensure security best practices.\n\n## Automated security reviews \u00b6\n\nTo mitigate potential security risks, Snowflake uses the Native App Anti-Abuse Pipeline Service (NAAAPS).\nThis service automatically scans all new app versions using various tools to determine if an app can\nbe distributed to consumers.\n\nThis automated security review occurs when a new version or patch of an app is created. This review\nperforms the following:\n\n* Copies the app to a dedicated Snowflake account used to scan apps.\n* Scans the files associated with the app and updates the security review status.\n* Auto-approves the app or initiates a manual review of the app.\n\nDuring the manual review process, an app can be approved or rejected. Snowflake does not send a notification if an\napp is rejected. Providers can view the status of the review in\nSnowsight.\n\n## Scanners and tools used during a security review \u00b6\n\nThe automated security review uses the following scanners and tools to perform the\nfollowing to analyze different components of an app:\n\n* Scan code for bugs, anti-patterns, and security vulnerabilities in code.\n* Scan code for malware.\n* Identify vulnerabilities in app dependencies.\n\nThe processes help detect various security issues, such as data exfiltration, ransomware, compute\nabuse, privilege escalation, and dynamic code execution.\n\n## Security requirements and best practices for an app \u00b6\n\nAll apps must conform to the security requirements outlined in the Security requirements and best practices for a Snowflake Native App .\n\nNote\n\nSecurity requirements are subject to change as Snowflake continues to monitor new potential risks.\n\n## Security considerations for a Snowflake Native App with Snowpark Container Services \u00b6\n\nFor information about additional security requirements for a Snowflake Native App with Snowpark Container Services see Secure a Snowflake Native App with Snowpark Container Services .\n\n## Guidelines for publishing an app to Snowflake Marketplace \u00b6\n\nWhen publishing an app to Snowflake Marketplace, providers must consider additional requirements\nand best practices. See Guidelines and requirements for listing Apps on Snowflake Marketplace .\n\n## CVE evaluation criteria for an app \u00b6\n\nSnowflake\u2019s approach to addressing Common Vulnerabilities and Exposures (CVEs) in a Snowflake Native App\nis based on our CVE Evaluation Criteria, a policy that establishes clear and objective criteria\nfor evaluating and prioritizing CVEs based on their risk profile.\n\nThe policy aims to balance the mitigation of critical security risks with the effort required to\naddress less severe vulnerabilities. It applies to all apps undergoing security review\nand is enforced to ensure only apps meeting the defined criteria are approved for publishing\nin Snowflake\u2019s data cloud environment.\n\nSee Common Vulnerabilities and Exposures (CVE) considerations for additional information.\n\n## Scanning Regions \u00b6\n\nWhen configuring a Snowflake Native App to be shared externally, providers automatically share the code in app\nwith Snowflake for scanning. The following table maps the NAAAPS scanning regions to the corresponding\nprovider regions:\n\n|Cloud provider |Provider region |Scanning region |\n| --- | --- | --- |\n|AWS |US West (Oregon) |US West (Oregon) |\n|AWS |US East (Ohio) |US East (Ohio) |\n|AWS |US East (N. Virginia) |US East (N. Virginia) |\n|AWS |Canada (Central) |Canada (Central) |\n|AWS |South America (S\u00e3o Paulo) |South America (S\u00e3o Paulo) |\n|AWS |EU (Ireland) |EU (Ireland) |\n|AWS |Europe (London) |Europe (London) |\n|AWS |EU (Paris) |EU (Paris) |\n|AWS |EU (Frankfurt) |EU (Frankfurt) |\n|AWS |EU (Zurich) |EU (Zurich) |\n|AWS |EU (Stockholm) |EU (Stockholm) |\n|AWS |Asia Pacific (Tokyo) |Asia Pacific (Tokyo) |\n|AWS |Asia Pacific (Osaka) |Asia Pacific (Osaka) |\n|AWS |Asia Pacific (Seoul) |Asia Pacific (Seoul) |\n|AWS |Asia Pacific (Mumbai) |Asia Pacific (Mumbai) |\n|AWS |Asia Pacific (Singapore) |Asia Pacific (Singapore) |\n|AWS |Asia Pacific (Sydney) |Asia Pacific (Sydney) |\n|AWS |Asia Pacific (Jakarta) |Asia Pacific (Jakarta) |\n|Azure |* West US 2 (Washington)\n* Central US (Iowa)\n* South Central US (Texas)\n* East US 2 (Virginia)\n* Canada Central (Toronto) |Azure East US 2 (Virginia) |\n|Azure |* UK South (London)\n* North Europe (Ireland)\n* West Europe (Netherlands)\n* Switzerland North (Zurich)\n* UAE North (Dubai) |Azure West Europe (Netherlands) |\n|Azure |* Central India (Pune)\n* Japan East (Tokyo)\n* Southeast Asia (Singapore)\n* Australia East (New South Wales) |Azure Australia East (New South Wales) |\n|GCP |* US Central1 (Iowa)\n* US East4 (N. Virginia)\n* Europe West2 (London)\n* Europe West4 (Netherlands) |AWS US West (Oregon) |\n\nWas this page helpful?\n\nYes No\n\n[Visit Snowflake](https://www.snowflake.com)\n\n[Join the conversation](https://community.snowflake.com/s/)\n\n[Develop with Snowflake](https://developers.snowflake.com)\n\nShare your feedback\n\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n\n[Get your own certification](https://learn.snowflake.com)\n\nLanguage: **English**\n\n* English\n* Fran\u00e7ais\n* Deutsch\n* \u65e5\u672c\u8a9e\n* \ud55c\uad6d\uc5b4\n* Portugu\u00eas"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/developer-guide/native-apps/security-app-requirements",
      "title": "Security requirements and best practices for a Snowflake Native App | Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n\n/\n\nGet started\n\nGuides\n\nDeveloper\n\nReference\n\nRelease notes\n\nTutorials\n\n[Status](https://status.snowflake.com)\n\nDeveloper Snowflake Native App Framework Security requirements and guidelines Security requirements for an app\n\n# Security requirements and best practices for a Snowflake Native App \u00b6\n\n Feature \u2014 Generally Available\n\nThe Snowflake Native App Framework is generally available on supported cloud platforms. For additional information, see Support for private connectivity, VPS, and government regions .\n\nThis topic describes the security requirements and best practices that providers must\nfollow when developing a Snowflake Native App. All apps that meet the conditions described in Automated security reviews must conform to the security requirements\noutlined in the following sections:\n\n* Security requirements for application code\n* Security requirements for app functionality\n* Security requirements for app permissions\n\nNote\n\nSecurity requirements are subject to change as Snowflake continues to monitor new potential risks.\n\n## Security requirements for application code \u00b6\n\nApp code included within an application package must conform to the following security requirements:\n\n1. Your app must not load or execute any code from outside the application package except\n   Snowflake-provided libraries. All the app code, including all library dependencies and setup code,\n   must be included in the app version defined in the application package.\n2. All app code must be un-obfuscated, meaning that the code must be human readable. This requirement\n   includes minified JavaScript code.\n   \n   Note\n   \n   If an app needs to use minified JavaScript code, it must include a corresponding source map file\n   that can be used to recover the un-minified code.\n3. All dependencies or libraries with critical or high common vulnerabilities and exposures (CVE) must be\n   updated to a secure version, if available.\n\n## Security requirements for app functionality \u00b6\n\nThe following security requirements apply to the functionality of your app:\n\n1. All apps must provide the following information to customers as part of a listing:\n   \n    1. All app functionality and features.\n    2. All Internet endpoints and URLs that the app connects to.\n    3. All external functions in the app.\n    4. Any consumer data logged, collected, or stored by the app.\n          \n        1. Apps should prohibit all non-essential cookies.\n        2. Apps should communicate all essential cookies to consumers\n2. Apps should function as advertised in the app listing.\n3. All app installation and setup instructions must be included in the app listing.\n4. Apps must not store or require any plain text customer secrets.\n5. Any communication between the app and the Internet should be over an HTTPS connection with a valid\n   TLS certificate.\n6. Apps must not have any functionality that could result in harm to Snowflake, its customers, or third\n   parties. Harm includes but is not limited to:\n   \n    1. Data leakage and/or loss;\n    2. Restricting consumer access to their data unless explicitly designed as part of the app\n          functionality, for example, data masking for data access policies.\n    3. Excessive resource consumption.\n    4. Arbitrary code injection/execution.\n7. All connections to an app, including web-based user interfaces and APIs, must first authenticate using a\n   Snowflake-provided method of authentication. Any app-specific authentication must be presented to users\n   after Snowflake authentication has succeeded.\n8. Apps should not create any public endpoints that allow connections to the app without a successful\n   authentication through Snowflake first.\n\n## Security requirements for app permissions \u00b6\n\nThe following security requirements apply to the privileges set by your app:\n\n1. All apps must provide the following information in the manifest file:\n   \n    1. All privileges required by the app on all objects.\n    2. All API integrations.\n2. Apps should only ask for the minimum set of privileges needed for the app to function.\n\n## Recommended security best practices \u00b6\n\nIn addition to the security requirements imposed by the automated security scan, Snowflake recommends the\nfollowing best practices when developing a Snowflake Native App. Following these best practices helps reduce\nthe likelihood of an app being blocked during security review.\n\n* Follow secure Software Development Life Cycle (SDLC) practices.\n  \n    + Review app code for vulnerabilities during the development lifecycle and fix them before creating\n        an app version.\n    + Review third-party libraries for vulnerabilities and update them to the latest secure version.\n    + Review and update all third-party libraries in the app at least once a quarter.\n* Follow Snowflake security best practices as described in the following:\n  \n    + Security Practices for UDFs and Procedures\n    + Securing an external function\n\n## Recommended security best practices for an app with containers \u00b6\n\nIn addition to the security best practices for a core Snowflake Native App outlined in Recommended security best practices , the following\nsecurity best practices apply to an app with containers:\n\n* Limit the use of external dependencies and libraries to minimize the attack surface of an app and\n  reduce the risk of supply chain vulnerabilities.\n* Follow container image hardening requirements, such as the use of minimal base images, removal of\n  unnecessary packages, and secure configuration of runtime environments.\n* Use secure communication protocols and encryption for all inter-container and external communication.\n* Generate comprehensive logging and auditing of container activities and data access patterns.\n* Update and patch container images regularly to address known vulnerabilities and security issues.\n* Implement only required privileges to minimizing the attack surface of containerized apps.\n* Managing secrets and sensitive data securely, using appropriate encryption and access controls.\n* Conduct thorough security testing and vulnerability assessments before submitting apps for review.\n* Respond promptly to security incidents and collaborate with Snowflake during incident response.\n* Provide clear and accurate documentation of app functionality, dependencies, and security controls.\n* Educate and guide consumers on the secure use and configuration of their apps.\n\n## Best practices for developing and publishing an application package \u00b6\n\nTo streamline the development and publishing process for a Snowflake Native App, Snowflake recommends creating\ntwo separate application packages:\n\n* Development application package\n  \n  The development application package is intended for rapid iteration and testing purposes. It should\n  have its DISTRIBUTION property set to `INTERNAL` . This ensures that the application package remains\n  internal and is not distributed to external consumers or to Snowflake scanning and approval.\n  \n  By keeping this package separate from the production package, developers can quickly make changes and\n  test new features without triggering the security review process for each iteration.\n* Production application package\n  \n  The production application package is intended for publishing an application package and distributing it\n  to Snowflake for scanning and approval and to external consumers. The production application package should have\n  its DISTRIBUTION property set to `EXTERNAL` .\n  \n  Only versions that have passed the provider\u2019s security review should be added to this package, ensuring\n  that the app meets the required security standards before being made available to consumers.\n\nBy following the best practice of having separate development and production packages, developers can maintain an efficient\ndevelopment lifecycle while ensuring that only secure and approved versions of the app are published and\ndistributed to external consumers.\n\nWas this page helpful?\n\nYes No\n\n[Visit Snowflake](https://www.snowflake.com)\n\n[Join the conversation](https://community.snowflake.com/s/)\n\n[Develop with Snowflake](https://developers.snowflake.com)\n\nShare your feedback\n\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n\n[Get your own certification](https://learn.snowflake.com)\n\nOn this page\n\n1. Security requirements for application code\n2. Security requirements for app functionality\n3. Security requirements for app permissions\n4. Recommended security best practices\n5. Recommended security best practices for an app with containers\n6. Best practices for developing and publishing an application package\n\nRelated content\n\n1. Security requirements and guidelines for a Snowflake Native App\n2. Run the automated security scan\n\nLanguage: **English**\n\n* English\n* Fran\u00e7ais\n* Deutsch\n* \u65e5\u672c\u8a9e\n* \ud55c\uad6d\uc5b4\n* Portugu\u00eas"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/user-guide/views-secure",
      "title": "Working with Secure Views | Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSnowflake Horizon Catalog\nApplications and tools for connecting to Snowflake\nVirtual warehouses\nDatabases, Tables, & Views\nData types\nData Integration\nSnowflake Openflow\nApache Iceberg\u2122\nApache Iceberg\u2122 Tables\nSnowflake Open Catalog\nData engineering\nData loading\nDynamic Tables\nStreams and Tasks\ndbt Projects on Snowflake\nData Unloading\nStorage Lifecycle Policies\nMigrations\nQueries\nListings\nCollaboration\nSnowflake AI & ML\nAlerts & Notifications\nSecurity\nData Governance\nPrivacy\nOrganizations & Accounts\nBusiness continuity & data recovery\nPerformance optimization\nCost & Billing\nGuides Databases, Tables, & Views Secure Views\nSection Title: Working with Secure Views \u00b6\nContent:\nThis topic covers concepts and syntax for defining views and materialized views as secure.\nSection Title: Working with Secure Views \u00b6 > Overview of Secure Views \u00b6 > Why Should I Use Secure Views? \u00b6\nContent:\nFor a non-secure view, internal optimizations can indirectly expose data.Some of the internal optimizations for views require access to the underlying data in the base tables for the view. This access\nmight allow data that is hidden from users of the view to be exposed through user code, such as user-defined functions, or other\nprogrammatic methods. Secure views do not utilize these optimizations, ensuring that users have no access to the underlying data. For a non-secure view, the view definition is visible to other users.By default, the query expression used to create a standard view, also known as the view definition or text, is visible to users\nin various commands and interfaces. For details, see Interacting with Secure Views (in this topic).For security or privacy reasons, you might not wish to expose the underlying tables or internal structural details for a view.\nSection Title: Working with Secure Views \u00b6 > Overview of Secure Views \u00b6 > Why Should I Use Secure Views? \u00b6\nContent:\nWith secure views, the view definition and details are visible only to authorized users (i.e. users who are granted the role that\nowns the view).\nSection Title: Working with Secure Views \u00b6 > Overview of Secure Views \u00b6 > When Should I Use a Secure View? \u00b6\nContent:\nViews should be defined as secure when they are specifically designated for data privacy (i.e. to limit access to sensitive data that\nshould not be exposed to all users of the underlying table(s)).\nSecure views should not be used for views that are defined solely for query convenience, such as views created to\nsimplify queries for which users do not need to understand the underlying data representation. Secure views can execute\nmore slowly than non-secure views.\nTip\nWhen deciding whether to use a secure view, you should consider the purpose of the view and weigh the trade-off between data\nprivacy/security and query performance.\nSection Title: Working with Secure Views \u00b6 > ... > How Might Data be Exposed by a Non-secure View? \u00b6\nContent:\nUsing the following widgets example, consider a user who has access to only the red widgets. Suppose the user wonders if any purple\nwidgets exist and issues the following query:\n```\nSELECT * \n    FROM widgets_view \n    WHERE 1 / iff ( color = 'Purple' , 0 , 1 ) = 1 ;\n```\nCopy\nIf any purple widgets exist, then the IFF() expression returns 0. The division operation then fails due to a division-by-zero error,\nwhich allows the user to infer that at least one purple widget exists.\nSection Title: Working with Secure Views \u00b6 > Creating Secure Views \u00b6\nContent:\nSecure views are defined using the SECURE keyword with the standard DDL for views:\nTo create a secure view, specify the SECURE keyword in the CREATE VIEW or CREATE MATERIALIZED VIEW command.\nTo convert an existing view to a secure view and back to a regular view, set/unset the SECURE keyword in the ALTER VIEW or ALTER MATERIALIZED VIEW command.\nNote\nIn some cases, error messages related to secure views might be redacted. For more information, see Secure objects: Redaction of information in error messages .\nSection Title: Working with Secure Views \u00b6 > ... > Viewing the Definition for Secure Views \u00b6\nContent:\nThe definition of a secure view is only exposed to authorized users (i.e. users who have been granted the role that owns the view). If an\nunauthorized user uses any of the following commands or interfaces, the view definition is not displayed:\nSHOW VIEWS and SHOW MATERIALIZED VIEWS commands.\nGET_DDL utility function.\nVIEWS Information Schema view.\nHowever, users that have been granted IMPORTED PRIVILEGES privilege on the SNOWFLAKE database or another shared database have access to secure view definitions via the VIEWS Account Usage view.\nUsers granted the ACCOUNTADMIN role or the SNOWFLAKE.OBJECT_VIEWER database role can also see secure view definitions via this view. The preferred, least-privileged means of access is the SNOWFLAKE.OBJECT_VIEWER database role.\n ... \nSection Title: Working with Secure Views \u00b6 > ... > Viewing Secure View Details in Query Profile \u00b6\nContent:\nThe internals of a secure view are not exposed in Query Profile (in the web interface). This is the\ncase even for the owner of the secure view, because non-owners might have access to an owner\u2019s Query Profile.\nSection Title: Working with Secure Views \u00b6 > Using Secure Views with Snowflake Access Control \u00b6\nContent:\nView security can be integrated with Snowflake users and roles using the CURRENT_ROLE and CURRENT_USER context functions. The following example illustrates using roles to control access to the rows of\na table. In addition to the table that contains the data ( `widgets` ), the example uses an access table ( `widget_access_rules` ) to\ntrack which roles have access to which rows in the data table:\nSection Title: Working with Secure Views \u00b6 > Using Secure Views with Snowflake Access Control \u00b6\nContent:\n```\nCREATE TABLE widgets ( \n    id NUMBER ( 38 , 0 ) DEFAULT widget_id_sequence . nextval , \n    name VARCHAR , \n    color VARCHAR , \n    price NUMBER ( 38 , 0 ), \n    created_on TIMESTAMP_LTZ ( 9 )); \n CREATE TABLE widget_access_rules ( \n    widget_id NUMBER ( 38 , 0 ), \n    role_name VARCHAR ); \n CREATE OR REPLACE SECURE VIEW widgets_view AS \n    SELECT w .* \n        FROM widgets AS w \n        WHERE w . id IN ( SELECT widget_id \n                           FROM widget_access_rules AS a \n                           WHERE upper ( role_name ) = CURRENT_ROLE () \n                      ) \n    ;\n```\nCopy\nThe WHERE clause limits which widgets each role can see.\nSuppose that a user who has access only to red widgets executes the query shown earlier:\n```\nSELECT * \n    FROM widgets_view \n    WHERE 1 / iff ( color = 'Purple' , 0 , 1 ) = 1 ;\n```\nCopy\nSection Title: Working with Secure Views \u00b6 > Using Secure Views with Snowflake Access Control \u00b6\nContent:\nThe secure view\u2019s WHERE clause is executed before any WHERE clause in the user\u2019s query. Because purple widgets are excluded\nby the view, the user\u2019s query never generates a division-by-zero error.\nIf the view were not secure, then the Snowflake optimizer could re-order the predicates in the WHERE clauses. This could allow\nthe predicate in the user\u2019s query to execute first, which would allow the division-by-zero error to occur.\nSection Title: Working with Secure Views \u00b6 > Best Practices for Using Secure Views \u00b6\nContent:\nSecure views prevent users from possibly being exposed to data from rows of tables that are filtered by the view. However, there are still\nways that a data owner might inadvertently expose information about the underlying data if views are not constructed carefully. This section\ndiscusses some potential pitfalls to avoid.\nTo illustrate these pitfalls, this section uses the sample `widgets` tables and view defined in the earlier examples in this topic.\nSection Title: Working with Secure Views \u00b6 > Best Practices for Using Secure Views \u00b6 > Sequence-generated Columns \u00b6\nContent:\nA common practice for generating surrogate keys is to use a sequence or auto-increment column. If these keys are exposed to users who do not\nhave access to all of the underlying data, then a user might be able to guess details of the underlying data distribution. For example, `widgets_view` exposes the ID column. If ID is generated from a sequence, then a user of `widgets_view` could deduce the total\nnumber of widgets created between the creation timestamps of two widgets that the user has access to. Consider the following query and result:\nCopy\nBased on the result, the user might suspect that 1139 widgets (1455 - 315) were created between January 7 and January 15. If this\ninformation is too sensitive to expose to users of a view, you can use any of the following alternatives:\nSection Title: Working with Secure Views \u00b6 > Best Practices for Using Secure Views \u00b6 > Sequence-generated Columns \u00b6\nContent:\nDo not expose the sequence-generated column as part of the view.\nUse randomized identifiers (e.g. generated by UUID_STRING ) instead of sequence-generated values.\nProgrammatically obfuscate the identifiers.\nSection Title: Working with Secure Views \u00b6 > Best Practices for Using Secure Views \u00b6 > Scanned Data Size \u00b6\nContent:\nFor queries containing secure views, Snowflake does not expose the amount of data scanned (either in terms of bytes or micro-partitions)\nor the total amount of data. This is to protect the information from users who only have access to a subset of the data. However, users\nmight still be able to make observations about the quantity of underlying data based on performance characteristics of queries. For example,\na query that runs twice as long might process twice as much data. While any such observations are approximate at best, in some cases it\nmight be undesirable for even this level of information to be exposed.\nSection Title: Working with Secure Views \u00b6 > Best Practices for Using Secure Views \u00b6 > Scanned Data Size \u00b6\nContent:\nIn such cases, it is best to materialize data per user/role instead of exposing views on the base data to users. In the case of the `widgets` table, a table would be created for each role that has access to widgets, which contains only the widgets accessible by\nthat role, and a role would be granted access to its table. This is much more cumbersome than using a single view, but for extremely\nhigh-security situations, this might be warranted.\nSection Title: Working with Secure Views \u00b6 > ... > Secure Views and Data Sharing \u00b6\nContent:\nWhen using secure views with Secure Data Sharing , use the CURRENT_ACCOUNT function to authorize users from a specific account to access rows in a base table.\nNoteWhen using the CURRENT_ROLE and CURRENT_USER functions with secure\nviews that will be shared to other Snowflake accounts, Snowflake returns a NULL value for these functions. The reason is that the owner\nof the data being shared does not typically control the users or roles in the account with which the view is being shared.\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nSection Title: Working with Secure Views \u00b6 > ... > Secure Views and Data Sharing \u00b6\nContent:\nOverview of Secure Views\nCreating Secure Views\nInteracting with Secure Views\nUsing Secure Views with Snowflake Access Control\nBest Practices for Using Secure Views\nRelated content\nOverview of Views\nTable, view, & sequence DDL\nWorking with views in Snowsight\nAbout Secure Data Sharing\nShare data from multiple databases\nLanguage: **English**\nEnglish\nFran\u00e7ais\nDeutsch\n\u65e5\u672c\u8a9e\n\ud55c\uad6d\uc5b4\nPortugu\u00eas"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/user-guide/security-column-ddm-use",
      "title": "Using Dynamic Data Masking | Snowflake Documentation",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nSnowflake Horizon Catalog\nApplications and tools for connecting to Snowflake\nVirtual warehouses\nDatabases, Tables, & Views\nData types\nData Integration\nSnowflake Openflow\nApache Iceberg\u2122\nApache Iceberg\u2122 Tables\nSnowflake Open Catalog\nData engineering\nData loading\nDynamic Tables\nStreams and Tasks\ndbt Projects on Snowflake\nData Unloading\nStorage Lifecycle Policies\nMigrations\nQueries\nListings\nCollaboration\nSnowflake AI & ML\nAlerts & Notifications\nSecurity\nData Governance\nPrivacy\nOrganizations & Accounts\nBusiness continuity & data recovery\nPerformance optimization\nCost & Billing\nGuides Data Governance Data access policies Masking Policies Dynamic Data Masking Using Dynamic Data Masking\nSection Title: Using Dynamic Data Masking \u00b6\nContent:\nEnterprise Edition Feature\nThis feature requires Enterprise Edition (or higher). To inquire about upgrading, please contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nThis topic provides instructions on how to configure and use Dynamic Data Masking in Snowflake.\nTo learn more about using a masking policy with a tag, see Tag-based masking policies .\nSection Title: Using Dynamic Data Masking \u00b6 > Using Dynamic Data Masking \u00b6\nContent:\nThe following lists the high-level steps to configure and use Dynamic Data Masking in Snowflake:\nGrant masking policy management privileges to a custom role for a security or privacy officer.\nGrant the custom role to the appropriate users.\nThe security or privacy officer creates and defines masking policies and applies them to columns with sensitive data.\nExecute queries in Snowflake. Note the following:\nSnowflake dynamically rewrites the query applying the masking policy SQL expression to the column.\nThe column rewrite occurs at every place where the column specified in the masking policy appears in the query (e.g. projections, join predicate, where clause predicate, order by, and group by).\nUsers see masked data based on the execution context conditions defined in the masking policies. For more information on the execution context in Dynamic Data Masking policies, see Advanced Column-level Security topics .\nSection Title: Using Dynamic Data Masking \u00b6 > ... > Step 1: Grant masking policy privileges to custom role \u00b6\nContent:\nA security or privacy officer should serve as the masking policy administrator (i.e. custom role: `MASKING_ADMIN` ) and have the privileges to define, manage, and apply masking policies to columns.\nSnowflake provides the following privileges to grant to a security or privacy officer for Column-level Security masking policies:\nSection Title: Using Dynamic Data Masking \u00b6 > ... > Step 1: Grant masking policy privileges to custom role \u00b6\nContent:\n| Privilege | Description |\n| CREATE MASKING POLICY | This schema-level privilege controls who can create masking policies. |\n| APPLY ON MASKING POLICY | Optional. This policy-level privilege can be used by a policy owner to decentralize the [un]set operations of a given masking policy on columns to the object owners (i.e. the role that has the OWNERSHIP privilege on the object). . Snowflake supports discretionary access control where object owners are also considered data stewards. . If the policy administrator trusts the object owners to be data stewards for protected columns, then the policy administrator can use this privilege to decentralize applying the policy [un]set operations. |\nSection Title: Using Dynamic Data Masking \u00b6 > ... > Step 1: Grant masking policy privileges to custom role \u00b6\nContent:\nThe following example creates the `MASKING_ADMIN` role and grants masking policy privileges to that role.\nCreate a masking policy administrator custom role:\nCopy\nGrant privileges to `masking_admin` role:\nCopy\nAllow `table_owner` role to set or unset the `ssn_mask` masking policy (optional):\nCopy\nWhere:\n`_db_name.schema_name_`\nSpecifies the identifier for the schema for which the privilege should be granted.\nFor more information, see:\nGRANT  \u2026 TO ROLE\nConfiguring access control\nAccess control privileges\nSection Title: Using Dynamic Data Masking \u00b6 > ... > Step 2: Grant the custom role to a user \u00b6\nContent:\nGrant the `MASKING_ADMIN` custom role to a user serving as the security or privacy officer.\n```\nGRANT ROLE masking_admin TO USER jsmith ;\n```\nCopy\nSection Title: Using Dynamic Data Masking \u00b6 > Using Dynamic Data Masking \u00b6 > Step 3: Create a masking policy \u00b6\nContent:\nUsing the MASKING_ADMIN role, create a masking policy and apply it to a column.\nIn this representative example, users with the ANALYST role see the unmasked value. Users without the ANALYST role see a full mask.\n```\nCREATE OR REPLACE MASKING POLICY email_mask AS ( val string ) RETURNS string -> \n  CASE \n    WHEN CURRENT_ROLE () IN ( 'ANALYST' ) THEN val \n    ELSE '*********' \n  END ;\n```\nCopy\nTip\nIf you want to update an existing masking policy and need to see the current definition of the policy, call the GET_DDL function or run the DESCRIBE MASKING POLICY command.\nSection Title: Using Dynamic Data Masking \u00b6 > ... > Step 4: Apply the masking policy to a table or view column \u00b6\nContent:\nThese examples assume that a masking policy is not applied to the table column when the table is created and the view column when the view\nis created. You can optionally apply a masking policy to a table column when you create the table with a CREATE TABLE statement or a view column with a CREATE VIEW statement.\nExecute the following statements to apply the policy to a table column or a view column.\n```\n-- apply masking policy to a table column \n\n ALTER TABLE IF EXISTS user_info MODIFY COLUMN email SET MASKING POLICY email_mask ; \n\n -- apply the masking policy to a view column \n\n ALTER VIEW user_info_v MODIFY COLUMN email SET MASKING POLICY email_mask ;\n```\nCopy\nSection Title: Using Dynamic Data Masking \u00b6 > Using Dynamic Data Masking \u00b6 > Step 5: Query data in Snowflake \u00b6\nContent:\nExecute two different queries in Snowflake, one query with the ANALYST role and another query with a different role, to verify that users without the ANALYST role see a full mask.\n```\n-- using the ANALYST role \n\n USE ROLE analyst ; \n SELECT email FROM user_info ; -- should see plain text value \n\n -- using the PUBLIC role \n\n USE ROLE PUBLIC ; \n SELECT email FROM user_info ; -- should see full data mask\n```\nCopy\nSection Title: Using Dynamic Data Masking \u00b6 > Masking policy with a memoizable function \u00b6\nContent:\nThis example uses a memoizable function to cache the result of a query on the mapping table that\ndetermines whether a role is authorized to view PII data. A data engineer uses a masking policy to protect the columns in the table.\nThe following procedure references these objects:\nA table that contains PII data, `employee_data` :\nA mapping table that determines whether a particular role is authorized to view data, `auth_role_t` :\nComplete these steps to create a masking policy that calls a memoizable function with arguments:\n ... \nSection Title: Using Dynamic Data Masking \u00b6 > Additional masking policy examples \u00b6\nContent:\nThe following are additional, representative examples that can be used in the body of the Dynamic Data Masking policy.\nAllow a production account to see unmasked values and all other accounts\n(e.g. development, test) to see masked values.\nCopy\nReturn NULL for unauthorized users:\nCopy\nReturn a static masked value for unauthorized users:\nCopy\nReturn a hash value using SHA2 , SHA2_HEX for unauthorized users. Using a hashing function in a masking policy may result in collisions; therefore, exercise caution with this approach. For more information, see Advanced Column-level Security topics .\nCopy\nApply a partial mask or full mask:\nCopy\nUsing timestamps.\nSection Title: Using Dynamic Data Masking \u00b6 > Additional masking policy examples \u00b6\nContent:\nCopyImportantCurrently, Snowflake does not support different input and output data types in a masking policy, such as defining the masking policy to target a timestamp and return a string (e.g. `***MASKED***` ); the input and output data types must match.A workaround is to cast the actual timestamp value with a fabricated timestamp value. For more information, see DATE_FROM_PARTS and CAST , :: .\nUsing a UDF:\nCopy\nOn variant data:\nCopy\nUsing a custom entitlement table. Note the use of EXISTS in the WHEN clause. Always use EXISTS when including a subquery in the masking policy body. For more information on subqueries that Snowflake supports, see Working with Subqueries .\nCopy\nUsing DECRYPT on previously encrypted data with either ENCRYPT or ENCRYPT_RAW , with a passphrase on the encrypted data:\nCopy\nUsing a <JavaScript UDF on JSON (VARIANT):\nSection Title: Using Dynamic Data Masking \u00b6 > Additional masking policy examples \u00b6\nContent:\nIn this example, a JavaScript UDF masks location data in a JSON string. It is important to set the data type as VARIANT in the UDF and\nthe masking policy. If the data type in the table column, UDF, and masking policy signature do not match, Snowflake returns an error\nmessage because it cannot resolve the SQL.Copy\nUsing the GEOGRAPHY data type:\nSection Title: Using Dynamic Data Masking \u00b6 > Additional masking policy examples \u00b6\nContent:\nIn this example, a masking policy uses the TO_GEOGRAPHY function to convert all GEOGRAPHY data in a\ncolumn to a fixed point, the longitude and latitude for Snowflake in San Mateo, California, for users whose CURRENT_ROLE is not `ANALYST` .CopySet the masking policy on a column with the GEOGRAPHY data type and set the GEOGRAPHY_OUTPUT_FORMAT value for the session to `GeoJSON` :CopySnowflake returns the following:CopyThe query result values in column B depend on the GEOGRAPHY_OUTPUT_FORMAT parameter value for the session. For example, if the parameter\nvalue is set to `WKT` , Snowflake returns the following:Copy\nFor examples using other context functions and role hierarchy, see Advanced Column-level Security topics .\n**Next Topics:**\nAdvanced Column-level Security topics\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\nSection Title: Using Dynamic Data Masking \u00b6 > Additional masking policy examples \u00b6\nContent:\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nUsing Dynamic Data Masking\nMasking policy with a memoizable function\nAdditional masking policy examples\nRelated content\nUnderstanding Column-level Security\nTag-based masking policies\nLanguage: **English**\nEnglish\nFran\u00e7ais\nDeutsch\n\u65e5\u672c\u8a9e\n\ud55c\uad6d\uc5b4\nPortugu\u00eas\nSection Title: Using Dynamic Data Masking \u00b6 > Privacy Preference Center\nContent:\nYour Opt Out Preference Signal is Honored\nYour Privacy\nStrictly Necessary Cookies\nPerformance Cookies\nFunctional Cookies\nTargeting Cookies\n ... \nSection Title: Using Dynamic Data Masking \u00b6 > Privacy Preference Center > Your Privacy > Functional Cookies\nContent:\nFunctional Cookies\nThese cookies enable the website to provide enhanced functionality and personalisation. They may be set by us or by third party providers whose services we have added to our pages.    If you do not allow these cookies then some or all of these services may not function properly.\nCookies Details\u200e\n ... \nSection Title: Using Dynamic Data Masking \u00b6 > Privacy Preference Center > Cookie List\nContent:\nConsent Leg.Interest\ncheckbox label label\ncheckbox label label\ncheckbox label label\nClear\ncheckbox label label\nApply Cancel\nConfirm My Choices\nAllow All\n[](https://www.onetrust.com/products/cookie-consent/)"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/user-guide/security-row-intro",
      "title": "Understanding row access policies | Snowflake Documentation",
      "excerpts": [
        "Section Title: Understanding row access policies \u00b6\nContent:\nEnterprise Edition Feature\nThis feature requires Enterprise Edition (or higher). To inquire about upgrading,\nplease contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nThis topic provides an introduction to row access policies and row-level security.\nSection Title: Understanding row access policies \u00b6 > What is Row-level Security? \u00b6\nContent:\nSnowflake supports row-level security through the use of row access policies to determine which rows to return in the query result. The row\naccess policy can be relatively simple to allow one particular role to view rows, or be more complex to include a [mapping table](https://en.wikipedia.org/wiki/Associative_entity) in the policy definition to determine access to rows in the query\nresult. If the policy contains a mapping table lookup, create a centralized mapping table and store the mapping table in the\nsame database as the protected table. This is particularly important if the policy calls the IS_DATABASE_ROLE_IN_SESSION function. For details, see the function usage notes.\nA row access policy is a schema-level object that determines whether a given row in a table or view can be viewed from the following types\nof statements:\nSELECT statements\nRows selected by UPDATE , DELETE , and MERGE statements.\nSection Title: Understanding row access policies \u00b6 > What is Row-level Security? \u00b6\nContent:\nRow access policies can include conditions and functions in the policy expression to transform the data at query runtime when those\nconditions are met. The policy-driven approach supports segregation of duties to allow governance teams to define policies that can limit\nsensitive data exposure. This approach also includes the object owner (i.e. the role with the OWNERSHIP privilege on the object, such as a\ntable or view) who normally has full access to the underlying data. A single policy can be set on different tables and views at the same\ntime.\nRow access policies do not currently prevent rows from being inserted, or prevent visible rows from being updated or deleted.\nA row access policy can be added to a table or view either when the object is created or after the object is created. For more information, see, Apply a Row Access Policy to a Table or View (in this topic).\nNote\n ... \nSection Title: Understanding row access policies \u00b6 > What is Row-level Security? \u00b6 > Considerations \u00b6\nContent:\nExecuting queries of this type on tables and views with a row access\npolicy may take longer than expected to obtain the query results since these statistics and optimizations are not used, and the\nreturned statistics are only based on what is permissible to access, not the \u201ctrue\u201d statistical values (i.e. statistics on the\ntable or view without a row access policy). Use caution when creating the setup script for a Snowflake Native App when the row access policy exists in a versioned schema. For details, see version schema considerations . If you specify the CURRENT_DATABASE or CURRENT_SCHEMA function in the\nbody of a masking or row access policy, the function returns the database or schema that contains the protected table, not the database or\nschema in use for the session.\n ... \nSection Title: Understanding row access policies \u00b6 > ... > Snowflake Native App Framework \u00b6\nContent:\nFor details about using row access policies with a Snowflake Native App, see:\nRestrictions on sharing data content that contains policies .\nDefine policies on proxy views .\nBlocked context functions .\nSection Title: Understanding row access policies \u00b6 > ... > Streamlit in Snowflake \u00b6\nContent:\nRow access policies that are used in Streamlit in Snowflake apps have limitations with context functions in the body of a row access policy. For more information, see:\nContext functions and row access policies in Streamlit in Snowflake\nExample: Access data in a table with row access policy using CURRENT_USER"
      ]
    },
    {
      "url": "https://www.youtube.com/watch?v=y_HuLvILpyY",
      "title": "Build And Configure Secure Snowflake Native Apps - YouTube",
      "publish_date": "2024-01-03",
      "excerpts": [
        "Creating secure applications can be quite complex. In this session, Snowflake's Brad Culberson and Mike Timmerman walk through the security ... Jan 3, 2024 \u00b7 Creating secure applications can be quite complex. In this session, Snowflake's Brad Culberson and Mike Timmerman walk through the security\u00a0..."
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/user-guide/security-column-ddm-intro",
      "title": "Understanding Dynamic Data Masking | Snowflake Documentation",
      "excerpts": [
        "Section Title: Understanding Dynamic Data Masking \u00b6\nContent:\nEnterprise Edition Feature\nThis feature requires Enterprise Edition (or higher). To inquire about upgrading, please contact [Snowflake Support](https://docs.snowflake.com/user-guide/contacting-support) .\nThis topic provides a general overview of the Dynamic Data Masking feature.\nTo learn more about using a masking policy with a tag, see Tag-based masking policies .\nSection Title: Understanding Dynamic Data Masking \u00b6 > What is Dynamic Data Masking? \u00b6\nContent:\nDynamic Data Masking is a Column-level Security feature that uses masking policies to selectively mask plain-text data in table and view columns at query time.\nIn Snowflake, masking policies are schema-level objects, which means a database and schema must exist in Snowflake before a masking policy can be applied to a column. Currently, Snowflake supports using Dynamic Data Masking on tables and views.\nAt query runtime, the masking policy is applied to the column at every location where the column appears. Depending on the masking policy conditions, the SQL execution context, and role hierarchy, Snowflake query operators may see the plain-text value, a partially masked value, or a fully masked value.\nSection Title: Understanding Dynamic Data Masking \u00b6 > What is Dynamic Data Masking? \u00b6\nContent:\nFor more details about how masking policies work, including the query runtime behavior, creating a policy, usage with tables and views, and management approaches using masking policies, see: Understanding Column-level Security .\nFor more details on the effects of the SQL execution context and role hierarchy, see Advanced Column-level Security topics .\n ... \nSection Title: Understanding Dynamic Data Masking \u00b6 > Dynamic Data Masking benefits \u00b6\nContent:\nFor a comparison of benefits between Dynamic Data Masking and External Tokenization, see: Column-level Security Benefits .\nSection Title: Understanding Dynamic Data Masking \u00b6 > Dynamic Data Masking limitations \u00b6\nContent:\nFor an overview of the limitations, see Column-level Security Limitations .\nSection Title: Understanding Dynamic Data Masking \u00b6 > Dynamic Data Masking considerations \u00b6\nContent:\nFor additional Dynamic Data Masking Considerations, see Column-level Security Considerations .\n ... \nSection Title: Understanding Dynamic Data Masking \u00b6 > Troubleshooting Dynamic Data Masking \u00b6 > Error Messages \u00b6\nContent:\n| Behavior | Error Message | Troubleshooting Action |\n| Cannot apply a masking policy to a Snowflake feature. | Unsupported feature `CREATE ON MASKING POLICY COLUMN` . | Masking policies are currently not applicable to this feature. |\n| Applying a masking policy to a materialized view. | SQL compilation error: syntax error line  at position  unexpected \u2018modify\u2019. . SQL compilation error: error line  at position  invalid identifier \u2018\u2019 . SQL execution error: One or more materialized views exist on the table. number of mvs=, table name=<table_name>. | Apply the masking policy to the column(s) in the source table. For more information, see Limitations . |\nSection Title: Understanding Dynamic Data Masking \u00b6 > Troubleshooting Dynamic Data Masking \u00b6 > Error Messages \u00b6\nContent:\n| Behavior | Error Message | Troubleshooting Action |\n| Cannot apply a masking policy to a Snowflake feature. | Unsupported feature `CREATE ON MASKING POLICY COLUMN` . | Masking policies are currently not applicable to this feature. |\n| Applying a masking policy to a table column used to create a materialized view. | SQL compilation error: Masking policy cannot be attached to a MATERIALIZED_VIEW column. | To apply the masking policy to the table column, drop the materialized view. |\n| Including a masked column while creating a materialized view. | Unsupported feature \u2018CREATE ON MASKING POLICY COLUMN\u2019. | Create the materialized view without including the masked columns or do not set any masking policies on the base table or views, create the materialized view, and then apply the masking policies to the materialized view columns. |"
      ]
    },
    {
      "url": "https://docs.snowflake.com/en/release-notes/2025/other/2025-06-23-auto-privs-app-spec",
      "title": "Jun 23, 2025: Snowflake Native App Framework updates | Snowflake Documentation",
      "publish_date": "2025-06-23",
      "excerpts": [
        "[DOCUMENTATION](https://docs.snowflake.com)\n/\nGet started\nGuides\nDeveloper\nReference\nRelease notes\nTutorials\n[Status](https://status.snowflake.com)\nOverview\nRelease notes\nAll release notes\nSnowflake server release notes and feature updates\nStreamlit in Snowflake release notes\nClient, driver, and library release notes\nMonthly release notes\nClient versions & support policy\nSnowflake Connector release notes\nSnowflake Connector for Google Analytics Raw Data\nSnowflake Connector for Google Analytics Aggregate Data\nSnowflake Connector for ServiceNow V2\nSnowflake Connector for MySQL\nSnowflake Connector for PostgreSQL\nSnowflake Connector for Sharepoint\nNative SDK for Connectors\nNative SDK for Connectors Java library\nNative SDK for Connectors Java Test library\nNative SDK for Connectors Java Template\nNative SDK Example Java GitHub Connector\nBehavior changes\nBehavior change announcements\nRecent improvements\nPerformance improvements\nSQL improvements\nFeature information\nPreview features\nRelease notes Snowflake server release notes and feature updates Earlier 2025 server release notes and feature updates Feature updates Jun 23, 2025 - Snowflake Native App Framework\nSection Title: Jun 23, 2025: Snowflake Native App Framework updates \u00b6\nContent:\nThe Snowflake Native App Framework now includes the following features that make it easier for providers\nto develop an app to create objects in a consumer account. These features also\nmake it easier for consumers to configure an app during installation and upgrade.\nFor general information on these features, see Create and access objects in a consumer account .\nSection Title: ... > Automated granting of privileges ( *Preview* ) \u00b6\nContent:\nThis feature allows providers to specify in the manifest file the privileges required by an app.\nWhen a consumer installs or upgrades an app, Snowflake grants these privileges to the app. For\nmore information, see Configure the privileges required by an app .\nConsumers can use feature policies to override the automatic grants for an app. For more\ninformation, see Use feature policies to limit the objects an app can create .\nSection Title: Jun 23, 2025: Snowflake Native App Framework updates \u00b6 > App specifications ( *Preview* ) \u00b6\nContent:\nApp specifications allow providers to request permission from the consumer to allow connections\noutside Snowflake that use external access integrations or security integrations. Consumers must\napprove the app specification for these objects when configuring the app after installation or\nupgrade.\nFor more information, see Overview of app specifications .\nWas this page helpful?\nYes No\n[Visit Snowflake](https://www.snowflake.com)\n[Join the conversation](https://community.snowflake.com/s/)\n[Develop with Snowflake](https://developers.snowflake.com)\nShare your feedback\n[Read the latest on our blog](https://www.snowflake.com/blog/)\n[Get your own certification](https://learn.snowflake.com)\nOn this page\nAutomated granting of privileges (Preview)\nApp specifications (Preview)\nLanguage: **English**\nEnglish\nFran\u00e7ais\nDeutsch\n\u65e5\u672c\u8a9e\n\ud55c\uad6d\uc5b4\nPortugu\u00eas"
      ]
    },
    {
      "url": "https://snowflakechronicles.medium.com/snowflake-view-security-a-practical-guide-to-regular-vs-secure-views-67035a6bc1f8",
      "title": "Snowflake View Security: A Practical Guide to Regular vs Secure Views | by Satish Kumar | Medium",
      "publish_date": "2025-04-06",
      "excerpts": [
        "Sitemap\n[Open in app](https://play.google.com/store/apps/details?id=com.medium.reader&referrer=utm_source%3DmobileNavBar&source=post_page---top_nav_layout_nav-----------------------------------------)\n[](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)\n[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\n[Search](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)\n ... \nSection Title: Snowflake View Security: A Practical Guide to Regular vs Secure Views\nContent:\nSnowflake\u2019s flexible access control and security model helps data teams balance usability with confidentiality. One area where this balance is particularly critical is **view security** .\nIn this post, we\u2019ll walk through:\nThe difference between *regular* and *secure* views in Snowflake\nHow Snowflake handles permissions for views vs. underlying tables\nA hands-on test scenario, with full setup and teardown scripts\nRecommendations for production-grade secure data modeling\nLet\u2019s get started.\nSection Title: ... > Why Views Matter for Security\nContent:\nViews in Snowflake allow you to abstract logic, define reusable business rules, and apply masking or filtering policies without exposing raw data. But what kind of protection do they really offer?\nLet\u2019s look at the two options available in Snowflake:\n ... \nSection Title: Snowflake View Security: A Practical Guide to Regular vs Secure Views > Secure Views\nContent:\nSecure views are a powerful enhancement that hide the underlying SQL logic, prevent certain types of inference attacks, and are a requirement for row-level security.\n```\nCREATE SECURE VIEW secure_view AS   \nSELECT id, name FROM employees;\n```\nSecure views:\nPrevent predicate pushdown\nObfuscate query logic in execution plans\nAre the only view type that supports **row access** and **masking policies**\nThey\u2019re ideal for protecting **PII** , **financial** , or **regulated** data.\n ... \nSection Title: ... > When Should You Use Secure Views?\nContent:\nPress enter or click to view image in full size\nSecure views add a layer of confidence, especially when combining with:\nRow-level security policies\nDynamic masking\nFederated access or service accounts\nQuery audits via `ACCOUNT_USAGE.QUERY_HISTORY`\nSection Title: ... > Example: Secure View + Row-Level Security\nContent:\n```\nCREATE ROW ACCESS POLICY filter_by_department AS  \n  (department STRING) RETURNS BOOLEAN ->  \n  CURRENT_ROLE() = 'HR_ADMIN' OR department = CURRENT_DEPARTMENT();  \n  \nALTER SECURE VIEW secure_view   \n  ADD ROW ACCESS POLICY filter_by_department ON (department);\n```\nSection Title: Snowflake View Security: A Practical Guide to Regular vs Secure Views > Key Takeaways\nContent:\nBoth view types work without base table access in Snowflake.\nSecure views protect against data leaks, inference attacks, and exposure of logic.\nSecure views are foundational for RLS and compliance-heavy environments.\nSection Title: Snowflake View Security: A Practical Guide to Regular vs Secure Views > Try It Yourself\nContent:\nWhether you\u2019re a Snowflake admin or architect, understanding how **view security actually works** helps you build safer, smarter, and cleaner data models. Please use the full script above, experiment in a dev environment, and audit your existing views for upgrade opportunities.\n\\ #DataPlatform #CloudSecurity #SQLViews #SecureViews #RLS #DataPrivacy #LearnSnowflake #ModernDataStack\n\u201cTell me and I forget, teach me and I may remember, involve me and I learn.\u201d \u2014 Benjamin Franklin\n[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fp%2F67035a6bc1f8&operation=register&redirect=https%3A%2F%2Fsnowflakechronicles.medium.com%2Fsnowflake-view-security-a-practical-guide-to-regular-vs-secure-views-67035a6bc1f8&user=Satish+Kumar&userId=d170d49944ec&source=---footer_actions--67035a6bc1f8---------------------clap_footer------------------)"
      ]
    }
  ],
  "usage": [
    {
      "name": "sku_search",
      "count": 1
    }
  ]
}
